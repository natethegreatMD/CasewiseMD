{"version":3,"file":"2011.bundle.10547efd2a04052b5c25.js","mappings":"uJAEA,IAAIA,EAAS,CAAC,EACP,SAASC,IACZ,OAAOD,CACX,CACO,SAASE,EAAUC,GACtBH,EAASG,CACb,CAIA,IAAIC,GAAqB,EAClB,SAASC,IACZ,IAAKL,EAAOM,QAAQC,QAEhB,OADAC,QAAQC,KAAK,6SACN,KAEX,MAAMC,EAAUV,EAAOM,OAAOC,QAK9B,OAJKH,IACDM,EAAQC,OACRP,GAAqB,GAElBM,CACX,C,gDCxBA,MAiQA,EAjQ8B,CAC1B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,I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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/config.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawFan.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/init.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getAnnotationMapFromSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getPolylineMap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/extractSegmentPolylines.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/decimateContours.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeCompleteContourAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeContourIslands.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/smoothContours.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/UltrasoundPleuraBLineTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/calculateFanShapeCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/deriveFanGeometry.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/generateConvexHullFromContour.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/segmentLargestUSOutlineFromBuffer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapEditWithContour.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/contourSegmentationOperation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getIntersectingAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/convertContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addPolylinesToSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/logicalOperators.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/mergeMultipleAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/sharedOperations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/unifyPolylineSets.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findIslands.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/version.js","webpack:///../../../node_modules/lodash.get/index.js"],"sourcesContent":["import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from './enums/Events';\nlet config = {};\nexport function getConfig() {\n    return config;\n}\nexport function setConfig(newConfig) {\n    config = newConfig;\n}\nexport function getAddOns() {\n    return config.addons;\n}\nlet polysegInitialized = false;\nexport function getPolySeg() {\n    if (!config.addons?.polySeg) {\n        console.warn('PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } }).');\n        return null;\n    }\n    const polyseg = config.addons.polySeg;\n    if (!polysegInitialized) {\n        polyseg.init();\n        polysegInitialized = true;\n    }\n    return polyseg;\n}\n","const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n    'alias',\n    'all-scroll',\n    'auto',\n    'cell',\n    'col-resize',\n    'context-menu',\n    'copy',\n    'crosshair',\n    'default',\n    'e-resize',\n    'ew-resize',\n    'grab',\n    'grabbing',\n    'help',\n    'move',\n    'ne-resize',\n    'nesw-resize',\n    'no-drop',\n    'none',\n    'not-allowed',\n    'n-resize',\n    'ns-resize',\n    'nw-resize',\n    'nwse-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    'se-resize',\n    's-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'wait',\n    'w-resize',\n    'zoom-in',\n    'zoom-out',\n]);\nexport default class MouseCursor {\n    constructor(name, fallback) {\n        this.name = name + '';\n        this.fallback = fallback;\n    }\n    getName() {\n        return this.name + '';\n    }\n    addFallbackStyleProperty(style) {\n        const { fallback } = this;\n        if (fallback instanceof MouseCursor) {\n            return `${style}, ${fallback.getStyleProperty()}`;\n        }\n        return style + '';\n    }\n    getStyleProperty() {\n        return this.addFallbackStyleProperty(this.name) + '';\n    }\n    static getDefinedCursor(name) {\n        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n        let mouseCursor = definedCursors.get(name);\n        if (mouseCursor instanceof MouseCursor) {\n            return mouseCursor;\n        }\n        if (STANDARD_CURSORS.has(name)) {\n            mouseCursor = new MouseCursor(name);\n            definedCursors.set(name, mouseCursor);\n            return mouseCursor;\n        }\n    }\n    static setDefinedCursor(name, cursor) {\n        if (cursor instanceof MouseCursor) {\n            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n            definedCursors.set(name, cursor);\n            return true;\n        }\n        return false;\n    }\n}\nfunction getDefinedCursors(context, symbol) {\n    let definedCursors = context[symbol];\n    if (!(definedCursors instanceof Map)) {\n        definedCursors = new Map();\n        Object.defineProperty(context, symbol, { value: definedCursors });\n    }\n    return definedCursors;\n}\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import MouseCursor from './MouseCursor';\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\nfunction initElementCursor(element, cursor) {\n    _getElementCursors(element)[0] = cursor;\n    _setElementCursor(element, cursor);\n}\nfunction _setElementCursor(element, cursor) {\n    const cursors = _getElementCursors(element);\n    cursors[1] = cursors[0];\n    cursors[0] = cursor;\n    element.style.cursor = (cursor instanceof MouseCursor\n        ? cursor\n        : MouseCursor.getDefinedCursor('auto')).getStyleProperty();\n}\nfunction resetElementCursor(element) {\n    _setElementCursor(element, _getElementCursors(element)[1]);\n}\nfunction hideElementCursor(element) {\n    _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\nfunction _getElementCursors(element) {\n    let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n    if (!(map instanceof WeakMap)) {\n        map = new WeakMap();\n        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n            value: map,\n        });\n    }\n    let cursors = map.get(element);\n    if (!cursors) {\n        cursors = [null, null];\n        map.set(element, cursors);\n    }\n    return cursors;\n}\nexport { initElementCursor, resetElementCursor, hideElementCursor, _setElementCursor as setElementCursor, };\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\nconst DEFAULT_NAME = 'image-cursor';\nexport default class ImageMouseCursor extends MouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);\n        this.url = url;\n        this.x = Number(x) || 0;\n        this.y = Number(y) || 0;\n    }\n    getStyleProperty() {\n        const { url, x, y } = this;\n        let style = `url('${url}')`;\n        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n            style += ` ${x} ${y}`;\n        }\n        return this.addFallbackStyleProperty(style);\n    }\n    static getUniqueInstanceName(prefix) {\n        return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n    }\n}\n","const BASE = {\n    iconContent: '',\n    iconSize: 16,\n    viewBox: {\n        x: 16,\n        y: 16,\n    },\n    mousePoint: {\n        x: 8,\n        y: 8,\n    },\n    mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n    x: 127,\n    y: 60,\n};\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CursorSVG = {\n    Angle: extend(BASE, {\n        name: 'Angle',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    ArrowAnnotate: extend(BASE, {\n        name: 'ArrowAnnotate',\n        iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Bidirectional: extend(BASE, {\n        name: 'Bidirectional',\n        iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n        viewBox: {\n            x: 48,\n            y: 48,\n        },\n    }),\n    CobbAngle: extend(BASE, {\n        name: 'CobbAngle',\n        iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    CircleROI: extend(BASE, {\n        name: 'CircleROI',\n        iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    EllipticalROI: extend(BASE, {\n        name: 'EllipticalROI',\n        iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    FreehandROI: extend(BASE, {\n        name: 'FreehandROI',\n        iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    FreehandROISculptor: extend(BASE, {\n        name: 'FreehandROISculptor',\n        iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Length: extend(BASE, {\n        name: 'Length',\n        iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Height: extend(BASE, {\n        name: 'Height',\n        iconContent: `<path d=\"m 6 22 l 8.5 0 v -16 h 8\" stroke-width=\"3\" fill=\"none\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Probe: extend(BASE, {\n        name: 'Probe',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    RectangleROI: extend(BASE, {\n        name: 'RectangleROI',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Label: extend(BASE, {\n        name: 'Label',\n        iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Crosshairs: extend(BASE, {\n        name: 'Crosshairs',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Eraser: extend(BASE, {\n        name: 'Eraser',\n        iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n        viewBox: {\n            x: 2048,\n            y: 1792,\n        },\n    }),\n    Magnify: extend(BASE, {\n        name: 'Magnify',\n        iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n        viewBox: {\n            x: 512,\n            y: 512,\n        },\n    }),\n    Pan: extend(BASE, {\n        name: 'Pan',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Rotate: extend(BASE, {\n        name: 'Rotate',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    StackScroll: extend(BASE, {\n        name: 'StackScroll',\n        iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n        viewBox: {\n            x: 24,\n            y: 28,\n        },\n    }),\n    WindowLevelRegion: extend(BASE, {\n        name: 'WindowLevelRegion',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    WindowLevel: extend(BASE, {\n        name: 'WindowLevel',\n        iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Zoom: extend(BASE, {\n        name: 'Zoom',\n        iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n        viewBox: {\n            x: 640,\n            y: 512,\n        },\n    }),\n    SegmentationFreeHandEraseInside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseInside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillInside: extend(BASE, {\n        name: 'SegmentationFreeHandFillInside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandEraseOutside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseOutside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillOutside: extend(BASE, {\n        name: 'SegmentationFreeHandFillOutside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationRectangleEraseInside: extend(BASE, {\n        name: 'SegmentationRectangleEraseInside',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    RectangleScissor: extend(BASE, {\n        name: 'RectangleScissor',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    CircleScissor: extend(BASE, {\n        name: 'CircleScissor',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_INSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.ERASE_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n};\nfunction extend(base, values) {\n    return Object.assign(Object.create(base), {\n        ...values,\n        name: values.name || base.name,\n    });\n}\nfunction registerCursor(toolName, iconContent, viewBox) {\n    CursorSVG[toolName] = extend(BASE, {\n        iconContent,\n        viewBox,\n    });\n}\nfunction getDefinedSVGCursorDescriptor(name) {\n    return CursorSVG[name];\n}\nconst svgCursorNames = Object.keys(CursorSVG);\nexport { getDefinedSVGCursorDescriptor, registerCursor, svgCursorNames, CursorSVG, };\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\nexport default class SVGMouseCursor extends ImageMouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(url, x, y, name, fallback);\n    }\n    static getDefinedCursor(name, pointer = false, color) {\n        if (!color) {\n            color = getStyleProperty(PROPERTY, {}, STATE, MODE);\n        }\n        const urn = getCursorURN(name, pointer, color);\n        let cursor = super.getDefinedCursor(urn);\n        if (!cursor) {\n            const descriptor = getDefinedSVGCursorDescriptor(name);\n            if (descriptor) {\n                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));\n                super.setDefinedCursor(urn, cursor);\n            }\n        }\n        return cursor;\n    }\n}\nfunction format(template, dictionary) {\n    const dict = Object(dictionary);\n    const defined = Object.prototype.hasOwnProperty.bind(dict);\n    return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n        return defined(key) ? dict[key] + '' : '';\n    });\n}\nfunction getCursorURN(name, pointer, color) {\n    const type = pointer ? 'pointer' : 'cursor';\n    return `${type}:${name}/${color}`;\n}\nfunction createSVGMouseCursor(descriptor, name, pointer, color, fallback) {\n    const { x, y } = descriptor.mousePoint;\n    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);\n}\nfunction createSVGIconUrl(descriptor, pointer, options) {\n    const blob = createSVGIconBlob(descriptor, pointer, options);\n    const url = URL.createObjectURL(blob);\n    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;\n    return urn;\n}\nfunction createSVGIconBlob(descriptor, pointer, options) {\n    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);\n    return new Blob([svgString], { type: 'image/svg+xml' });\n}\nfunction createSVGIcon(descriptor, options) {\n    const { iconContent, iconSize, viewBox } = descriptor;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n    return format(svgString, options);\n}\nfunction createSVGIconWithPointer(descriptor, options) {\n    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;\n    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n    const svgSize = 16 + iconSize;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n    return format(svgString, options);\n}\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nfunction setCursorForElement(element, cursorName) {\n    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n    if (!cursor) {\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    if (!cursor) {\n        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    setElementCursor(element, cursor);\n}\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport { registerCursor, svgCursorNames, CursorSVG, } from './SVGCursorDescriptor';\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\nexport { MouseCursor, ImageMouseCursor, SVGMouseCursor, elementCursor, registerCursor, CursorNames, CursorSVG, setCursorForElement, };\n","import _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\nfunction drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {\n    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];\n    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];\n    drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));\n}\nexport default drawEllipse;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [bottom, top, left, right] = canvasCoordinates;\n    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipseByCoordinates;\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {\n    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);\n    let attributes;\n    if (type === 'circle') {\n        attributes = {\n            cx: `${handle[0]}`,\n            cy: `${handle[1]}`,\n            r: handleRadius,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            opacity: opacity,\n        };\n    }\n    else if (type === 'rect') {\n        const handleRadiusFloat = parseFloat(handleRadius);\n        const side = handleRadiusFloat * 1.5;\n        const x = handle[0] - side * 0.5;\n        const y = handle[1] - side * 0.5;\n        attributes = {\n            x: `${x}`,\n            y: `${y}`,\n            width: `${side}`,\n            height: `${side}`,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            rx: `${side * 0.1}`,\n            opacity: opacity,\n        };\n    }\n    else {\n        throw new Error(`Unsupported handle type: ${type}`);\n    }\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingHandleElement) {\n        setAttributesIfNecessary(attributes, existingHandleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newHandleElement = document.createElementNS(svgns, type);\n        setNewAttributesIfValid(attributes, newHandleElement);\n        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n}\nexport default drawHandle;\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, lineWidth, lineDash, markerStartId = null, markerEndId = null, shadow = false, strokeOpacity = 1, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const dropShadowStyle = shadow ? `filter:url(#shadow-${layerId});` : '';\n    const attributes = {\n        x1: `${start[0]}`,\n        y1: `${start[1]}`,\n        x2: `${end[0]}`,\n        y2: `${end[1]}`,\n        stroke: color,\n        style: dropShadowStyle,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'marker-start': markerStartId ? `url(#${markerStartId})` : '',\n        'marker-end': markerEndId ? `url(#${markerEndId})` : '',\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingLine) {\n        setAttributesIfNecessary(attributes, existingLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newLine = document.createElementNS(svgns, 'line');\n        if (dataId !== '') {\n            newLine.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newLine);\n        svgDrawingHelper.appendNode(newLine, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {\n    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);\n    const pointsArrays = hasSubArrays ? points : [points];\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n        const points = pointsArrays[i];\n        const numPoints = points.length;\n        if (numPoints < 2) {\n            continue;\n        }\n        for (let j = 0; j < numPoints; j++) {\n            const point = points[j];\n            const cmd = j ? 'L' : 'M';\n            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n        }\n        if (closePath) {\n            pointsAttribute += 'Z ';\n        }\n    }\n    if (!pointsAttribute) {\n        return;\n    }\n    const attributes = {\n        d: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingNode) {\n        setAttributesIfNecessary(attributes, existingNode);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newNode = document.createElementNS(svgns, 'path');\n        setNewAttributesIfValid(attributes, newNode);\n        svgDrawingHelper.appendNode(newNode, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {\n    if (points.length < 2) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, markerStartId = null, markerEndId = null, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (const point of points) {\n        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n    }\n    if (closePath) {\n        const firstPoint = points[0];\n        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n    }\n    const attributes = {\n        points: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'marker-start': markerStartId ? `url(#${markerStartId})` : '',\n        'marker-end': markerEndId ? `url(#${markerEndId})` : '',\n    };\n    if (existingPolyLine) {\n        setAttributesIfNecessary(attributes, existingPolyLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newPolyLine = document.createElementNS(svgns, 'polyline');\n        setNewAttributesIfValid(attributes, newPolyLine);\n        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;\n    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);\n    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);\n    const center = [\n        (bottomRight[0] + topLeft[0]) / 2,\n        (bottomRight[1] + topLeft[1]) / 2,\n    ];\n    const leftEdgeCenter = [\n        (bottomLeft[0] + topLeft[0]) / 2,\n        (bottomLeft[1] + topLeft[1]) / 2,\n    ];\n    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *\n        180) /\n        Math.PI;\n    const attributes = {\n        x: `${center[0] - width / 2}`,\n        y: `${center[1] - height / 2}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        if (dataId !== '') {\n            svgRectElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {\n    const mergedOptions = Object.assign({\n        fontFamily: 'Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        color: 'rgb(255, 255, 0)',\n        background: '',\n        padding: 25,\n        centerX: false,\n        centerY: true,\n    }, options);\n    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);\n    return textGroupBoundingBox;\n}\nfunction _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {\n    const { padding, color, fontFamily, fontSize, background } = options;\n    let textGroupBoundingBox;\n    const [x, y] = [position[0] + padding, position[1] + padding];\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingTextGroup) {\n        const textElement = existingTextGroup.querySelector('text');\n        const textSpans = Array.from(textElement.children);\n        for (let i = 0; i < textSpans.length; i++) {\n            const textSpanElement = textSpans[i];\n            const text = textLines[i] || '';\n            textSpanElement.textContent = text;\n        }\n        if (textLines.length > textSpans.length) {\n            for (let i = 0; i < textLines.length - textSpans.length; i++) {\n                const textLine = textLines[i + textSpans.length];\n                const textSpan = _createTextSpan(textLine);\n                textElement.appendChild(textSpan);\n            }\n            existingTextGroup.appendChild(textElement);\n            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n        }\n        const textAttributes = {\n            fill: color,\n            'font-size': fontSize,\n            'font-family': fontFamily,\n        };\n        const textGroupAttributes = {\n            transform: `translate(${x} ${y})`,\n        };\n        setAttributesIfNecessary(textAttributes, textElement);\n        setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n        existingTextGroup.setAttribute('data-annotation-uid', annotationUID);\n        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const textGroup = document.createElementNS(svgns, 'g');\n        textGroup.setAttribute('data-annotation-uid', annotationUID);\n        textGroup.setAttribute('transform', `translate(${x} ${y})`);\n        const textElement = _createTextElement(svgDrawingHelper, options);\n        for (let i = 0; i < textLines.length; i++) {\n            const textLine = textLines[i];\n            const textSpan = _createTextSpan(textLine);\n            textElement.appendChild(textSpan);\n        }\n        textGroup.appendChild(textElement);\n        svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n        textGroupBoundingBox = _drawTextBackground(textGroup, background);\n    }\n    return Object.assign({}, textGroupBoundingBox, {\n        x,\n        y,\n        height: textGroupBoundingBox.height + padding,\n        width: textGroupBoundingBox.width + padding,\n    });\n}\nfunction _createTextElement(svgDrawingHelper, options) {\n    const { color, fontFamily, fontSize } = options;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textElement = document.createElementNS(svgns, 'text');\n    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n    textElement.setAttribute('x', '0');\n    textElement.setAttribute('y', '0');\n    textElement.setAttribute('fill', color);\n    textElement.setAttribute('font-family', fontFamily);\n    textElement.setAttribute('font-size', fontSize);\n    textElement.setAttribute('style', combinedStyle);\n    textElement.setAttribute('pointer-events', 'visible');\n    return textElement;\n}\nfunction _createTextSpan(text) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textSpanElement = document.createElementNS(svgns, 'tspan');\n    textSpanElement.setAttribute('x', '0');\n    textSpanElement.setAttribute('dy', '1.2em');\n    textSpanElement.textContent = text;\n    return textSpanElement;\n}\nfunction _drawTextBackground(group, color) {\n    let element = group.querySelector('rect.background');\n    if (!color) {\n        if (element) {\n            group.removeChild(element);\n        }\n        return group.getBBox();\n    }\n    if (!element) {\n        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        element.setAttribute('class', 'background');\n        group.insertBefore(element, group.firstChild);\n    }\n    const bBox = group.getBBox();\n    const attributes = {\n        x: `${bBox.x}`,\n        y: `${bBox.y}`,\n        width: `${bBox.width}`,\n        height: `${bBox.height}`,\n        fill: color,\n    };\n    setAttributesIfNecessary(attributes, element);\n    return bBox;\n}\nexport default drawTextBox;\n","import drawLine from './drawLine';\nexport default function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const midX = end[0] + (start[0] - end[0]) / 2;\n    const endfirstLine = [midX, start[1]];\n    const endsecondLine = [midX, end[1]];\n    const firstLine = {\n        start: start,\n        end: endfirstLine,\n    };\n    const secondLine = {\n        start: endfirstLine,\n        end: endsecondLine,\n    };\n    const threeLine = {\n        start: endsecondLine,\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawFan(svgDrawingHelper, annotationUID, fanUID, center, innerRadius, outerRadius, startAngle, endAngle, options = {}, dataId = '', zIndex) {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'fan', fanUID);\n    const existingFanElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const startRad = (startAngle * Math.PI) / 180;\n    const endRad = (endAngle * Math.PI) / 180;\n    const centerX = center[0];\n    const centerY = center[1];\n    const outerStartX = centerX + outerRadius * Math.cos(startRad);\n    const outerStartY = centerY + outerRadius * Math.sin(startRad);\n    const outerEndX = centerX + outerRadius * Math.cos(endRad);\n    const outerEndY = centerY + outerRadius * Math.sin(endRad);\n    const innerStartX = centerX + innerRadius * Math.cos(startRad);\n    const innerStartY = centerY + innerRadius * Math.sin(startRad);\n    const innerEndX = centerX + innerRadius * Math.cos(endRad);\n    const innerEndY = centerY + innerRadius * Math.sin(endRad);\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n    let pathData = `M ${outerStartX} ${outerStartY}`;\n    pathData += ` A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEndX} ${outerEndY}`;\n    pathData += ` L ${innerEndX} ${innerEndY}`;\n    pathData += ` A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY}`;\n    pathData += ` Z`;\n    const attributes = {\n        d: pathData,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n        'mix-blend-mode': 'normal',\n    };\n    if (existingFanElement) {\n        setAttributesIfNecessary(attributes, existingFanElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newFanElement = document.createElementNS(svgns, 'path');\n        if (dataId !== '') {\n            newFanElement.setAttribute('data-id', dataId);\n        }\n        if (zIndex !== undefined) {\n            newFanElement.style.zIndex = zIndex.toString();\n        }\n        setNewAttributesIfValid(attributes, newFanElement);\n        svgDrawingHelper.appendNode(newFanElement, svgNodeHash);\n    }\n}\nexport default drawFan;\n","import drawLine from './drawLine';\nconst svgns = 'http://www.w3.org/2000/svg';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;\n    if (!viaMarker) {\n        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n        return;\n    }\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const markerBaseId = `arrow-${annotationUID}`;\n    const markerFullId = `${markerBaseId}-${layerId}`;\n    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');\n    let arrowMarker = defs.querySelector(`#${markerFullId}`);\n    if (!arrowMarker) {\n        arrowMarker = document.createElementNS(svgns, 'marker');\n        arrowMarker.setAttribute('id', markerFullId);\n        arrowMarker.setAttribute('viewBox', '0 0 10 10');\n        arrowMarker.setAttribute('refX', '8');\n        arrowMarker.setAttribute('refY', '5');\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        arrowMarker.setAttribute('orient', 'auto');\n        const arrowPath = document.createElementNS(svgns, 'path');\n        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        arrowPath.setAttribute('fill', color);\n        arrowMarker.appendChild(arrowPath);\n        defs.appendChild(arrowMarker);\n    }\n    else {\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        const arrowPath = arrowMarker.querySelector('path');\n        if (arrowPath) {\n            arrowPath.setAttribute('fill', color);\n        }\n    }\n    options.markerEndId = markerFullId;\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n}\nfunction legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'black',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","export function setAttributesIfNecessary(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const currentValue = svgNode.getAttribute(key);\n        const newValue = attributes[key];\n        if (newValue === undefined || newValue === '') {\n            svgNode.removeAttribute(key);\n        }\n        else if (currentValue !== newValue) {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const newValue = attributes[key];\n        if (newValue !== undefined && newValue !== '') {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setNewAttributesIfValid;\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\nconst enable = function () {\n    eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.addEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nconst disable = function () {\n    eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.removeEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraReset = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onResetCamera) {\n            tool.onResetCamera(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\nconst onImageRendered = function (evt) {\n    triggerAnnotationRender(evt.detail.element);\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.KEY_DOWN, keyDown);\n    element.addEventListener(Events.KEY_UP, keyUp);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.KEY_DOWN, keyDown);\n    element.removeEventListener(Events.KEY_UP, keyUp);\n};\nconst keyboardToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default keyboardToolEventDispatcher;\n","import Events from '../enums/Events';\nimport { mouseClick, mouseDown, mouseDownActivate, mouseDoubleClick, mouseDrag, mouseMove, mouseUp, mouseWheel, } from './mouseEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.addEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.addEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.addEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.addEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.addEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.addEventListener(Events.MOUSE_UP, mouseUp);\n    element.addEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.removeEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.removeEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.removeEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.removeEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.removeEventListener(Events.MOUSE_UP, mouseUp);\n    element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst mouseToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default mouseToolEventDispatcher;\n","import Events from '../enums/Events';\nimport { touchStart, touchStartActivate, touchDrag, touchEnd, touchTap, touchPress, } from './touchEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.TOUCH_START, touchStart);\n    element.addEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.addEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.addEventListener(Events.TOUCH_END, touchEnd);\n    element.addEventListener(Events.TOUCH_TAP, touchTap);\n    element.addEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.TOUCH_START, touchStart);\n    element.removeEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.removeEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.removeEventListener(Events.TOUCH_END, touchEnd);\n    element.removeEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst touchToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default touchToolEventDispatcher;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, { mouseDoubleClickIgnoreListener, } from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\nfunction disable(element) {\n    element.removeEventListener('dblclick', mouseDoubleClickListener);\n    element.removeEventListener('mousedown', mouseDownListener);\n    element.removeEventListener('mousemove', mouseMoveListener);\n    element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('dblclick', mouseDoubleClickListener);\n    element.addEventListener('mousedown', mouseDownListener);\n    element.addEventListener('mousemove', mouseMoveListener);\n    element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\nfunction disable(element) {\n    preventGhostClick.disable(element);\n    element.removeEventListener('touchstart', touchStartListener);\n}\nfunction enable(element) {\n    disable(element);\n    preventGhostClick.enable(element);\n    element.addEventListener('touchstart', touchStartListener, {\n        passive: false,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import wheelListener from './wheelListener';\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('wheel', wheelListener, { passive: false });\n}\nfunction disable(element) {\n    element.removeEventListener('wheel', wheelListener);\n}\nexport default {\n    enable,\n    disable,\n};\n","import { VolumeViewport, getEnabledElementByViewportId, StackViewport, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { performVolumeLabelmapUpdate } from './performVolumeLabelmapUpdate';\nimport { performStackLabelmapUpdate } from './performStackLabelmapUpdate';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nconst onLabelmapSegmentationDataModified = function (evt) {\n    const { segmentationId, modifiedSlicesToUse } = evt.detail;\n    const { representationData } = getSegmentation(segmentationId);\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    const hasVolumeViewport = viewportIds.some((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        return viewport instanceof VolumeViewport;\n    });\n    const hasStackViewport = viewportIds.some((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        return viewport instanceof StackViewport;\n    });\n    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;\n    viewportIds.forEach((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        if (viewport instanceof VolumeViewport) {\n            performVolumeLabelmapUpdate({\n                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,\n                representationData,\n                type: SegmentationRepresentations.Labelmap,\n            });\n        }\n        if (viewport instanceof StackViewport) {\n            performStackLabelmapUpdate({\n                viewportIds,\n                segmentationId,\n            });\n        }\n    });\n};\nexport default onLabelmapSegmentationDataModified;\n","import { cache } from '@cornerstonejs/core';\nexport function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {\n    const segmentationVolume = cache.getVolume(representationData[type].volumeId);\n    if (!segmentationVolume) {\n        console.warn('segmentation not found in cache');\n        return;\n    }\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n    let slicesToUpdate;\n    if (modifiedSlicesToUse?.length > 0) {\n        slicesToUpdate = modifiedSlicesToUse;\n    }\n    else {\n        const numSlices = imageData.getDimensions()[2];\n        slicesToUpdate = [...Array(numSlices).keys()];\n    }\n    slicesToUpdate.forEach((i) => {\n        vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n    imageData.modified();\n}\n","import { cache, utilities as csUtils, VolumeViewport, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { getLabelmapActorEntries } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nexport function performStackLabelmapUpdate({ viewportIds, segmentationId, }) {\n    viewportIds.forEach((viewportId) => {\n        let representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n        representations.forEach((representation) => {\n            if (representation.segmentationId !== segmentationId) {\n                return;\n            }\n            const enabledElement = getEnabledElementByViewportId(viewportId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            if (viewport instanceof VolumeViewport) {\n                return;\n            }\n            const actorEntries = getLabelmapActorEntries(viewportId, segmentationId);\n            if (!actorEntries?.length) {\n                return;\n            }\n            actorEntries.forEach((actorEntry, i) => {\n                const segImageData = actorEntry.actor.getMapper().getInputData();\n                const currentSegmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n                const segmentationImage = cache.getImage(currentSegmentationImageIds[i]);\n                segImageData.modified();\n                csUtils.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);\n            });\n        });\n    });\n}\n","import { triggerSegmentationRenderBySegmentationId } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nconst onSegmentationDataModified = function (evt) {\n    const { segmentationId } = evt.detail;\n    const { representationData } = getSegmentation(segmentationId);\n    if (representationData.Labelmap) {\n        onLabelmapSegmentationDataModified(evt);\n    }\n    triggerSegmentationRenderBySegmentationId(segmentationId);\n};\nexport default onSegmentationDataModified;\n","import { triggerSegmentationRenderBySegmentationId } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nconst segmentationModifiedListener = function (evt) {\n    const { segmentationId } = evt.detail;\n    triggerSegmentationRenderBySegmentationId(segmentationId);\n};\nexport default segmentationModifiedListener;\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { BaseVolumeViewport, getEnabledElement, Enums, getEnabledElementByIds, cache, utilities, } from '@cornerstonejs/core';\nimport { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport { updateLabelmapSegmentationImageReferences } from '../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getLabelmapActorEntries } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nconst enable = function (element) {\n    if (!element) {\n        return;\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (viewport instanceof BaseVolumeViewport) {\n        return;\n    }\n    element.addEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst perViewportManualTriggers = new Map();\nfunction _imageChangeEventListener(evt) {\n    const eventData = evt.detail;\n    const { viewportId, renderingEngineId } = eventData;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const representations = getSegmentationRepresentations(viewportId);\n    if (!representations?.length) {\n        return;\n    }\n    const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n    const actors = viewport.getActors();\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n    });\n    const labelmapActors = labelmapRepresentations\n        .flatMap((representation) => {\n        return getLabelmapActorEntries(viewportId, representation.segmentationId);\n    })\n        .filter((actor) => actor !== undefined);\n    if (!labelmapActors.length) {\n        return;\n    }\n    labelmapActors.forEach((actor) => {\n        const validActor = labelmapRepresentations.find((representation) => {\n            const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, representation.segmentationId);\n            return derivedImageIds?.includes(actor.referencedId);\n        });\n        if (!validActor) {\n            viewport.removeActors([actor.uid]);\n        }\n    });\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        const currentImageId = viewport.getCurrentImageId();\n        const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n        if (!derivedImageIds) {\n            return;\n        }\n        const updateSegmentationActor = (derivedImageId) => {\n            const derivedImage = cache.getImage(derivedImageId);\n            if (!derivedImage) {\n                console.warn('No derived image found in the cache for segmentation representation', representation);\n                return;\n            }\n            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);\n            if (!segmentationActorInput) {\n                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);\n                const currentImage = cache.getImage(currentImageId) ||\n                    {\n                        imageId: currentImageId,\n                    };\n                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);\n                const originToUse = currentOrigin;\n                const constructor = derivedImage.voxelManager.getConstructor();\n                const newPixelData = derivedImage.voxelManager.getScalarData();\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: new constructor(newPixelData),\n                });\n                const imageData = vtkImageData.newInstance();\n                imageData.setDimensions(dimensions[0], dimensions[1], 1);\n                imageData.setSpacing(spacing);\n                imageData.setDirection(direction);\n                imageData.setOrigin(originToUse);\n                imageData.getPointData().setScalars(scalarArray);\n                imageData.modified();\n                viewport.addImages([\n                    {\n                        imageId: derivedImageId,\n                        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,\n                        callback: ({ imageActor }) => {\n                            imageActor.getMapper().setInputData(imageData);\n                        },\n                    },\n                ]);\n                triggerSegmentationRender(viewportId);\n                return;\n            }\n            else {\n                const segmentationImageData = segmentationActorInput.actor\n                    .getMapper()\n                    .getInputData();\n                if (segmentationImageData.setDerivedImage) {\n                    segmentationImageData.setDerivedImage(derivedImage);\n                }\n                else {\n                    utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);\n                }\n            }\n        };\n        derivedImageIds.forEach(updateSegmentationActor);\n        viewport.render();\n        if (evt.type === Enums.Events.IMAGE_RENDERED) {\n            viewport.element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n        }\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport { getAllAnnotations } from '../../../stateManagement/annotation/annotationState';\nimport { areSameSegment, isContourSegmentationAnnotation, } from '../../../utilities/contourSegmentation';\nimport { getToolGroupForViewport } from '../../../store/ToolGroupManager';\nimport { findAllIntersectingContours } from '../../../utilities/contourSegmentation/getIntersectingAnnotations';\nimport { processMultipleIntersections } from '../../../utilities/contourSegmentation/mergeMultipleAnnotations';\nimport { convertContourPolylineToCanvasSpace, createPolylineHole, combinePolylines, } from '../../../utilities/contourSegmentation/sharedOperations';\nimport { Events } from '../../../enums';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default async function contourSegmentationCompletedListener(evt) {\n    const sourceAnnotation = evt.detail\n        .annotation;\n    if (!isContourSegmentationAnnotation(sourceAnnotation)) {\n        return;\n    }\n    const viewport = getViewport(sourceAnnotation);\n    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);\n    if (!contourSegmentationAnnotations.length) {\n        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {\n            element: viewport.element,\n            sourceAnnotation,\n        });\n        return;\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const intersectingContours = findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations);\n    if (!intersectingContours.length) {\n        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {\n            element: viewport.element,\n            sourceAnnotation,\n        });\n        return;\n    }\n    if (intersectingContours.length > 1) {\n        processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours);\n        return;\n    }\n    const { targetAnnotation, targetPolyline, isContourHole } = intersectingContours[0];\n    if (isContourHole) {\n        const { contourHoleProcessingEnabled = false } = evt.detail;\n        if (!contourHoleProcessingEnabled) {\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {\n    const toolName = 'PlanarFreehandContourSegmentationTool';\n    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n    let errorMessage;\n    if (!toolGroup) {\n        errorMessage = `ToolGroup not found for viewport ${viewport.id}`;\n    }\n    else if (!toolGroup.hasTool(toolName)) {\n        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n    }\n    else if (!toolGroup.getToolOptions(toolName)) {\n        errorMessage = `Tool ${toolName} must be in active/passive state in ${toolGroup.id} toolGroup`;\n    }\n    if (errorMessage && !silent) {\n        console.warn(errorMessage);\n    }\n    return !errorMessage;\n}\nfunction getViewport(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));\n    return viewportWithToolRegistered ?? viewports[0];\n}\nfunction getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {\n    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n    const allAnnotations = getAllAnnotations();\n    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&\n        targetAnnotation.annotationUID !== sourceAnnotationUID &&\n        isContourSegmentationAnnotation(targetAnnotation) &&\n        areSameSegment(targetAnnotation, sourceAnnotation) &&\n        viewport.isReferenceViewable(targetAnnotation.metadata));\n}\n","import * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationCompleted } from './contourSegmentation';\nexport default function annotationCompletedListener(evt) {\n    const annotation = evt.detail.annotation;\n    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n        contourSegmentationCompleted(evt);\n    }\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationSelectionListener(evt) {\n    const deselectedAnnotation = evt.detail.removed;\n    if (!deselectedAnnotation.length) {\n        return;\n    }\n    const renderingEngines = getRenderingEngines();\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getViewports();\n        const viewportIds = viewports.map((vp) => vp.id);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    });\n}\nexport default annotationSelectionListener;\n","import triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationModifiedListener(evt) {\n    const { viewportId } = evt.detail;\n    triggerAnnotationRenderForViewportIds([viewportId]);\n}\nexport default annotationModifiedListener;\n","import * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationRemoved } from './contourSegmentation';\nexport default function annotationRemovedListener(evt) {\n    const annotation = evt.detail.annotation;\n    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n        contourSegmentationRemoved(evt);\n    }\n}\n","import { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nexport default function contourSegmentationRemovedListener(evt) {\n    const annotation = evt.detail.annotation;\n    removeContourSegmentationAnnotation(annotation);\n}\n","import { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nconst segmentationRepresentationModifiedListener = function (evt) {\n    const { viewportId } = evt.detail;\n    triggerSegmentationRender(viewportId);\n};\nexport default segmentationRepresentationModifiedListener;\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport { annotationCompletedListener, annotationRemovedListener, annotationSelectionListener, annotationModifiedListener, segmentationDataModifiedEventListener, segmentationModifiedListener, } from './eventListeners';\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\nimport * as ToolGroupManager from './store/ToolGroupManager';\nimport { defaultSegmentationStateManager } from './stateManagement/segmentation/SegmentationStateManager';\nimport segmentationRepresentationModifiedListener from './eventListeners/segmentation/segmentationRepresentationModifiedListener';\nimport { setConfig } from './config';\nlet csToolsInitialized = false;\nexport function init(defaultConfiguration = {}) {\n    if (csToolsInitialized) {\n        return;\n    }\n    setConfig(defaultConfiguration);\n    _addCornerstoneEventListeners();\n    _addCornerstoneToolsEventListeners();\n    csToolsInitialized = true;\n}\nexport function destroy() {\n    _removeCornerstoneEventListeners();\n    _removeCornerstoneToolsEventListeners();\n    ToolGroupManager.destroy();\n    resetCornerstoneToolsState();\n    const annotationManager = getAnnotationManager();\n    const segmentationStateManager = defaultSegmentationStateManager;\n    annotationManager.restoreAnnotations({});\n    segmentationStateManager.resetState();\n    csToolsInitialized = false;\n}\nfunction _addCornerstoneEventListeners() {\n    _removeCornerstoneEventListeners();\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n    annotationInterpolationEventDispatcher.enable();\n}\nfunction _removeCornerstoneEventListeners() {\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n    annotationInterpolationEventDispatcher.disable();\n}\nfunction _addCornerstoneToolsEventListeners() {\n    _removeCornerstoneToolsEventListeners();\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_REMOVED, annotationRemovedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);\n}\nfunction _removeCornerstoneToolsEventListeners() {\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);\n}\nexport default init;\n","import { getEnabledElement, triggerEvent, getRenderingEngine, } from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../../enums';\nimport { draw as drawSvg } from '../../drawingSvg';\nimport getToolsWithModesForElement from '../../utilities/getToolsWithModesForElement';\nconst { Active, Passive, Enabled } = ToolModes;\nclass AnnotationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._renderFlaggedViewports = () => {\n            this._throwIfDestroyed();\n            const elements = Array.from(this._viewportElements.values());\n            for (let i = 0; i < elements.length; i++) {\n                const element = elements[i];\n                if (this._needsRender.has(element)) {\n                    this._triggerRender(element);\n                    this._needsRender.delete(element);\n                    if (this._needsRender.size === 0) {\n                        break;\n                    }\n                }\n            }\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            this._render();\n        };\n        this._viewportElements = new Map();\n    }\n    addViewportElement(viewportId, element) {\n        this._viewportElements.set(viewportId, element);\n    }\n    removeViewportElement(viewportId, element) {\n        this._viewportElements.delete(viewportId);\n        this._needsRender.delete(element);\n        this._reset();\n    }\n    renderViewport(element) {\n        this._setViewportsToBeRenderedNextFrame([element]);\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setAllViewportsToBeRenderedNextFrame() {\n        const elements = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            this._needsRender.add(element);\n        });\n        this._renderFlaggedViewports();\n    }\n    _setViewportsToBeRenderedNextFrame(elements) {\n        const elementsEnabled = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            if (elementsEnabled.indexOf(element) !== -1) {\n                this._needsRender.add(element);\n            }\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(element) {\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);\n        if (!renderingEngine) {\n            console.warn('rendering Engine has been destroyed');\n            return;\n        }\n        const enabledTools = getToolsWithModesForElement(element, [\n            Active,\n            Passive,\n            Enabled,\n        ]);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const eventDetail = {\n            element,\n            renderingEngineId,\n            viewportId,\n        };\n        drawSvg(element, (svgDrawingHelper) => {\n            let anyRendered = false;\n            const handleDrawSvg = (tool) => {\n                if (tool.renderAnnotation) {\n                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);\n                    anyRendered = anyRendered || rendered;\n                }\n            };\n            enabledTools.forEach(handleDrawSvg);\n            if (anyRendered) {\n                triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n            }\n        });\n    }\n    _reset() {\n        window.cancelAnimationFrame(this._animationFrameHandle);\n        this._needsRender.clear();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._setAllViewportsToBeRenderedNextFrame();\n    }\n}\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\nexport { annotationRenderingEngine };\n","import { Enums, eventTarget, getEnabledElement, utilities, } from '@cornerstonejs/core';\nclass FrameOfReferenceSpecificAnnotationManager {\n    constructor(uid) {\n        this.getGroupKey = (annotationGroupSelector) => {\n            if (typeof annotationGroupSelector === 'string') {\n                return annotationGroupSelector;\n            }\n            const element = annotationGroupSelector;\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');\n            }\n            return enabledElement.FrameOfReferenceUID;\n        };\n        this._imageVolumeModifiedHandler = (evt) => {\n            const eventDetail = evt.detail;\n            const { FrameOfReferenceUID } = eventDetail;\n            const annotations = this.annotations;\n            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];\n            if (!frameOfReferenceSpecificAnnotations) {\n                return;\n            }\n            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                toolSpecificAnnotations.forEach((annotation) => {\n                    const invalidated = annotation.invalidated;\n                    if (invalidated !== undefined) {\n                        annotation.invalidated = true;\n                    }\n                });\n            });\n        };\n        this.getFramesOfReference = () => {\n            return Object.keys(this.annotations);\n        };\n        this.getAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (!annotations[groupKey]) {\n                return [];\n            }\n            if (toolName) {\n                return annotations[groupKey][toolName]\n                    ? annotations[groupKey][toolName]\n                    : [];\n            }\n            return annotations[groupKey];\n        };\n        this.getAnnotation = (annotationUID) => {\n            const annotations = this.annotations;\n            for (const frameOfReferenceUID in annotations) {\n                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n                for (const toolName in frameOfReferenceAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n                    for (const annotation of toolSpecificAnnotations) {\n                        if (annotationUID === annotation.annotationUID) {\n                            return annotation;\n                        }\n                    }\n                }\n            }\n        };\n        this.getNumberOfAnnotations = (groupKey, toolName) => {\n            const annotations = this.getAnnotations(groupKey, toolName);\n            if (!annotations.length) {\n                return 0;\n            }\n            if (toolName) {\n                return annotations.length;\n            }\n            let total = 0;\n            for (const toolName in annotations) {\n                total += annotations[toolName].length;\n            }\n            return total;\n        };\n        this.addAnnotation = (annotation, groupKey) => {\n            const { metadata } = annotation;\n            const { FrameOfReferenceUID, toolName } = metadata;\n            groupKey = groupKey || FrameOfReferenceUID;\n            const annotations = this.annotations;\n            let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            if (!frameOfReferenceSpecificAnnotations) {\n                annotations[groupKey] = {};\n                frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            }\n            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            if (!toolSpecificAnnotations) {\n                frameOfReferenceSpecificAnnotations[toolName] = [];\n                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            }\n            if (this.preprocessingFn) {\n                annotation = this.preprocessingFn(annotation);\n            }\n            toolSpecificAnnotations.push(annotation);\n        };\n        this.removeAnnotation = (annotationUID) => {\n            const { annotations } = this;\n            for (const groupKey in annotations) {\n                const groupAnnotations = annotations[groupKey];\n                for (const toolName in groupAnnotations) {\n                    const toolAnnotations = groupAnnotations[toolName];\n                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);\n                    if (index !== -1) {\n                        toolAnnotations.splice(index, 1);\n                        if (toolAnnotations.length === 0) {\n                            delete groupAnnotations[toolName];\n                        }\n                    }\n                }\n                if (Object.keys(groupAnnotations).length === 0) {\n                    delete annotations[groupKey];\n                }\n            }\n        };\n        this.removeAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            const removedAnnotations = [];\n            if (!annotations[groupKey]) {\n                return removedAnnotations;\n            }\n            if (toolName) {\n                const annotationsForTool = annotations[groupKey][toolName];\n                for (const annotation of annotationsForTool) {\n                    this.removeAnnotation(annotation.annotationUID);\n                    removedAnnotations.push(annotation);\n                }\n            }\n            else {\n                for (const toolName in annotations[groupKey]) {\n                    const annotationsForTool = annotations[groupKey][toolName];\n                    for (const annotation of annotationsForTool) {\n                        this.removeAnnotation(annotation.annotationUID);\n                        removedAnnotations.push(annotation);\n                    }\n                }\n            }\n            return removedAnnotations;\n        };\n        this.saveAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    return;\n                }\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                return structuredClone(toolSpecificAnnotations);\n            }\n            else if (groupKey) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                return structuredClone(frameOfReferenceSpecificAnnotations);\n            }\n            return structuredClone(annotations);\n        };\n        this.restoreAnnotations = (state, groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    annotations[groupKey] = {};\n                    frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                }\n                frameOfReferenceSpecificAnnotations[toolName] = state;\n            }\n            else if (groupKey) {\n                annotations[groupKey] = state;\n            }\n            else {\n                this.annotations = structuredClone(state);\n            }\n        };\n        this.getAllAnnotations = () => {\n            return Object.values(this.annotations)\n                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))\n                .flat(2);\n        };\n        this.getNumberOfAllAnnotations = () => {\n            let count = 0;\n            const annotations = this.annotations;\n            for (const groupKey in annotations) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                for (const toolName in frameOfReferenceSpecificAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                    count += toolSpecificAnnotations.length;\n                }\n            }\n            return count;\n        };\n        this.removeAllAnnotations = () => {\n            const removedAnnotations = [];\n            for (const annotation of this.getAllAnnotations()) {\n                this.removeAnnotation(annotation.annotationUID);\n                removedAnnotations.push(annotation);\n            }\n            return removedAnnotations;\n        };\n        if (!uid) {\n            uid = utilities.uuidv4();\n        }\n        this.annotations = {};\n        this.uid = uid;\n        eventTarget.addEventListener(Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);\n    }\n    setPreprocessingFn(preprocessingFn) {\n        this.preprocessingFn = preprocessingFn;\n    }\n}\nconst defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst globalLockedAnnotationUIDsSet = new Set();\nfunction setAnnotationLocked(annotationUID, locked = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (locked) {\n            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n        else {\n            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction unlockAllAnnotations() {\n    const detail = makeEventDetail();\n    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction getAnnotationsLocked() {\n    return Array.from(globalLockedAnnotationUIDsSet);\n}\nfunction isAnnotationLocked(annotationUID) {\n    return globalLockedAnnotationUIDsSet.has(annotationUID);\n}\nfunction getAnnotationsLockedCount() {\n    return globalLockedAnnotationUIDsSet.size;\n}\nfunction checkAndSetAnnotationLocked(annotationUID) {\n    const isLocked = isAnnotationLocked(annotationUID);\n    setAnnotationLocked(annotationUID, isLocked);\n    return isLocked;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        locked: [],\n    });\n}\nfunction lock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (!lockedAnnotationUIDsSet.has(annotationUID)) {\n        lockedAnnotationUIDsSet.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = true;\n        }\n    }\n}\nfunction unlock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (lockedAnnotationUIDsSet.delete(annotationUID)) {\n        detail.removed.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = false;\n        }\n    }\n}\nfunction clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {\n    lockedAnnotationUIDsSet.forEach((annotationUID) => {\n        unlock(annotationUID, lockedAnnotationUIDsSet, detail);\n    });\n}\nfunction publish(detail, lockedAnnotationUIDsSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n    }\n}\nexport { setAnnotationLocked, getAnnotationsLocked, getAnnotationsLockedCount, unlockAllAnnotations, isAnnotationLocked, checkAndSetAnnotationLocked, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst selectedAnnotationUIDs = new Set();\nfunction setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {\n    if (selected) {\n        selectAnnotation(annotationUID, preserveSelected);\n    }\n    else {\n        deselectAnnotation(annotationUID);\n    }\n}\nfunction selectAnnotation(annotationUID, preserveSelected = false) {\n    const detail = makeEventDetail();\n    if (!preserveSelected) {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n        selectedAnnotationUIDs.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction deselectAnnotation(annotationUID) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (selectedAnnotationUIDs.delete(annotationUID)) {\n            detail.removed.push(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            annotation.isSelected = false;\n        }\n    }\n    else {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelected() {\n    return Array.from(selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelectedByToolName(toolName) {\n    return getAnnotationsSelected().filter((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        return annotation?.metadata?.toolName === toolName;\n    });\n}\nfunction isAnnotationSelected(annotationUID) {\n    return selectedAnnotationUIDs.has(annotationUID);\n}\nfunction getAnnotationsSelectedCount() {\n    return selectedAnnotationUIDs.size;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        selection: [],\n    });\n}\nfunction clearSelectionSet(selectionSet, detail) {\n    selectionSet.forEach((value) => {\n        if (selectionSet.delete(value)) {\n            detail.removed.push(value);\n            const annotation = getAnnotation(value);\n            if (annotation) {\n                annotation.isSelected = false;\n            }\n        }\n    });\n}\nfunction publish(detail, selectionSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        selectionSet.forEach((item) => void detail.selection.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n    }\n}\nexport { setAnnotationSelected, getAnnotationsSelected, getAnnotationsSelectedByToolName, getAnnotationsSelectedCount, deselectAnnotation, isAnnotationSelected, };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, } from './helpers/state';\nlet defaultManager;\nfunction getAnnotationManager() {\n    return defaultManager;\n}\nfunction setAnnotationManager(annotationManager) {\n    defaultManager = annotationManager;\n}\nfunction getAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getAnnotations(groupKey, toolName);\n}\nfunction getAnnotation(annotationUID) {\n    const manager = getAnnotationManager();\n    return manager.getAnnotation(annotationUID);\n}\nfunction getAllAnnotations() {\n    const manager = getAnnotationManager();\n    return manager.getAllAnnotations();\n}\nfunction clearParentAnnotation(annotation) {\n    const { annotationUID: childUID, parentAnnotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return;\n    }\n    const parentAnnotation = getAnnotation(parentAnnotationUID);\n    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n    annotation.parentAnnotationUID = undefined;\n}\nfunction addChildAnnotation(parentAnnotation, childAnnotation) {\n    const { annotationUID: parentUID } = parentAnnotation;\n    const { annotationUID: childUID } = childAnnotation;\n    clearParentAnnotation(childAnnotation);\n    if (!parentAnnotation.childAnnotationUIDs) {\n        parentAnnotation.childAnnotationUIDs = [];\n    }\n    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n        return;\n    }\n    parentAnnotation.childAnnotationUIDs.push(childUID);\n    childAnnotation.parentAnnotationUID = parentUID;\n}\nfunction getParentAnnotation(annotation) {\n    return annotation.parentAnnotationUID\n        ? getAnnotation(annotation.parentAnnotationUID)\n        : undefined;\n}\nfunction getChildAnnotations(annotation) {\n    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);\n}\nfunction addAnnotation(annotation, annotationGroupSelector) {\n    if (!annotation.annotationUID) {\n        annotation.annotationUID = csUtils.uuidv4();\n    }\n    const manager = getAnnotationManager();\n    if (annotationGroupSelector instanceof HTMLDivElement) {\n        const groupKey = manager.getGroupKey(annotationGroupSelector);\n        manager.addAnnotation(annotation, groupKey);\n        triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n    }\n    else {\n        manager.addAnnotation(annotation, undefined);\n        triggerAnnotationAddedForFOR(annotation);\n    }\n    return annotation.annotationUID;\n}\nfunction getNumberOfAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getNumberOfAnnotations(groupKey, toolName);\n}\nfunction removeAnnotation(annotationUID) {\n    if (!annotationUID) {\n        return;\n    }\n    const manager = getAnnotationManager();\n    const annotation = manager.getAnnotation(annotationUID);\n    if (!annotation) {\n        return;\n    }\n    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));\n    manager.removeAnnotation(annotationUID);\n    triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });\n}\nfunction removeAllAnnotations() {\n    const manager = getAnnotationManager();\n    const removedAnnotations = manager.removeAllAnnotations();\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction removeAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction invalidateAnnotation(annotation) {\n    let currAnnotation = annotation;\n    while (currAnnotation) {\n        currAnnotation.invalidated = true;\n        currAnnotation = currAnnotation.parentAnnotationUID\n            ? getAnnotation(currAnnotation.parentAnnotationUID)\n            : undefined;\n    }\n}\nexport { getAllAnnotations, getAnnotations, getParentAnnotation, getChildAnnotations, clearParentAnnotation, addChildAnnotation, getNumberOfAnnotations, addAnnotation, removeAnnotation, removeAnnotations, removeAllAnnotations, setAnnotationManager, getAnnotationManager, invalidateAnnotation, getAnnotation, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { isAnnotationSelected, deselectAnnotation, } from './annotationSelection';\nimport { getAnnotation } from './annotationState';\nconst globalHiddenAnnotationUIDsSet = new Set();\nfunction setAnnotationVisibility(annotationUID, visible = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (visible) {\n            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n        else {\n            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail);\n}\nfunction showAllAnnotations() {\n    const detail = makeEventDetail();\n    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    });\n    publish(detail);\n}\nfunction isAnnotationVisible(annotationUID) {\n    const annotation = getAnnotation(annotationUID);\n    if (annotation) {\n        return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    }\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        lastVisible: [],\n        lastHidden: [],\n        hidden: [],\n    });\n}\nfunction show(annotationUID, annotationUIDsSet, detail) {\n    if (annotationUIDsSet.delete(annotationUID)) {\n        detail.lastVisible.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        annotation.isVisible = true;\n    }\n}\nfunction hide(annotationUID, annotationUIDsSet, detail) {\n    if (!annotationUIDsSet.has(annotationUID)) {\n        annotationUIDsSet.add(annotationUID);\n        if (isAnnotationSelected(annotationUID)) {\n            deselectAnnotation(annotationUID);\n        }\n        detail.lastHidden.push(annotationUID);\n    }\n}\nfunction publish(detail) {\n    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n    }\n}\nfunction checkAndSetAnnotationVisibility(annotationUID) {\n    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    setAnnotationVisibility(annotationUID, isVisible);\n    return isVisible;\n}\nexport { setAnnotationVisibility, showAllAnnotations, isAnnotationVisible, checkAndSetAnnotationVisibility, };\n","class ToolStyle {\n    constructor() {\n        const defaultConfig = {\n            color: 'rgb(255, 255, 0)',\n            colorHighlighted: 'rgb(0, 255, 0)',\n            colorSelected: 'rgb(0, 220, 0)',\n            colorLocked: 'rgb(209, 193, 90)',\n            lineWidth: '1',\n            lineDash: '',\n            shadow: true,\n            textBoxVisibility: true,\n            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            textBoxFontSize: '14px',\n            textBoxColor: 'rgb(255, 255, 0)',\n            textBoxColorHighlighted: 'rgb(0, 255, 0)',\n            textBoxColorSelected: 'rgb(0, 255, 0)',\n            textBoxColorLocked: 'rgb(209, 193, 90)',\n            textBoxBackground: '',\n            textBoxLinkLineWidth: '1',\n            textBoxLinkLineDash: '2,3',\n            textBoxShadow: true,\n            markerSize: '10',\n            angleArcLineDash: '',\n        };\n        this._initializeConfig(defaultConfig);\n    }\n    getAnnotationToolStyles(annotationUID) {\n        return this.config.annotations && this.config.annotations[annotationUID];\n    }\n    getViewportToolStyles(viewportId) {\n        return this.config.viewports && this.config.viewports[viewportId];\n    }\n    getToolGroupToolStyles(toolGroupId) {\n        return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n    }\n    getDefaultToolStyles() {\n        return this.config.default;\n    }\n    setAnnotationStyles(annotationUID, styles) {\n        let annotationSpecificStyles = this.config.annotations;\n        if (!annotationSpecificStyles) {\n            this.config = {\n                ...this.config,\n                annotations: {},\n            };\n            annotationSpecificStyles = this.config.annotations;\n        }\n        annotationSpecificStyles[annotationUID] = styles;\n    }\n    setViewportToolStyles(viewportId, styles) {\n        let viewportSpecificStyles = this.config.viewports;\n        if (!viewportSpecificStyles) {\n            this.config = {\n                ...this.config,\n                viewports: {},\n            };\n            viewportSpecificStyles = this.config.viewports;\n        }\n        viewportSpecificStyles[viewportId] = styles;\n    }\n    setToolGroupToolStyles(toolGroupId, styles) {\n        let toolGroupSpecificStyles = this.config.toolGroups;\n        if (!toolGroupSpecificStyles) {\n            this.config = {\n                ...this.config,\n                toolGroups: {},\n            };\n            toolGroupSpecificStyles = this.config.toolGroups;\n        }\n        toolGroupSpecificStyles[toolGroupId] = styles;\n    }\n    setDefaultToolStyles(styles) {\n        this.config.default = styles;\n    }\n    getStyleProperty(toolStyle, specifications) {\n        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);\n    }\n    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {\n        if (annotationUID) {\n            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n            if (annotationToolStyles) {\n                if (annotationToolStyles[property] !== undefined) {\n                    return annotationToolStyles[property];\n                }\n            }\n        }\n        if (viewportId) {\n            const viewportToolStyles = this.getViewportToolStyles(viewportId);\n            if (viewportToolStyles) {\n                if (viewportToolStyles[toolName] &&\n                    viewportToolStyles[toolName][property] !== undefined) {\n                    return viewportToolStyles[toolName][property];\n                }\n                if (viewportToolStyles.global &&\n                    viewportToolStyles.global[property] !== undefined) {\n                    return viewportToolStyles.global[property];\n                }\n            }\n        }\n        if (toolGroupId) {\n            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n            if (toolGroupToolStyles) {\n                if (toolGroupToolStyles[toolName] &&\n                    toolGroupToolStyles[toolName][property] !== undefined) {\n                    return toolGroupToolStyles[toolName][property];\n                }\n                if (toolGroupToolStyles.global &&\n                    toolGroupToolStyles.global[property] !== undefined) {\n                    return toolGroupToolStyles.global[property];\n                }\n            }\n        }\n        const globalStyles = this.getDefaultToolStyles();\n        if (globalStyles[toolName] &&\n            globalStyles[toolName][property] !== undefined) {\n            return globalStyles[toolName][property];\n        }\n        if (globalStyles.global && globalStyles.global[property] !== undefined) {\n            return globalStyles.global[property];\n        }\n    }\n    _initializeConfig(config) {\n        const toolStyles = {};\n        for (const name in config) {\n            toolStyles[name] = config[name];\n        }\n        this.config = {\n            default: {\n                global: toolStyles,\n            },\n        };\n    }\n}\nconst toolStyle = new ToolStyle();\nexport default toolStyle;\n","import toolStyle from './ToolStyle';\nfunction getHierarchalPropertyStyles(property, state, mode) {\n    const list = [`${property}`];\n    if (state) {\n        list.push(`${list[0]}${state}`);\n    }\n    if (mode) {\n        list.push(`${list[list.length - 1]}${mode}`);\n    }\n    return list;\n}\nfunction getStyleProperty(property, styleSpecifier, state, mode) {\n    const alternatives = getHierarchalPropertyStyles(property, state, mode);\n    for (let i = alternatives.length - 1; i >= 0; --i) {\n        const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n        if (style !== undefined) {\n            return style;\n        }\n    }\n}\nexport { getStyleProperty };\n","import { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\nfunction getState(annotation) {\n    if (annotation) {\n        if (annotation.data && annotation.highlighted) {\n            return AnnotationStyleStates.Highlighted;\n        }\n        if (isAnnotationSelected(annotation.annotationUID)) {\n            return AnnotationStyleStates.Selected;\n        }\n        if (isAnnotationLocked(annotation.annotationUID)) {\n            return AnnotationStyleStates.Locked;\n        }\n        if (annotation.data && annotation.autoGenerated) {\n            return AnnotationStyleStates.AutoGenerated;\n        }\n    }\n    return AnnotationStyleStates.Default;\n}\nexport default getState;\n","import { getStyleProperty } from './helpers';\nfunction getFont(styleSpecifier, state, mode) {\n    const fontSize = getStyleProperty('textBoxFontSize', styleSpecifier, state, mode);\n    const fontFamily = getStyleProperty('textBoxFontFamily', styleSpecifier, state, mode);\n    return `${fontSize}px ${fontFamily}`;\n}\nexport default getFont;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\nexport default class AnnotationGroup {\n    constructor() {\n        this.annotationUIDs = new Set();\n        this._isVisible = true;\n        this.visibleFilter = this.unboundVisibleFilter.bind(this);\n    }\n    unboundVisibleFilter(uid) {\n        return !this._isVisible || !this.annotationUIDs.has(uid);\n    }\n    has(uid) {\n        return this.annotationUIDs.has(uid);\n    }\n    setVisible(isVisible = true, baseEvent, filter) {\n        if (this._isVisible === isVisible) {\n            return;\n        }\n        this._isVisible = isVisible;\n        this.annotationUIDs.forEach((uid) => {\n            const annotation = getAnnotation(uid);\n            if (!annotation) {\n                this.annotationUIDs.delete(uid);\n                return;\n            }\n            if (annotation.isVisible === isVisible) {\n                return;\n            }\n            if (!isVisible && filter?.(uid) === false) {\n                return;\n            }\n            annotation.isVisible = isVisible;\n            const eventDetail = {\n                ...baseEvent,\n                annotation,\n            };\n            triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n        });\n    }\n    get isVisible() {\n        return this._isVisible;\n    }\n    findNearby(uid, direction) {\n        const uids = [...this.annotationUIDs];\n        if (uids.length === 0) {\n            return null;\n        }\n        if (!uid) {\n            return uids[direction === 1 ? 0 : uids.length - 1];\n        }\n        const index = uids.indexOf(uid);\n        if (index === -1 ||\n            index + direction < 0 ||\n            index + direction >= uids.length) {\n            return null;\n        }\n        return uids[index + direction];\n    }\n    add(...annotationUIDs) {\n        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));\n    }\n    remove(...annotationUIDs) {\n        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));\n    }\n    clear() {\n        this.annotationUIDs.clear();\n    }\n}\n","import * as config from './config';\nimport * as locking from './annotationLocking';\nimport * as selection from './annotationSelection';\nimport * as annotationState from './annotationState';\nimport * as annotationStateHelpers from './helpers/state';\nimport * as visibility from './annotationVisibility';\nimport FrameOfReferenceSpecificAnnotationManager from './FrameOfReferenceSpecificAnnotationManager';\nimport AnnotationGroup from './AnnotationGroup';\nimport { resetAnnotationManager } from './resetAnnotationManager';\nconst state = {\n    ...annotationState,\n    ...annotationStateHelpers,\n    resetAnnotationManager,\n};\nexport { config, locking, selection, state, visibility, FrameOfReferenceSpecificAnnotationManager, AnnotationGroup, };\n","import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const viewportRenderList = [];\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            try {\n                const viewportId = display.render(viewport, representation);\n                viewportRenderList.push(viewportId);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n","import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        this._labelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this._stackLabelmapImageIdReferenceMap.clear();\n        this._labelmapImageIdReferenceMap.clear();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const referenceImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(referenceImageId, labelmapImageId);\n                this._updateLabelmapImageIdReferenceMap({\n                    segmentationId,\n                    referenceImageId,\n                    labelmapImageId,\n                });\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(referenceImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((referenceImageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(referenceImageId, labelmapImageId);\n                        this._updateLabelmapImageIdReferenceMap({\n                            segmentationId,\n                            referenceImageId,\n                            labelmapImageId,\n                        });\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getLabelmapImageIdsForImageId(imageId, segmentationId) {\n        const key = this._generateMapKey({\n            segmentationId,\n            referenceImageId: imageId,\n        });\n        return this._labelmapImageIdReferenceMap.get(key);\n    }\n    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const referenceImageId = stackViewport.getCurrentImageId();\n        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {\n        const key = this._generateMapKey({ segmentationId, referenceImageId });\n        if (!this._labelmapImageIdReferenceMap.has(key)) {\n            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);\n            return;\n        }\n        const currentValues = this._labelmapImageIdReferenceMap.get(key);\n        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));\n        this._labelmapImageIdReferenceMap.set(key, newValues);\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n    _generateMapKey({ segmentationId, referenceImageId }) {\n        return `${segmentationId}-${referenceImageId}`;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n","import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setActiveSegmentation(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nexport function addColorLUT(colorLUT, index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const indexToUse = index ?? getNextColorLUTIndex();\n    let colorLUTToUse = [...colorLUT];\n    if (!utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];\n    }\n    colorLUTToUse = colorLUTToUse.map((color) => {\n        if (color.length === 3) {\n            return [color[0], color[1], color[2], 255];\n        }\n        return color;\n    });\n    if (colorLUTToUse.length < 255) {\n        const missingColorLUTs = CORNERSTONE_COLOR_LUT.slice(colorLUTToUse.length);\n        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];\n    }\n    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);\n    return indexToUse;\n}\n","import { SegmentationRepresentations } from '../../enums';\nimport { internalAddSegmentationRepresentation } from './internalAddSegmentationRepresentation';\nexport function addSegmentationRepresentations(viewportId, segmentationInputArray) {\n    segmentationInputArray.map((segmentationInput) => {\n        return internalAddSegmentationRepresentation(viewportId, segmentationInput);\n    });\n}\nfunction addContourRepresentationToViewport(viewportId, contourInputArray) {\n    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Contour,\n    })));\n}\nfunction addContourRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nfunction addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {\n    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Labelmap,\n    })));\n}\nfunction addLabelmapRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({\n            ...input,\n            type: SegmentationRepresentations.Labelmap,\n        })));\n    }\n}\nfunction addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {\n    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Surface,\n    })));\n}\nfunction addSurfaceRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nexport { addContourRepresentationToViewport, addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap, };\n","import { SegmentationRepresentations } from '../../../enums';\nimport { cache } from '@cornerstonejs/core';\nfunction normalizeSegmentationInput(segmentationInput) {\n    const { segmentationId, representation, config } = segmentationInput;\n    const { type, data: inputData } = representation;\n    const data = inputData ? { ...inputData } : {};\n    if (!data) {\n        throw new Error('Segmentation representation data may not be undefined');\n    }\n    if (type === SegmentationRepresentations.Contour) {\n        normalizeContourData(data);\n    }\n    const normalizedSegments = normalizeSegments(config?.segments, type, data);\n    delete config?.segments;\n    return {\n        segmentationId,\n        label: config?.label ?? null,\n        cachedStats: config?.cachedStats ?? {},\n        segments: normalizedSegments,\n        representationData: {\n            [type]: {\n                ...data,\n            },\n        },\n    };\n}\nfunction normalizeContourData(contourData) {\n    contourData.geometryIds = contourData.geometryIds ?? [];\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n}\nfunction normalizeSegments(segmentsConfig, type, data) {\n    const normalizedSegments = {};\n    if (segmentsConfig) {\n        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {\n            const { label, locked, cachedStats, active, ...rest } = segment;\n            const normalizedSegment = {\n                segmentIndex: Number(segmentIndex),\n                label: label ?? `Segment ${segmentIndex}`,\n                locked: locked ?? false,\n                cachedStats: cachedStats ?? {},\n                active: active ?? false,\n                ...rest,\n            };\n            normalizedSegments[segmentIndex] = normalizedSegment;\n        });\n    }\n    else if (type === SegmentationRepresentations.Surface) {\n        normalizeSurfaceSegments(normalizedSegments, data);\n    }\n    else {\n        normalizedSegments[1] = createDefaultSegment();\n    }\n    return normalizedSegments;\n}\nfunction normalizeSurfaceSegments(normalizedSegments, surfaceData) {\n    const { geometryIds } = surfaceData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction createDefaultSegment() {\n    return {\n        segmentIndex: 1,\n        label: 'Segment 1',\n        locked: false,\n        cachedStats: {},\n        active: true,\n    };\n}\nexport default normalizeSegmentationInput;\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\nexport function addSegmentations(segmentationInputArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationInputArray.forEach((segmentationInput) => {\n        const segmentation = normalizeSegmentationInput(segmentationInput);\n        segmentationStateManager.addSegmentation(segmentation);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentation.segmentationId);\n        }\n    });\n}\nexport default addSegmentations;\n","import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            console.warn(`Can't create colour for LUT index ${segmentIndex}`);\n            return null;\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n","import { getSegmentation } from './getSegmentation';\nexport function getActiveSegmentIndex(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation) {\n        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);\n        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;\n    }\n    return undefined;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getColorLUT(index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getColorLUT(index);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n    const imageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n    return imageIds[0];\n}\nexport function getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n}\nexport function getLabelmapImageIdsForImageId(imageId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getLabelmapImageIdsForImageId(imageId, segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getNextColorLUTIndex() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getNextColorLUTIndex();\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentation(segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportIdsWithSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportSegRepresentations = state.viewportSegRepresentations;\n    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)\n        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))\n        .map(([viewportId]) => viewportId);\n    return viewportIdsWithSegmentation;\n}\n","import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportSegmentations(viewportId, type) {\n    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);\n    const segmentations = viewportRepresentations.map((representation) => {\n        if (type && representation.type === type) {\n            return getSegmentation(representation.segmentationId);\n        }\n        return getSegmentation(representation.segmentationId);\n    });\n    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);\n    return filteredSegmentations;\n}\nexport function getViewportSegmentationRepresentations(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportRepresentations = state.viewportSegRepresentations[viewportId];\n    return viewportRepresentations;\n}\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { updateStackSegmentationState } from '../helpers/updateStackSegmentationState';\nexport async function computeStackLabelmapFromVolume({ volumeId, }) {\n    const segmentationVolume = cache.getVolume(volumeId);\n    return { imageIds: segmentationVolume.imageIds };\n}\nexport function convertVolumeToStackLabelmap({ segmentationId, options, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const { volumeId } = segmentation.representationData\n        .Labelmap;\n    const segmentationVolume = cache.getVolume(volumeId);\n    return updateStackSegmentationState({\n        segmentationId,\n        viewportId: options.viewportId,\n        imageIds: segmentationVolume.imageIds,\n        options,\n    });\n}\n","import { internalComputeVolumeLabelmapFromStack } from '../SegmentationStateManager';\nexport async function computeVolumeLabelmapFromStack(args) {\n    return internalComputeVolumeLabelmapFromStack(args);\n}\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nfunction getActorEntry(viewportId, segmentationId, filterFn) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngine, viewport } = enabledElement;\n    if (!renderingEngine || !viewport) {\n        return;\n    }\n    const actors = viewport.getActors();\n    const filteredActors = actors.filter(filterFn);\n    return filteredActors.length > 0 ? filteredActors[0] : undefined;\n}\nfunction getActorEntries(viewportId, filterFn) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngine, viewport } = enabledElement;\n    if (!renderingEngine || !viewport) {\n        return;\n    }\n    const actors = viewport.getActors();\n    const filteredActors = actors.filter(filterFn);\n    return filteredActors.length > 0 ? filteredActors : undefined;\n}\nexport function getLabelmapActorUID(viewportId, segmentationId) {\n    const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);\n    return actorEntry?.uid;\n}\nexport function getLabelmapActorEntries(viewportId, segmentationId) {\n    return getActorEntries(viewportId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${SegmentationRepresentations.Labelmap}`));\n}\nexport function getLabelmapActorEntry(viewportId, segmentationId) {\n    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${SegmentationRepresentations.Labelmap}`));\n}\nexport function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {\n    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID ===\n        getSurfaceRepresentationUID(segmentationId, segmentIndex));\n}\nexport function getSurfaceRepresentationUID(segmentationId, segmentIndex) {\n    return `${segmentationId}-${SegmentationRepresentations.Surface}-${segmentIndex}`;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nexport function updateSegmentations(segmentationUpdateArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationUpdateArray.forEach((segmentationUpdate) => {\n        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentationUpdate.segmentationId);\n        }\n    });\n}\n","import { getSegmentationRepresentation, getSegmentationRepresentations, } from '../getSegmentationRepresentation';\nimport { setSegmentationRepresentationVisibility as _setSegmentationRepresentationVisibility } from '../setSegmentationRepresentationVisibility';\nimport { getSegmentationRepresentationVisibility as _getSegmentationRepresentationVisibility } from '../getSegmentationRepresentationVisibility';\nimport { triggerSegmentationRenderBySegmentationId } from '../SegmentationRenderingEngine';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {\n    const representations = getSegmentationRepresentations(viewportId, specifier);\n    if (!representations) {\n        return;\n    }\n    representations.forEach((representation) => {\n        _setSegmentationRepresentationVisibility(viewportId, {\n            segmentationId: representation.segmentationId,\n            type: representation.type,\n        }, visibility);\n    });\n}\nfunction getSegmentationRepresentationVisibility(viewportId, specifier) {\n    return _getSegmentationRepresentationVisibility(viewportId, specifier);\n}\nfunction setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {\n    const representations = getSegmentationRepresentations(viewportId, specifier);\n    if (!representations) {\n        return;\n    }\n    representations.forEach((representation) => {\n        representation.segments[segmentIndex].visible = visibility;\n    });\n    triggerSegmentationRenderBySegmentationId(specifier.segmentationId);\n    triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId);\n}\nfunction getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {\n    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);\n    return !hiddenSegments.has(segmentIndex);\n}\nfunction getHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\nexport { setSegmentationRepresentationVisibility, getSegmentationRepresentationVisibility, setSegmentIndexVisibility, getSegmentIndexVisibility, getHiddenSegmentIndices, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);\n}\n","import { getSegmentations } from '../getSegmentations';\nimport { getViewportSegmentations } from '../getViewportSegmentations';\nimport { triggerSegmentationRender } from '../SegmentationRenderingEngine';\nimport { segmentationStyle } from '../SegmentationStyle';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction getStyle(specifier) {\n    return segmentationStyle.getStyle(specifier);\n}\nfunction setStyle(specifier, style) {\n    segmentationStyle.setStyle(specifier, style);\n    if (!specifier.viewportId && !specifier.segmentationId) {\n        const segmentations = getSegmentations();\n        segmentations.forEach((segmentation) => {\n            triggerSegmentationRender(segmentation.segmentationId);\n        });\n    }\n    triggerSegmentationRepresentationModified(specifier.viewportId, specifier.segmentationId, specifier.type);\n}\nfunction setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n    segmentationStyle.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);\n    triggerSegmentationRender(viewportId);\n    const segmentations = getViewportSegmentations(viewportId);\n    segmentations.forEach((segmentation) => {\n        triggerSegmentationRepresentationModified(viewportId, segmentation.segmentationId);\n    });\n}\nfunction getRenderInactiveSegmentations(viewportId) {\n    return segmentationStyle.getRenderInactiveSegmentations(viewportId);\n}\nfunction resetToGlobalStyle() {\n    segmentationStyle.resetToGlobalStyle();\n    triggerSegmentationRender();\n}\nfunction hasCustomStyle(specifier) {\n    return segmentationStyle.hasCustomStyle(specifier);\n}\nexport { getStyle, setStyle, setRenderInactiveSegmentations, getRenderInactiveSegmentations, resetToGlobalStyle, hasCustomStyle, };\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { getViewportIdsWithSegmentation } from '../getViewportIdsWithSegmentation';\nexport function getViewportsAssociatedToSegmentation(segmentationId) {\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    if (viewportIds?.length === 0) {\n        return [];\n    }\n    const viewports = [];\n    for (const viewportId of viewportIds) {\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (viewport) {\n            viewports.push(viewport);\n        }\n    }\n    return viewports;\n}\nexport function getViewportAssociatedToSegmentation(segmentationId) {\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    return viewports.length > 0 ? viewports[0] : undefined;\n}\nexport function getViewportWithMatchingViewPlaneNormal(viewports, annotation, dotThreshold = 0.99) {\n    const annotationViewPlaneNormal = annotation.metadata?.viewPlaneNormal;\n    if (!annotationViewPlaneNormal || !Array.isArray(annotationViewPlaneNormal)) {\n        return undefined;\n    }\n    const normalizedAnnotationNormal = vec3.create();\n    vec3.normalize(normalizedAnnotationNormal, annotationViewPlaneNormal);\n    for (const viewport of viewports) {\n        const camera = viewport.getCamera();\n        if (!camera?.viewPlaneNormal) {\n            continue;\n        }\n        const normalizedCameraNormal = vec3.create();\n        vec3.normalize(normalizedCameraNormal, camera.viewPlaneNormal);\n        const dotProduct = vec3.dot(normalizedAnnotationNormal, normalizedCameraNormal);\n        if (Math.abs(dotProduct) >= dotThreshold) {\n            return viewport;\n        }\n    }\n    return undefined;\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nexport function getAnnotationMapFromSegmentation(contourRepresentationData, options = {}) {\n    const annotationMap = contourRepresentationData.annotationUIDsMap;\n    const segmentIndices = options.segmentIndices?.length\n        ? options.segmentIndices\n        : Array.from(annotationMap.keys());\n    const annotationUIDsInSegmentMap = new Map();\n    segmentIndices.forEach((index) => {\n        const annotationUIDsInSegment = annotationMap.get(index);\n        let uids = Array.from(annotationUIDsInSegment);\n        uids = uids.filter((uid) => !getAnnotation(uid).parentAnnotationUID);\n        const annotations = uids.map((uid) => {\n            const annotation = getAnnotation(uid);\n            const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\n            const childPolylinesInformation = hasChildAnnotations &&\n                annotation.childAnnotationUIDs.map((childUID) => {\n                    const childAnnotation = getAnnotation(childUID);\n                    return {\n                        polyline: childAnnotation.data.contour.polyline,\n                        isClosed: childAnnotation.data.contour.closed,\n                    };\n                });\n            const holesClosed = hasChildAnnotations &&\n                childPolylinesInformation.map((childInfo) => childInfo.isClosed);\n            const childPolylines = hasChildAnnotations &&\n                childPolylinesInformation.map((childInfo) => childInfo.polyline);\n            return {\n                polyline: annotation.data.contour.polyline,\n                isClosed: annotation.data.contour.closed,\n                annotationUID: annotation.annotationUID,\n                referencedImageId: annotation.metadata.referencedImageId,\n                holesPolyline: childPolylines,\n                holesUIDs: annotation.childAnnotationUIDs,\n                holesClosed,\n            };\n        });\n        annotationUIDsInSegmentMap.set(index, annotations);\n    });\n    return { segmentIndices, annotationUIDsInSegmentMap };\n}\n","import { getAnnotationMapFromSegmentation, } from './getAnnotationMapFromSegmentation';\nfunction closePolyline(polyline, closed) {\n    if (!polyline || polyline.length === 0) {\n        return [];\n    }\n    if (!closed) {\n        return [...polyline];\n    }\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    const isAlreadyClosed = firstPoint[0] === lastPoint[0] &&\n        firstPoint[1] === lastPoint[1] &&\n        firstPoint[2] === lastPoint[2];\n    if (isAlreadyClosed) {\n        return [...polyline];\n    }\n    return [...polyline, firstPoint];\n}\nexport function getPolylinesMap(contourRepresentationData, segmentIndex) {\n    const { annotationUIDsInSegmentMap } = getAnnotationMapFromSegmentation(contourRepresentationData);\n    if (!annotationUIDsInSegmentMap.has(segmentIndex)) {\n        console.warn(`No contour information found for segmentIndex ${segmentIndex}`);\n        return;\n    }\n    const polylines = new Map();\n    const annotationsInfo = annotationUIDsInSegmentMap.get(segmentIndex);\n    for (const annotationInfo of annotationsInfo) {\n        polylines.set(annotationInfo.annotationUID, closePolyline(annotationInfo.polyline, annotationInfo.isClosed));\n        for (let i = 0; i < annotationInfo.holesUIDs?.length; i++) {\n            polylines.set(annotationInfo.holesUIDs[i], closePolyline(annotationInfo.holesPolyline[i], annotationInfo.holesClosed[i]));\n        }\n    }\n    return polylines;\n}\n","import { getSegmentation } from '../getSegmentation';\nimport { convertContourPolylineToCanvasSpace } from '../../../utilities/contourSegmentation';\nimport { getViewportsAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nimport { getPolylinesMap } from './getPolylineMap';\nimport { getAnnotation } from '../../annotation/annotationState';\nexport function extractSegmentPolylines(segmentationId, segmentIndex) {\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    if (!annotationUIDsMap.get(segmentIndex)) {\n        return;\n    }\n    const polyLinesMap = getPolylinesMap(contourRepresentationData, segmentIndex);\n    if (!polyLinesMap) {\n        return;\n    }\n    const keys = Array.from(polyLinesMap?.keys());\n    const polylinesCanvasMap = new Map();\n    for (const key of keys) {\n        const annotation = getAnnotation(key);\n        const viewport = getViewportWithMatchingViewPlaneNormal(viewports, annotation);\n        polylinesCanvasMap.set(key, convertContourPolylineToCanvasSpace(polyLinesMap.get(key), viewport));\n    }\n    return polylinesCanvasMap;\n}\n","import { getAnnotation, invalidateAnnotation, } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport decimate from '../../../utilities/math/polyline/decimate';\nimport { getViewportsAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nexport default function decimateContours(segmentationId, segmentIndex, options = { epsilon: 0.1 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    if (!viewports) {\n        console.warn('No viewport associated to the segmentation found');\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    for (const annotationUID of keys) {\n        const annotation = getAnnotation(annotationUID);\n        if (!annotation) {\n            continue;\n        }\n        const polylineCanvas = polylinesCanvasMap.get(annotationUID);\n        const decimatedPolyline2D = decimate(polylineCanvas, options.epsilon);\n        const viewport = getViewportWithMatchingViewPlaneNormal(viewports, annotation);\n        if (viewport) {\n            annotation.data.contour.polyline = decimatedPolyline2D.map((point2D) => viewport.canvasToWorld(point2D));\n            invalidateAnnotation(annotation);\n        }\n    }\n}\n","import { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nimport { clearParentAnnotation, removeAnnotation, } from '../../annotation/annotationState';\nexport function removeCompleteContourAnnotation(annotation) {\n    if (!annotation) {\n        return;\n    }\n    if (annotation.parentAnnotationUID) {\n        clearParentAnnotation(annotation);\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n}\n","import { findContourHoles } from '../../../utilities/contours';\nimport { getAnnotation } from '../../annotation/annotationState';\nimport { triggerAnnotationRemoved } from '../../annotation/helpers/state';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport default function removeContourHoles(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const holeDetectionResults = findContourHoles(polylines);\n    if (holeDetectionResults?.length > 0) {\n        holeDetectionResults.forEach((hole) => {\n            hole.holeIndexes.forEach((index) => {\n                const annotation = getAnnotation(keys[index]);\n                removeCompleteContourAnnotation(annotation);\n            });\n        });\n    }\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport findIslands from '../../../utilities/contours/findIslands';\nimport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport default function removeContourIslands(segmentationId, segmentIndex, options = { threshold: 3 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const islands = findIslands(polylines, options.threshold);\n    if (islands?.length > 0) {\n        islands.forEach((index) => {\n            const annotation = getAnnotation(keys[index]);\n            removeCompleteContourAnnotation(annotation);\n        });\n    }\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport interpolateSegmentPoints from '../../../utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints';\nexport default function smoothContours(segmentationId, segmentIndex, options = { knotsRatioPercentage: 30 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        console.warn(`No contours found for segmentation ${segmentationId}`);\n        return;\n    }\n    if (!annotationUIDsMap.has(segmentIndex)) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const annotationList = annotationUIDsMap.get(segmentIndex);\n    annotationList.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        if (!annotation) {\n            return;\n        }\n        const polyline = annotation.data.contour.polyline;\n        if (!polyline || polyline.length < 3) {\n            return;\n        }\n        const smoothedPolyline = interpolateSegmentPoints(polyline, 0, polyline.length - 1, options.knotsRatioPercentage);\n        annotation.data.contour.polyline = smoothedPolyline;\n    });\n}\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { triggerSegmentationDataModified } from '../triggerSegmentationEvents';\nexport function clearSegmentValue(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation.representationData.Labelmap) {\n        const { representationData } = segmentation;\n        const labelmapData = representationData.Labelmap;\n        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {\n            const items = 'imageIds' in labelmapData\n                ? labelmapData.imageIds.map((imageId) => cache.getImage(imageId))\n                : [cache.getVolume(labelmapData.volumeId)];\n            items.forEach((item) => {\n                if (!item) {\n                    return;\n                }\n                const { voxelManager } = item;\n                voxelManager.forEach(({ value, index }) => {\n                    if (value === segmentIndex) {\n                        voxelManager.setAtIndex(index, 0);\n                    }\n                });\n            });\n        }\n        triggerSegmentationDataModified(segmentationId);\n    }\n    else {\n        throw new Error('Invalid segmentation type, only labelmap is supported right now');\n    }\n}\n","import { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentation } from './getSegmentation';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { setActiveSegmentIndex } from './segmentIndex';\nimport { updateSegmentations } from './updateSegmentations';\nexport function removeSegment(segmentationId, segmentIndex, options = {\n    setNextSegmentAsActive: true,\n}) {\n    clearSegmentValue(segmentationId, segmentIndex);\n    const isThisSegmentActive = getActiveSegmentIndex(segmentationId) === segmentIndex;\n    const segmentation = getSegmentation(segmentationId);\n    const { segments } = segmentation;\n    delete segments[segmentIndex];\n    const updatedSegments = {\n        ...segments,\n    };\n    updateSegmentations([\n        {\n            segmentationId,\n            payload: {\n                segments: updatedSegments,\n            },\n        },\n    ]);\n    if (isThisSegmentActive && options.setNextSegmentAsActive) {\n        const segmentIndices = Object.keys(segments)\n            .map(Number)\n            .sort((a, b) => a - b);\n        const currentIndex = segmentIndices.indexOf(segmentIndex);\n        const nextSegmentIndex = segmentIndices[currentIndex + 1];\n        const previousSegmentIndex = segmentIndices[currentIndex - 1];\n        if (nextSegmentIndex !== undefined) {\n            setActiveSegmentIndex(segmentationId, nextSegmentIndex);\n        }\n        else if (previousSegmentIndex !== undefined) {\n            setActiveSegmentIndex(segmentationId, previousSegmentIndex);\n        }\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            delete representation.segments[segmentIndex];\n        });\n    });\n}\n","import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getLabelmapImageIds(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentation = getSegmentation(segmentationId);\n    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);\n}\n","import { removeContourRepresentation, removeLabelmapRepresentation, removeSegmentationRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, } from './addSegmentationRepresentationsToViewport';\nimport { addSegmentations } from './addSegmentations';\nimport addRepresentationData from './internalAddRepresentationData';\nimport { updateSegmentations } from './updateSegmentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nimport * as utilities from './utilities';\nimport { convertStackToVolumeLabelmap } from './helpers/convertStackToVolumeLabelmap';\nimport { computeVolumeLabelmapFromStack } from './helpers/computeVolumeLabelmapFromStack';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { convertVolumeToStackLabelmap } from './helpers/computeStackLabelmapFromVolume';\nimport { removeSegment } from './removeSegment';\nimport { getLabelmapImageIds } from './getLabelmapImageIds';\nimport * as strategies from './../../tools/segmentation/strategies';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, } from './getCurrentLabelmapImageIdForViewport';\nimport { getActiveSegmentation } from './getActiveSegmentation';\nconst helpers = {\n    clearSegmentValue,\n    convertStackToVolumeLabelmap,\n    computeVolumeLabelmapFromStack,\n    convertVolumeToStackLabelmap,\n};\nexport { removeSegmentationRepresentation, removeContourRepresentation, removeLabelmapRepresentation, removeSurfaceRepresentation, removeAllSegmentations, removeSegmentation, removeSegmentationRepresentations, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, removeAllSegmentationRepresentations, addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addSegmentations, updateSegmentations, state, activeSegmentation, segmentLocking, config, segmentIndex, triggerSegmentationEvents, utilities, helpers, removeSegment, getLabelmapImageIds, addRepresentationData, strategies, segmentationStyle, defaultSegmentationStateManager, getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, getActiveSegmentation, };\n","import CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { addColorLUT } from './addColorLUT';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nfunction internalAddSegmentationRepresentation(viewportId, representationInput) {\n    const { segmentationId, config } = representationInput;\n    const renderingConfig = {\n        colorLUTIndex: getColorLUTIndex(config),\n        ...config,\n    };\n    defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);\n    if (representationInput.type === SegmentationRepresentations.Contour) {\n        triggerAnnotationRenderForViewportIds([viewportId]);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getColorLUTIndex(config) {\n    const { colorLUTOrIndex } = config || {};\n    if (colorLUTOrIndex === undefined) {\n        const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n        return index;\n    }\n    if (typeof colorLUTOrIndex === 'number') {\n        return colorLUTOrIndex;\n    }\n    if (Array.isArray(colorLUTOrIndex) &&\n        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {\n        const index = addColorLUT(colorLUTOrIndex);\n        return index;\n    }\n    const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n    return index;\n}\nexport { internalAddSegmentationRepresentation };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationRemoved } from './triggerSegmentationEvents';\nimport { removeSegmentationRepresentations } from './removeSegmentationRepresentations';\nexport function removeSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const viewportsWithSegmentation = segmentationStateManager\n        .getAllViewportSegmentationRepresentations()\n        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))\n        .map(({ viewportId }) => viewportId);\n    viewportsWithSegmentation.forEach((viewportId) => {\n        removeSegmentationRepresentations(viewportId, { segmentationId });\n    });\n    segmentationStateManager.removeSegmentation(segmentationId);\n    triggerSegmentationRemoved(segmentationId);\n}\nexport function removeAllSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentations = segmentationStateManager.getState().segmentations;\n    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);\n    segmentationIds.forEach((segmentationId) => {\n        removeSegmentation(segmentationId);\n    });\n    segmentationStateManager.resetState();\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { surfaceDisplay } from '../../tools/displayTools/Surface';\nfunction removeSegmentationRepresentation(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction _removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    const { segmentationId, type } = specifier;\n    _removeRepresentationObject(viewportId, segmentationId, type, immediate);\n    return defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n}\nfunction removeAllSegmentationRepresentations() {\n    const state = defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();\n    state.forEach(({ viewportId, representations }) => {\n        representations.forEach(({ segmentationId, type }) => {\n            removeSegmentationRepresentation(viewportId, {\n                segmentationId,\n                type,\n            });\n        });\n    });\n    defaultSegmentationStateManager.resetState();\n}\nfunction removeLabelmapRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    }, immediate);\n}\nfunction removeContourRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    }, immediate);\n}\nfunction removeSurfaceRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Surface,\n    }, immediate);\n}\nfunction _removeRepresentationObject(viewportId, segmentationId, type, immediate) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n    representations.forEach((representation) => {\n        if (representation.type === SegmentationRepresentations.Labelmap) {\n            labelmapDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Contour) {\n            contourDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Surface) {\n            surfaceDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n    });\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        viewport.render();\n    }\n}\nexport { removeSegmentationRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, };\n","import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { invalidateBrushCursor } from '../../utilities/segmentation/invalidateBrushCursor';\nimport { getSegmentation } from './getSegmentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (typeof segmentIndex === 'string') {\n        console.warn('segmentIndex is a string, converting to number');\n        segmentIndex = Number(segmentIndex);\n    }\n    Object.values(segmentation.segments).forEach((segment) => {\n        segment.active = false;\n    });\n    if (!segmentation.segments[segmentIndex]) {\n        segmentation.segments[segmentIndex] = {\n            segmentIndex,\n            label: '',\n            locked: false,\n            cachedStats: {},\n            active: false,\n        };\n    }\n    if (segmentation.segments[segmentIndex].active !== true) {\n        segmentation.segments[segmentIndex].active = true;\n        triggerSegmentationModified(segmentationId);\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            if (!representation.segments[segmentIndex]) {\n                representation.segments[segmentIndex] = {\n                    visible: true,\n                };\n            }\n        });\n    });\n    viewportIds.forEach((viewportId) => {\n        const toolGroup = getToolGroupForViewport(viewportId);\n        invalidateBrushCursor(toolGroup.id);\n    });\n}\nexport { setActiveSegmentIndex, getActiveSegmentIndex };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function removeColorLUT(colorLUTIndex) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);\n}\n","import { getSegmentation } from './getSegmentation';\nimport { getSegmentations } from './getSegmentations';\nimport { addSegmentations } from './addSegmentations';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addColorLUT } from './addColorLUT';\nimport { getColorLUT } from './getColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { removeColorLUT } from './removeColorLUT';\nimport { getViewportSegmentations, getViewportSegmentationRepresentations, } from './getViewportSegmentations';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, } from './getCurrentLabelmapImageIdForViewport';\nimport { updateLabelmapSegmentationImageReferences } from './updateLabelmapSegmentationImageReferences';\nimport { getStackSegmentationImageIdsForViewport } from './getStackSegmentationImageIdsForViewport';\nimport { getSegmentationRepresentation, getSegmentationRepresentations, getSegmentationRepresentationsBySegmentationId, } from './getSegmentationRepresentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nfunction destroy() {\n    defaultSegmentationStateManager.resetState();\n}\nexport { getColorLUT, getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, getNextColorLUTIndex, getSegmentation, getSegmentations, getStackSegmentationImageIdsForViewport, getViewportIdsWithSegmentation, getSegmentationRepresentation, getSegmentationRepresentations, getViewportSegmentationRepresentations, removeColorLUT, getViewportSegmentations, removeSegmentation, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, removeAllSegmentations, addColorLUT, addSegmentations, updateLabelmapSegmentationImageReferences, getSegmentationRepresentationsBySegmentationId, destroy, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n}\n","import { getRenderingEngine, getEnabledElement, eventTarget, Enums, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nclass Synchronizer {\n    constructor(synchronizerId, eventName, eventHandler, options) {\n        this._viewportOptions = {};\n        this._onEvent = (evt) => {\n            if (this._ignoreFiredEvents === true) {\n                return;\n            }\n            if (!this._targetViewports.length) {\n                return;\n            }\n            const enabledElement = this._eventSource === 'element'\n                ? getEnabledElement(evt.currentTarget)\n                : getEnabledElementByViewportId(evt.detail?.viewportId);\n            if (!enabledElement) {\n                return;\n            }\n            const { renderingEngineId, viewportId } = enabledElement;\n            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n                return;\n            }\n            this.fireEvent({\n                renderingEngineId,\n                viewportId,\n            }, evt);\n        };\n        this._enabled = true;\n        this._eventName = eventName;\n        this._eventHandler = eventHandler;\n        this._ignoreFiredEvents = false;\n        this._sourceViewports = [];\n        this._targetViewports = [];\n        this._options = options || {};\n        this._eventSource = this._options.eventSource || 'element';\n        this._auxiliaryEvents = this._options.auxiliaryEvents || [];\n        this.id = synchronizerId;\n    }\n    isDisabled() {\n        return !this._enabled || !this._hasSourceElements();\n    }\n    setOptions(viewportId, options = {}) {\n        this._viewportOptions[viewportId] = options;\n    }\n    setEnabled(enabled) {\n        this._enabled = enabled;\n    }\n    getOptions(viewportId) {\n        return this._viewportOptions[viewportId];\n    }\n    add(viewportInfo) {\n        this.addTarget(viewportInfo);\n        this.addSource(viewportInfo);\n    }\n    addSource(viewportInfo) {\n        if (_containsViewport(this._sourceViewports, viewportInfo)) {\n            return;\n        }\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const viewport = getRenderingEngine(renderingEngineId).getViewport(viewportId);\n        if (!viewport) {\n            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);\n            return;\n        }\n        const eventSource = this._eventSource === 'element' ? viewport.element : eventTarget;\n        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));\n        this._auxiliaryEvents.forEach(({ name, source }) => {\n            const target = source === 'element' ? viewport.element : eventTarget;\n            target.addEventListener(name, this._onEvent.bind(this));\n        });\n        this._updateDisableHandlers();\n        this._sourceViewports.push(viewportInfo);\n    }\n    addTarget(viewportInfo) {\n        if (_containsViewport(this._targetViewports, viewportInfo)) {\n            return;\n        }\n        this._targetViewports.push(viewportInfo);\n        this._updateDisableHandlers();\n    }\n    getSourceViewports() {\n        return this._sourceViewports;\n    }\n    getTargetViewports() {\n        return this._targetViewports;\n    }\n    destroy() {\n        this._sourceViewports.forEach((s) => this.removeSource(s));\n        this._targetViewports.forEach((t) => this.removeTarget(t));\n    }\n    remove(viewportInfo) {\n        this.removeTarget(viewportInfo);\n        this.removeSource(viewportInfo);\n    }\n    removeSource(viewportInfo) {\n        const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        const eventSource = this._eventSource === 'element'\n            ? this.getViewportElement(viewportInfo)\n            : eventTarget;\n        this._sourceViewports.splice(index, 1);\n        eventSource.removeEventListener(this._eventName, this._eventHandler);\n        this._auxiliaryEvents.forEach(({ name, source }) => {\n            const target = source === 'element'\n                ? this.getViewportElement(viewportInfo)\n                : eventTarget;\n            target.removeEventListener(name, this._eventHandler);\n        });\n        this._updateDisableHandlers();\n    }\n    removeTarget(viewportInfo) {\n        const index = _getViewportIndex(this._targetViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        this._targetViewports.splice(index, 1);\n        this._updateDisableHandlers();\n    }\n    hasSourceViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._sourceViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    hasTargetViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._targetViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    fireEvent(sourceViewport, sourceEvent) {\n        if (this.isDisabled() || this._ignoreFiredEvents) {\n            return;\n        }\n        this._ignoreFiredEvents = true;\n        const promises = [];\n        try {\n            for (let i = 0; i < this._targetViewports.length; i++) {\n                const targetViewport = this._targetViewports[i];\n                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;\n                if (targetIsSource) {\n                    continue;\n                }\n                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);\n                if (result instanceof Promise) {\n                    promises.push(result);\n                }\n            }\n        }\n        catch (ex) {\n            console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n        }\n        finally {\n            if (promises.length) {\n                Promise.allSettled(promises).then(() => {\n                    this._ignoreFiredEvents = false;\n                });\n            }\n            else {\n                this._ignoreFiredEvents = false;\n            }\n        }\n    }\n    _hasSourceElements() {\n        return this._sourceViewports.length !== 0;\n    }\n    _updateDisableHandlers() {\n        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);\n        const _remove = this.remove.bind(this);\n        const disableHandler = (elementDisabledEvent) => {\n            _remove(elementDisabledEvent.detail.element);\n        };\n        viewports.forEach((vp) => {\n            const eventSource = this.getEventSource(vp);\n            if (!eventSource) {\n                return;\n            }\n            eventSource.removeEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n            eventSource.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n        });\n    }\n    getEventSource(viewportInfo) {\n        return this._eventSource === 'element'\n            ? this.getViewportElement(viewportInfo)\n            : eventTarget;\n    }\n    getViewportElement(viewportInfo) {\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        if (!renderingEngine) {\n            return null;\n        }\n        const viewport = renderingEngine.getViewport(viewportId);\n        if (!viewport) {\n            return null;\n        }\n        return viewport.element;\n    }\n}\nfunction _getUniqueViewports(vp1, vp2) {\n    const unique = [];\n    const vps = vp1.concat(vp2);\n    for (let i = 0; i < vps.length; i++) {\n        const vp = vps[i];\n        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&\n            vp.viewportId === u.viewportId)) {\n            unique.push(vp);\n        }\n    }\n    return unique;\n}\nfunction _getViewportIndex(arr, vp) {\n    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&\n        vp.viewportId === ar.viewportId);\n}\nfunction _containsViewport(arr, vp) {\n    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&\n        ar.viewportId === vp.viewportId);\n}\nexport default Synchronizer;\n","import { state } from '../state';\nimport Synchronizer, {} from './Synchronizer';\nfunction createSynchronizer(synchronizerId, eventName, eventHandler, options) {\n    const synchronizerWithSameIdExists = state.synchronizers.some((sync) => sync.id === synchronizerId);\n    if (synchronizerWithSameIdExists) {\n        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n    }\n    const synchronizer = new Synchronizer(synchronizerId, eventName, eventHandler, options);\n    state.synchronizers.push(synchronizer);\n    return synchronizer;\n}\nexport default createSynchronizer;\n","import { state } from '../state';\nfunction destroy() {\n    while (state.synchronizers.length > 0) {\n        const synchronizer = state.synchronizers.pop();\n        synchronizer.destroy();\n    }\n}\nexport default destroy;\n","import { state } from '../state';\nfunction destroySynchronizer(synchronizerId) {\n    const synchronizerIndex = state.synchronizers.findIndex((sync) => sync.id === synchronizerId);\n    if (synchronizerIndex > -1) {\n        const synchronizer = state.synchronizers[synchronizerIndex];\n        synchronizer.destroy();\n        state.synchronizers.splice(synchronizerIndex, 1);\n    }\n}\nexport default destroySynchronizer;\n","import { state } from '../state';\nfunction getAllSynchronizers() {\n    return state.synchronizers;\n}\nexport default getAllSynchronizers;\n","import { state } from '../state';\nfunction getSynchronizer(synchronizerId) {\n    return state.synchronizers.find((s) => s.id === synchronizerId);\n}\nexport default getSynchronizer;\n","import { state } from '../state';\nfunction getSynchronizersForViewport(viewportId, renderingEngineId) {\n    const synchronizersFilteredByIds = [];\n    if (!renderingEngineId && !viewportId) {\n        throw new Error('At least one of renderingEngineId or viewportId should be given');\n    }\n    for (let i = 0; i < state.synchronizers.length; i++) {\n        const synchronizer = state.synchronizers[i];\n        const notDisabled = !synchronizer.isDisabled();\n        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);\n        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);\n        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n            synchronizersFilteredByIds.push(synchronizer);\n        }\n    }\n    return synchronizersFilteredByIds;\n}\nexport default getSynchronizersForViewport;\n","import { state } from '../state';\nfunction getToolGroup(toolGroupId) {\n    return state.toolGroups.find((s) => s.id === toolGroupId);\n}\nexport default getToolGroup;\n","import { MouseBindings, ToolModes, Events } from '../../enums';\nimport get from 'lodash.get';\nimport { triggerEvent, eventTarget, getRenderingEngine, getRenderingEngines, getEnabledElementByIds, Settings, } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { state } from '../state';\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\nimport getToolGroup from './getToolGroup';\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\nexport default class ToolGroup {\n    constructor(id) {\n        this.viewportsInfo = [];\n        this.toolOptions = {};\n        this.currentActivePrimaryToolName = null;\n        this.prevActivePrimaryToolName = null;\n        this.restoreToolOptions = {};\n        this._toolInstances = {};\n        this.id = id;\n    }\n    getViewportIds() {\n        return this.viewportsInfo.map(({ viewportId }) => viewportId);\n    }\n    getViewportsInfo() {\n        return this.viewportsInfo.slice();\n    }\n    getToolInstance(toolInstanceName) {\n        const toolInstance = this._toolInstances[toolInstanceName];\n        if (!toolInstance) {\n            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);\n            return;\n        }\n        return toolInstance;\n    }\n    getToolInstances() {\n        return this._toolInstances;\n    }\n    hasTool(toolName) {\n        return !!this._toolInstances[toolName];\n    }\n    addTool(toolName, configuration = {}) {\n        const toolDefinition = state.tools[toolName];\n        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n        const localToolInstance = this.toolOptions[toolName];\n        if (!hasToolName) {\n            console.warn('Tool with configuration did not produce a toolName: ', configuration);\n            return;\n        }\n        if (!toolDefinition) {\n            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);\n            return;\n        }\n        if (localToolInstance) {\n            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);\n            return;\n        }\n        const { toolClass: ToolClass } = toolDefinition;\n        const toolProps = {\n            name: toolName,\n            toolGroupId: this.id,\n            configuration,\n        };\n        const instantiatedTool = new ToolClass(toolProps);\n        this._toolInstances[toolName] = instantiatedTool;\n    }\n    addToolInstance(toolName, parentClassName, configuration = {}) {\n        let ToolClassToUse = state.tools[toolName]\n            ?.toolClass;\n        if (!ToolClassToUse) {\n            const ParentClass = state.tools[parentClassName]\n                .toolClass;\n            class ToolInstance extends ParentClass {\n            }\n            ToolInstance.toolName = toolName;\n            ToolClassToUse = ToolInstance;\n            state.tools[toolName] = {\n                toolClass: ToolInstance,\n            };\n        }\n        this.addTool(ToolClassToUse.toolName, configuration);\n    }\n    addViewport(viewportId, renderingEngineId) {\n        if (typeof viewportId !== 'string') {\n            throw new Error('viewportId must be defined and be a string');\n        }\n        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);\n        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {\n            this.viewportsInfo.push({\n                viewportId,\n                renderingEngineId: renderingEngineUIDToUse,\n            });\n        }\n        const toolName = this.getActivePrimaryMouseButtonTool();\n        const runtimeSettings = Settings.getRuntimeSettings();\n        if (runtimeSettings.get('useCursors')) {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId: renderingEngineUIDToUse,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n    }\n    removeViewports(renderingEngineId, viewportId) {\n        const indices = [];\n        this.viewportsInfo.forEach((vpInfo, index) => {\n            let match = false;\n            if (vpInfo.renderingEngineId === renderingEngineId) {\n                match = true;\n                if (viewportId && vpInfo.viewportId !== viewportId) {\n                    match = false;\n                }\n            }\n            if (match) {\n                indices.push(index);\n            }\n        });\n        if (indices.length) {\n            for (let i = indices.length - 1; i >= 0; i--) {\n                this.viewportsInfo.splice(indices[i], 1);\n            }\n        }\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n    }\n    setActiveStrategy(toolName, strategyName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);\n            return;\n        }\n        toolInstance.setActiveStrategy(strategyName);\n    }\n    setToolMode(toolName, mode, options = {}) {\n        if (!toolName) {\n            console.warn('setToolMode: toolName must be defined');\n            return;\n        }\n        if (mode === ToolModes.Active) {\n            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);\n            return;\n        }\n        if (mode === ToolModes.Passive) {\n            this.setToolPassive(toolName);\n            return;\n        }\n        if (mode === ToolModes.Enabled) {\n            this.setToolEnabled(toolName);\n            return;\n        }\n        if (mode === ToolModes.Disabled) {\n            this.setToolDisabled(toolName);\n            return;\n        }\n        console.warn('setToolMode: mode must be defined');\n    }\n    setToolActive(toolName, toolBindingsOptions = {}) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        if (!toolInstance) {\n            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevBindings = this.toolOptions[toolName]\n            ? this.toolOptions[toolName].bindings\n            : [];\n        const newBindings = toolBindingsOptions.bindings\n            ? toolBindingsOptions.bindings\n            : [];\n        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {\n            const TouchBinding = binding.numTouchPoints !== undefined;\n            const MouseBinding = binding.mouseButton !== undefined;\n            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&\n                (TouchBinding || MouseBinding)) {\n                unique.push(binding);\n            }\n            return unique;\n        }, []);\n        const toolOptions = {\n            bindings: bindingsToUse,\n            mode: Active,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        this._toolInstances[toolName].mode = Active;\n        const runtimeSettings = Settings.getRuntimeSettings();\n        const useCursor = runtimeSettings.get('useCursors');\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        else {\n            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n            if (!activeToolIdentifier && useCursor) {\n                const cursor = MouseCursor.getDefinedCursor('default');\n                this._setCursorForViewports(cursor);\n            }\n        }\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n            if (this.prevActivePrimaryToolName === null) {\n                this.prevActivePrimaryToolName = toolName;\n            }\n            else {\n                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n            }\n            this.currentActivePrimaryToolName = toolName;\n        }\n        if (typeof toolInstance.onSetToolActive === 'function') {\n            toolInstance.onSetToolActive();\n        }\n        this._renderViewports();\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n    }\n    setToolPassive(toolName, options) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevToolOptions = this.getToolOptions(toolName);\n        const toolOptions = Object.assign({\n            bindings: prevToolOptions ? prevToolOptions.bindings : [],\n        }, prevToolOptions, {\n            mode: Passive,\n        });\n        const matchBindings = Array.isArray(options?.removeAllBindings)\n            ? options.removeAllBindings\n            : this.getDefaultPrimaryBindings();\n        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&\n            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));\n        let mode = Passive;\n        if (toolOptions.bindings.length !== 0) {\n            mode = Active;\n            toolOptions.mode = mode;\n        }\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = mode;\n        if (typeof toolInstance.onSetToolPassive === 'function') {\n            toolInstance.onSetToolPassive();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Passive);\n    }\n    setToolEnabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Enabled,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Enabled;\n        if (typeof toolInstance.onSetToolEnabled === 'function') {\n            toolInstance.onSetToolEnabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Enabled);\n    }\n    setToolDisabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Disabled,\n        };\n        this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Disabled;\n        if (typeof toolInstance.onSetToolDisabled === 'function') {\n            toolInstance.onSetToolDisabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Disabled);\n    }\n    getToolOptions(toolName) {\n        const toolOptionsForTool = this.toolOptions[toolName];\n        if (toolOptionsForTool === undefined) {\n            return;\n        }\n        return toolOptionsForTool;\n    }\n    getActivePrimaryMouseButtonTool() {\n        return Object.keys(this.toolOptions).find((toolName) => {\n            const toolOptions = this.toolOptions[toolName];\n            return (toolOptions.mode === Active &&\n                this._hasMousePrimaryButtonBinding(toolOptions));\n        });\n    }\n    setViewportsCursorByToolName(toolName, strategyName) {\n        const cursor = this._getCursor(toolName, strategyName);\n        this._setCursorForViewports(cursor);\n    }\n    _getCursor(toolName, strategyName) {\n        let cursorName;\n        let cursor;\n        if (strategyName) {\n            cursorName = `${toolName}.${strategyName}`;\n            cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n            if (cursor) {\n                return cursor;\n            }\n        }\n        cursorName = `${toolName}`;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        cursorName = toolName;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        return MouseCursor.getDefinedCursor('default');\n    }\n    _setCursorForViewports(cursor) {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            initElementCursor(viewport.element, cursor);\n        });\n    }\n    setToolConfiguration(toolName, configuration, overwrite) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return false;\n        }\n        let _configuration;\n        if (overwrite) {\n            _configuration = configuration;\n        }\n        else {\n            _configuration = Object.assign(toolInstance.configuration, configuration);\n        }\n        toolInstance.configuration = _configuration;\n        if (typeof toolInstance.onSetToolConfiguration === 'function') {\n            toolInstance.onSetToolConfiguration();\n        }\n        this._renderViewports();\n        return true;\n    }\n    getDefaultMousePrimary() {\n        return MouseBindings.Primary;\n    }\n    getDefaultPrimaryBindings() {\n        return PRIMARY_BINDINGS;\n    }\n    getToolConfiguration(toolName, configurationPath) {\n        if (this._toolInstances[toolName] === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return;\n        }\n        const _configuration = get(this._toolInstances[toolName].configuration, configurationPath) ||\n            this._toolInstances[toolName].configuration;\n        return utilities.deepClone(_configuration);\n    }\n    getPrevActivePrimaryToolName() {\n        return this.prevActivePrimaryToolName;\n    }\n    setActivePrimaryTool(toolName) {\n        const activeToolName = this.getCurrentActivePrimaryToolName();\n        this.setToolDisabled(activeToolName);\n        this.setToolActive(toolName, {\n            bindings: [{ mouseButton: MouseBindings.Primary }],\n        });\n    }\n    getCurrentActivePrimaryToolName() {\n        return this.currentActivePrimaryToolName;\n    }\n    clone(newToolGroupId, fnToolFilter = null) {\n        let toolGroup = getToolGroup(newToolGroupId);\n        if (toolGroup) {\n            console.debug(`ToolGroup ${newToolGroupId} already exists`);\n            return toolGroup;\n        }\n        toolGroup = new ToolGroup(newToolGroupId);\n        state.toolGroups.push(toolGroup);\n        fnToolFilter = fnToolFilter ?? (() => true);\n        Object.keys(this._toolInstances)\n            .filter(fnToolFilter)\n            .forEach((toolName) => {\n            const sourceToolInstance = this._toolInstances[toolName];\n            const sourceToolOptions = this.toolOptions[toolName];\n            const sourceToolMode = sourceToolInstance.mode;\n            toolGroup.addTool(toolName);\n            toolGroup.setToolMode(toolName, sourceToolMode, {\n                bindings: sourceToolOptions.bindings ?? [],\n            });\n        });\n        return toolGroup;\n    }\n    _hasMousePrimaryButtonBinding(toolOptions) {\n        const primaryBindings = this.getDefaultPrimaryBindings();\n        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));\n    }\n    _renderViewports() {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n        });\n    }\n    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            mode,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n    }\n    _findRenderingEngine(viewportId, renderingEngineId) {\n        const renderingEngines = getRenderingEngines();\n        if (renderingEngines?.length === 0) {\n            throw new Error('No rendering engines found.');\n        }\n        if (renderingEngineId) {\n            return renderingEngineId;\n        }\n        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));\n        if (matchingEngines.length === 0) {\n            if (renderingEngines.length === 1) {\n                return renderingEngines[0].id;\n            }\n            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        if (matchingEngines.length > 1) {\n            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        return matchingEngines[0].id;\n    }\n}\nfunction hasSameBinding(binding1, binding2) {\n    if (binding1.mouseButton !== binding2.mouseButton) {\n        return false;\n    }\n    if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n        return false;\n    }\n    return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../state';\nimport ToolGroup from './ToolGroup';\nfunction createToolGroup(toolGroupId) {\n    const toolGroupWithIdExists = state.toolGroups.some((tg) => tg.id === toolGroupId);\n    if (toolGroupWithIdExists) {\n        console.warn(`'${toolGroupId}' already exists.`);\n        return;\n    }\n    const toolGroup = new ToolGroup(toolGroupId);\n    state.toolGroups.push(toolGroup);\n    return toolGroup;\n}\nexport default createToolGroup;\n","import { state } from '../state';\nfunction destroyToolGroup(toolGroupId) {\n    const toolGroupIndex = state.toolGroups.findIndex((tg) => tg.id === toolGroupId);\n    if (toolGroupIndex > -1) {\n        state.toolGroups.splice(toolGroupIndex, 1);\n    }\n}\nexport default destroyToolGroup;\n","import { state } from '../state';\nimport destroyToolGroup from './destroyToolGroup';\nfunction destroy() {\n    const toolGroups = [...state.toolGroups];\n    for (const toolGroup of toolGroups) {\n        destroyToolGroup(toolGroup.id);\n    }\n    state.toolGroups = [];\n}\nexport default destroy;\n","import { state } from '../state';\nfunction getAllToolGroups() {\n    return state.toolGroups;\n}\nexport default getAllToolGroups;\n","import { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, imageChangeEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, touchToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, cameraResetEventDispatcher, } from '../eventDispatchers';\nimport { state } from './state';\nimport { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nexport default function addEnabledElement(evt) {\n    const { element, viewportId } = evt.detail;\n    const svgLayer = _createSvgAnnotationLayer(viewportId);\n    _setSvgNodeCache(element);\n    _appendChild(svgLayer, element);\n    annotationRenderingEngine.addViewportElement(viewportId, element);\n    mouseEventListeners.enable(element);\n    wheelEventListener.enable(element);\n    touchEventListeners.enable(element);\n    keyEventListener.enable(element);\n    imageChangeEventListener.enable(element);\n    imageRenderedEventDispatcher.enable(element);\n    cameraModifiedEventDispatcher.enable(element);\n    imageSpacingCalibratedEventDispatcher.enable(element);\n    cameraResetEventDispatcher.enable(element);\n    mouseToolEventDispatcher.enable(element);\n    keyboardToolEventDispatcher.enable(element);\n    touchToolEventDispatcher.enable(element);\n    state.enabledElements.push(element);\n}\nfunction _createSvgAnnotationLayer(viewportId) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgLayer = document.createElementNS(svgns, 'svg');\n    const svgLayerId = `svg-layer-${viewportId}`;\n    svgLayer.classList.add('svg-layer');\n    svgLayer.setAttribute('id', svgLayerId);\n    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svgLayer.style.width = '100%';\n    svgLayer.style.height = '100%';\n    svgLayer.style.pointerEvents = 'none';\n    svgLayer.style.position = 'absolute';\n    const defs = document.createElementNS(svgns, 'defs');\n    const filter = document.createElementNS(svgns, 'filter');\n    const feOffset = document.createElementNS(svgns, 'feOffset');\n    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n    const feBlend = document.createElementNS(svgns, 'feBlend');\n    filter.setAttribute('id', `shadow-${svgLayerId}`);\n    filter.setAttribute('filterUnits', 'userSpaceOnUse');\n    feOffset.setAttribute('result', 'offOut');\n    feOffset.setAttribute('in', 'SourceGraphic');\n    feOffset.setAttribute('dx', '0.5');\n    feOffset.setAttribute('dy', '0.5');\n    feColorMatrix.setAttribute('result', 'matrixOut');\n    feColorMatrix.setAttribute('in', 'offOut');\n    feColorMatrix.setAttribute('in2', 'matrix');\n    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');\n    feBlend.setAttribute('in', 'SourceGraphic');\n    feBlend.setAttribute('in2', 'matrixOut');\n    feBlend.setAttribute('mode', 'normal');\n    filter.appendChild(feOffset);\n    filter.appendChild(feColorMatrix);\n    filter.appendChild(feBlend);\n    defs.appendChild(filter);\n    svgLayer.appendChild(defs);\n    return svgLayer;\n}\nfunction _setSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    state.svgNodeCache[elementHash] = {};\n}\nfunction _appendChild(newNode, referenceNode) {\n    referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from './state';\nexport function addTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName]) {\n        state.tools[toolName] = {\n            toolClass: ToolClass,\n        };\n    }\n}\nexport function hasTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    return !!(toolName && state.tools[toolName]);\n}\nexport function hasToolByName(toolName) {\n    return !!(toolName && state.tools[toolName]);\n}\nexport function removeTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No tool found for: ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName] !== undefined) {\n        delete state.tools[toolName];\n    }\n    else {\n        throw new Error(`${toolName} cannot be removed because it has not been added`);\n    }\n}\nexport default addTool;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nexport default function cancelActiveManipulations(element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    for (const { tool } of toolsWithData) {\n        const annotationUID = tool.cancel(element);\n        if (annotationUID) {\n            return annotationUID;\n        }\n    }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, imageChangeEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, touchToolEventDispatcher, cameraResetEventDispatcher, } from '../eventDispatchers';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction removeEnabledElement(elementDisabledEvt) {\n    const { element, viewportId } = elementDisabledEvt.detail;\n    _resetSvgNodeCache(element);\n    _removeSvgNode(element);\n    annotationRenderingEngine.removeViewportElement(viewportId, element);\n    mouseEventListeners.disable(element);\n    wheelEventListener.disable(element);\n    touchEventListeners.disable(element);\n    keyEventListener.disable(element);\n    imageChangeEventListener.disable(element);\n    imageRenderedEventDispatcher.disable(element);\n    cameraModifiedEventDispatcher.disable(element);\n    imageSpacingCalibratedEventDispatcher.disable(element);\n    cameraResetEventDispatcher.disable(element);\n    mouseToolEventDispatcher.disable(element);\n    keyboardToolEventDispatcher.disable(element);\n    touchToolEventDispatcher.disable(element);\n    _removeViewportFromSynchronizers(element);\n    _removeViewportFromToolGroup(element);\n    _removeEnabledElement(element);\n}\nconst _removeViewportFromSynchronizers = (element) => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const synchronizers = getSynchronizersForViewport(enabledElement.viewportId, enabledElement.renderingEngineId);\n    synchronizers.forEach((sync) => {\n        sync.remove(enabledElement);\n    });\n};\nconst _removeViewportFromToolGroup = (element) => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (toolGroup) {\n        toolGroup.removeViewports(renderingEngineId, viewportId);\n    }\n};\nconst _removeAllToolsForElement = function (element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    toolsWithData.forEach(({ annotations }) => {\n        annotations.forEach((annotation) => {\n            removeAnnotation(annotation.annotationUID);\n        });\n    });\n};\nfunction _resetSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    delete state.svgNodeCache[elementHash];\n}\nfunction _removeSvgNode(element) {\n    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n    const svgLayer = internalViewportNode.querySelector('svg');\n    if (svgLayer) {\n        internalViewportNode.removeChild(svgLayer);\n    }\n}\nconst _removeEnabledElement = function (element) {\n    const foundElementIndex = state.enabledElements.findIndex((el) => el === element);\n    if (foundElementIndex > -1) {\n        state.enabledElements.splice(foundElementIndex, 1);\n    }\n};\nexport default removeEnabledElement;\n","import svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nconst defaultState = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nlet state = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nfunction resetCornerstoneToolsState() {\n    resetSvgNodeCache();\n    state = {\n        ...structuredClone({\n            ...defaultState,\n            svgNodeCache: {},\n        }),\n        svgNodeCache: {\n            ...defaultState.svgNodeCache,\n        },\n    };\n}\nexport { resetCornerstoneToolsState, state, state as default };\n","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n","import { vec3 } from 'gl-matrix';\nexport default function areViewportsCoplanar(viewport1, viewport2) {\n    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n    const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n    return Math.abs(dotProducts) > 0.9;\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {\n    const { camera } = cameraModifiedEvent.detail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    tViewport.setCamera(camera);\n    tViewport.render();\n}\n","import { vec3, mat4 } from 'gl-matrix';\nimport { getRenderingEngine, metaData, utilities, VolumeViewport, } from '@cornerstonejs/core';\nimport areViewportsCoplanar from './areViewportsCoplanar';\nconst getSpatialRegistration = (targetId, sourceId) => utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);\nexport default async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    if (options?.disabled) {\n        return;\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const imageId1 = sViewport.getCurrentImageId();\n    const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n    const targetImageIds = tViewport.getImageIds();\n    if (!areViewportsCoplanar(sViewport, tViewport)) {\n        return;\n    }\n    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);\n    if (!registrationMatrixMat4) {\n        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&\n            options?.useInitialPosition !== false) {\n            registrationMatrixMat4 = mat4.identity(mat4.create());\n        }\n        else {\n            utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);\n        }\n        if (!registrationMatrixMat4) {\n            return;\n        }\n    }\n    const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(vec3.create(), sourceImagePositionPatient, registrationMatrixMat4);\n    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);\n    let imageIndexToSet = closestImageIdIndex2.index;\n    if (tViewport instanceof VolumeViewport) {\n        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n    }\n    if (closestImageIdIndex2.index !== -1 &&\n        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {\n        await utilities.jumpToSlice(tViewport.element, {\n            imageIndex: imageIndexToSet,\n        });\n    }\n}\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n    return imageIds.reduce((closestImageIdIndex, imageId, index) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = vec3.distance(imagePositionPatient, targetPoint);\n        if (distance < closestImageIdIndex.distance) {\n            return {\n                distance,\n                index,\n            };\n        }\n        return closestImageIdIndex;\n    }, {\n        distance: Infinity,\n        index: -1,\n    });\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const presentationView = sViewport.getViewPresentation(options);\n    tViewport.setViewPresentation(presentationView);\n    tViewport.render();\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const slabThickness = sViewport.getSlabThickness?.();\n    if (!slabThickness) {\n        return;\n    }\n    tViewport.setSlabThickness?.(slabThickness);\n    tViewport.render();\n}\n","import { BaseVolumeViewport, getRenderingEngine, StackViewport, } from '@cornerstonejs/core';\nexport default function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {\n    const eventDetail = modifiedEvent.detail;\n    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const tProperties = {\n        voiRange: range,\n    };\n    if (options?.syncInvertState && invertStateChanged) {\n        tProperties.invert = invert;\n    }\n    if (options?.syncColormap && colormap) {\n        tProperties.colormap = colormap;\n    }\n    if (tViewport instanceof BaseVolumeViewport) {\n        const isFusion = tViewport._actors && tViewport._actors.size > 1;\n        if (isFusion) {\n            tViewport.setProperties(tProperties, volumeId);\n        }\n        else {\n            tViewport.setProperties(tProperties);\n        }\n    }\n    else if (tViewport instanceof StackViewport) {\n        tViewport.setProperties(tProperties);\n    }\n    else {\n        throw new Error('Viewport type not supported.');\n    }\n    tViewport.render();\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    if (options?.syncZoom !== false) {\n        const srcZoom = sViewport.getZoom();\n        tViewport.setZoom(srcZoom);\n    }\n    if (options?.syncPan !== false) {\n        const srcPan = sViewport.getPan();\n        tViewport.setPan(srcPan);\n    }\n    tViewport.render();\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\nexport { createCameraPositionSynchronizer, createPresentationViewSynchronizer, createVOISynchronizer, createZoomPanSynchronizer, createImageSliceSynchronizer, createStackImageSynchronizer, createSlabThicknessSynchronizer, };\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\nexport default function createImageSliceSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: 'VOLUME_NEW_IMAGE',\n            },\n        ],\n    });\n    return stackImageSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName, options) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });\n    return presentationView;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, slabThicknessSyncCallback);\n    return presentationView;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nexport default function createVOISynchronizer(synchronizerName, options) {\n    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);\n    const VOISynchronizer = createSynchronizer(synchronizerName, Enums.Events.VOI_MODIFIED, voiSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: Enums.Events.COLORMAP_MODIFIED,\n            },\n        ],\n        ...options,\n    });\n    return VOISynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities as csUtils, eventTarget, Enums, getRenderingEngine, CONSTANTS, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events, MouseBindings, KeyboardBindings, Events as cstEvents, SegmentationRepresentations, ToolModes, } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nimport debounce from '../utilities/debounce';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { addSegmentationRepresentations } from '../stateManagement/segmentation';\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\nconst { Events: csEvents } = Enums;\nconst isSegmentation = (actor) => actor.uid !== actor.referencedId;\nvar AdvancedMagnifyToolActions;\n(function (AdvancedMagnifyToolActions) {\n    AdvancedMagnifyToolActions[\"ShowZoomFactorsList\"] = \"showZoomFactorsList\";\n})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nclass AdvancedMagnifyTool extends AnnotationTool {\n    static { this.Actions = AdvancedMagnifyToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            magnifyingGlass: {\n                radius: 125,\n                zoomFactor: 3,\n                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n                autoPan: {\n                    enabled: true,\n                    padding: 10,\n                },\n            },\n            actions: {\n                showZoomFactorsList: {\n                    method: 'showZoomFactorsList',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Secondary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const { magnifyingGlass: config } = this.configuration;\n            const { radius, zoomFactor, autoPan } = config;\n            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotationUID = csUtils.uuidv4();\n            const magnifyViewportId = csUtils.uuidv4();\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    sourceViewportId: viewport.id,\n                    magnifyViewportId,\n                    zoomFactor,\n                    isCanvasAnnotation: true,\n                    handles: {\n                        points: canvasHandlePoints,\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            this.magnifyViewportManager.createViewport(annotation, {\n                magnifyViewportId,\n                sourceEnabledElement: enabledElement,\n                position: canvasPos,\n                radius,\n                zoomFactor,\n                autoPan: {\n                    enabled: autoPan.enabled,\n                    padding: autoPan.padding,\n                    callback: (data) => {\n                        const annotationPoints = annotation.data.handles.points;\n                        const { canvas: canvasDelta } = data.delta;\n                        for (let i = 0, len = annotationPoints.length; i < len; i++) {\n                            const point = annotationPoints[i];\n                            point[0] += canvasDelta[0];\n                            point[1] += canvasDelta[1];\n                            annotation.invalidated = true;\n                        }\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.onSetToolDisabled = () => {\n            this.magnifyViewportManager.dispose();\n            const annotations = getAllAnnotations();\n            annotations.forEach((annotation) => {\n                if (annotation.metadata.toolName === this.getToolName()) {\n                    removeAnnotation(annotation.annotationUID);\n                }\n            });\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const center = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radiusPoint - radius) < proximity * 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            const { points } = data.handles;\n            const handleIndex = points.findIndex((p) => p === handle);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { deltaPoints } = eventDetail;\n            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { points } = annotation.data.handles;\n            points.forEach((point) => {\n                point[0] += canvasDelta[0];\n                point[1] += canvasDelta[1];\n            });\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const canvasDelta = deltaPoints.canvas;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += canvasDelta[0];\n                    point[1] += canvasDelta[1];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const canvasCenter = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const newRadius = getCanvasCircleRadius([\n                canvasCenter,\n                currentCanvasPoints,\n            ]);\n            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);\n            points[0] = newCanvasHandlePoints[0];\n            points[1] = newCanvasHandlePoints[1];\n            points[2] = newCanvasHandlePoints[2];\n            points[3] = newCanvasHandlePoints[3];\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===\n                viewport.id);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!filteredAnnotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < filteredAnnotations.length; i++) {\n                const annotation = filteredAnnotations[i];\n                const { annotationUID, data } = annotation;\n                const { magnifyViewportId, zoomFactor, handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points;\n                const canvasTop = canvasCoordinates[0];\n                const canvasBottom = canvasCoordinates[2];\n                const canvasLeft = canvasCoordinates[3];\n                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n                const center = [\n                    canvasLeft[0] + radius,\n                    canvasTop[1] + radius,\n                ];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-advancedMagnify`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineWidth: 5,\n                }, dataId);\n                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);\n                magnifyViewport.position = center;\n                magnifyViewport.radius = radius;\n                magnifyViewport.zoomFactor = zoomFactor;\n                magnifyViewport.update();\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n            return [\n                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],\n                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],\n                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],\n                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],\n            ];\n        };\n        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n    }\n    showZoomFactorsList(evt, annotation) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvas: canvasPoint } = currentPoints;\n        const viewportElement = element.querySelector(':scope .viewport-element');\n        const currentZoomFactor = annotation.data.zoomFactor;\n        const remove = () => dropdown.parentElement.removeChild(dropdown);\n        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {\n            if (newZoomFactor !== undefined) {\n                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n                annotation.invalidated = true;\n            }\n            remove();\n            viewport.render();\n        });\n        Object.assign(dropdown.style, {\n            left: `${canvasPoint[0]}px`,\n            top: `${canvasPoint[1]}px`,\n        });\n        viewportElement.appendChild(dropdown);\n        dropdown.focus();\n    }\n    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n        const { zoomFactorList } = this.configuration.magnifyingGlass;\n        const dropdown = document.createElement('select');\n        dropdown.size = 5;\n        Object.assign(dropdown.style, {\n            width: '50px',\n            position: 'absolute',\n        });\n        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n        });\n        dropdown.addEventListener('change', (evt) => {\n            evt.stopPropagation();\n            onChangeCallback(dropdown.value);\n        });\n        dropdown.addEventListener('keydown', (evt) => {\n            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||\n                evt.key?.toLowerCase() === 'escape';\n            if (shouldCancel) {\n                evt.stopPropagation();\n                onChangeCallback();\n            }\n        });\n        zoomFactorList.forEach((zoomFactor) => {\n            const option = document.createElement('option');\n            option.label = zoomFactor;\n            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n            option.value = zoomFactor;\n            option.defaultSelected = zoomFactor === currentZoomFactor;\n            dropdown.add(option);\n        });\n        return dropdown;\n    }\n}\nclass AdvancedMagnifyViewportManager {\n    constructor() {\n        this.createViewport = (annotation, viewportInfo) => {\n            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;\n            const { viewport: sourceViewport } = sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            const magnifyViewport = new AdvancedMagnifyViewport({\n                magnifyViewportId,\n                sourceEnabledElement,\n                radius,\n                position,\n                zoomFactor,\n                autoPan,\n            });\n            this._addSourceElementEventListener(sourceElement);\n            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n                annotation,\n                magnifyViewport,\n                magnifyViewportInfo: viewportInfo,\n            });\n            return magnifyViewport;\n        };\n        this._annotationRemovedCallback = (evt) => {\n            const { annotation } = evt.detail;\n            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n                return;\n            }\n            this.destroyViewport(annotation.data.magnifyViewportId);\n        };\n        this._newStackImageCallback = (evt) => {\n            const { viewportId: sourceViewportId, imageId } = evt.detail;\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n            if (viewport.stackActorReInitialized) {\n                this._reset(sourceViewportId);\n            }\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                annotation.metadata.referencedImageId = imageId;\n                annotation.invalidated = true;\n            });\n        };\n        this._newVolumeImageCallback = (evt) => {\n            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                const { viewPlaneNormal } = annotation.metadata;\n                const isParallel = Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n                    PARALLEL_THRESHOLD;\n                if (!isParallel) {\n                    return;\n                }\n                const { handles } = annotation.data;\n                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n                const vecHandleToImagePlane = vec3.sub(vec3.create(), worldImagePlanePoint, handles.points[0]);\n                const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n                const worldDelta = vec3.scale(vec3.create(), currentViewPlaneNormal, worldDist);\n                for (let i = 0, len = handles.points.length; i < len; i++) {\n                    const point = handles.points[i];\n                    point[0] += worldDelta[0];\n                    point[1] += worldDelta[1];\n                    point[2] += worldDelta[2];\n                }\n                annotation.invalidated = true;\n            });\n        };\n        this._magnifyViewportsMap = new Map();\n        this._initialize();\n    }\n    static getInstance() {\n        AdvancedMagnifyViewportManager._singleton =\n            AdvancedMagnifyViewportManager._singleton ??\n                new AdvancedMagnifyViewportManager();\n        return AdvancedMagnifyViewportManager._singleton;\n    }\n    getViewport(magnifyViewportId) {\n        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n    }\n    dispose() {\n        this._removeEventListeners();\n        this._destroyViewports();\n    }\n    destroyViewport(magnifyViewportId) {\n        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);\n        if (magnifyViewportMapEntry) {\n            const { magnifyViewport } = magnifyViewportMapEntry;\n            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            this._removeSourceElementEventListener(sourceElement);\n            magnifyViewport.dispose();\n            this._magnifyViewportsMap.delete(magnifyViewportId);\n        }\n    }\n    _destroyViewports() {\n        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));\n    }\n    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());\n        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n            const { viewport } = magnifyViewport.sourceEnabledElement;\n            return viewport.id === sourceViewportId;\n        });\n    }\n    _reset(sourceViewportId) {\n        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n            this.destroyViewport(magnifyViewport.viewportId);\n            const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);\n            this.createViewport(annotation, {\n                ...magnifyViewportInfo,\n                sourceEnabledElement: {\n                    ...newEnabledElement,\n                },\n            });\n        });\n    }\n    _addEventListeners() {\n        eventTarget.addEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _removeEventListeners() {\n        eventTarget.removeEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _addSourceElementEventListener(element) {\n        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        const newStackHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);\n        const newVolumeHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);\n        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.newStackHandler = newStackHandler;\n        element.newVolumeHandler = newVolumeHandler;\n    }\n    _removeSourceElementEventListener(element) {\n        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);\n        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);\n        delete element.newStackHandler;\n        delete element.newVolumeHandler;\n    }\n    _initialize() {\n        this._addEventListeners();\n    }\n}\nclass AdvancedMagnifyViewport {\n    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {\n        this._enabledElement = null;\n        this._sourceToolGroup = null;\n        this._magnifyToolGroup = null;\n        this._isViewportReady = false;\n        this._radius = 0;\n        this._resized = false;\n        this._canAutoPan = false;\n        this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n        this._sourceEnabledElement = sourceEnabledElement;\n        this._autoPan = autoPan;\n        this.radius = radius;\n        this.position = position;\n        this.zoomFactor = zoomFactor;\n        this.visible = true;\n        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n        this._mouseDragCallback = this._mouseDragCallback.bind(this);\n        this._resizeViewportAsync = (debounce(this._resizeViewport.bind(this), 1));\n        this._initialize();\n    }\n    get sourceEnabledElement() {\n        return this._sourceEnabledElement;\n    }\n    get viewportId() {\n        return this._viewportId;\n    }\n    get radius() {\n        return this._radius;\n    }\n    set radius(radius) {\n        if (Math.abs(this._radius - radius) > 0.00001) {\n            this._radius = radius;\n            this._resized = true;\n        }\n    }\n    update() {\n        const { radius, position, visible } = this;\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const size = 2 * radius;\n        const [x, y] = position;\n        if (this._resized) {\n            this._resizeViewportAsync();\n            this._resized = false;\n        }\n        Object.assign(element.style, {\n            display: visible ? 'block' : 'hidden',\n            width: `${size}px`,\n            height: `${size}px`,\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(${x}px, ${y}px)`,\n        });\n        if (this._isViewportReady) {\n            this._syncViewports();\n            viewport.render();\n        }\n    }\n    dispose() {\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const renderingEngine = viewport.getRenderingEngine();\n        this._removeEventListeners(element);\n        renderingEngine.disableElement(viewport.id);\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n    _handleToolModeChanged(evt) {\n        const { _magnifyToolGroup: magnifyToolGroup } = this;\n        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n        if (this._sourceToolGroup?.id !== toolGroupId) {\n            return;\n        }\n        switch (mode) {\n            case ToolModes.Active:\n                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n                break;\n            case ToolModes.Passive:\n                magnifyToolGroup.setToolPassive(toolName);\n                break;\n            case ToolModes.Enabled:\n                magnifyToolGroup.setToolEnabled(toolName);\n                break;\n            case ToolModes.Disabled:\n                magnifyToolGroup.setToolDisabled(toolName);\n                break;\n            default:\n                throw new Error(`Unknow tool mode (${mode})`);\n        }\n    }\n    _inheritBorderRadius(magnifyElement) {\n        const viewport = magnifyElement.querySelector('.viewport-element');\n        const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n        viewport.style.borderRadius = 'inherit';\n        canvas.style.borderRadius = 'inherit';\n    }\n    _createViewportNode() {\n        const magnifyElement = document.createElement('div');\n        const { radius } = this;\n        const size = radius * 2;\n        magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n        Object.assign(magnifyElement.style, {\n            display: 'block',\n            width: `${size}px`,\n            height: `${size}px`,\n            position: 'absolute',\n            overflow: 'hidden',\n            borderRadius: '50%',\n            boxSizing: 'border-box',\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(-1000px, -1000px)`,\n        });\n        return magnifyElement;\n    }\n    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {\n        const { parallelScale } = viewport.getCamera();\n        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n        return parallelScale * (1 / zoomFactor) * canvasRatio;\n    }\n    _isStackViewport(viewport) {\n        return 'setStack' in viewport;\n    }\n    _isVolumeViewport(viewport) {\n        return 'addVolumes' in viewport;\n    }\n    _cloneToolGroups(sourceViewport, magnifyViewport) {\n        const sourceActors = sourceViewport.getActors();\n        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n        const sourceToolGroup = getToolGroupForViewport(sourceViewport.id, sourceViewport.renderingEngineId);\n        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {\n            const toolInstance = sourceToolGroup.getToolInstance(toolName);\n            const isAnnotationTool = toolInstance instanceof AnnotationTool &&\n                !(toolInstance instanceof AdvancedMagnifyTool);\n            return isAnnotationTool;\n        });\n        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);\n        sourceActors.filter(isSegmentation).forEach((actor) => {\n            addSegmentationRepresentations(this.viewportId, [\n                {\n                    segmentationId: actor.referencedId,\n                    type: SegmentationRepresentations.Labelmap,\n                },\n            ]);\n        });\n        return { sourceToolGroup, magnifyToolGroup };\n    }\n    _cloneStack(sourceViewport, magnifyViewport) {\n        const imageIds = sourceViewport.getImageIds();\n        magnifyViewport.setStack(imageIds).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n    }\n    _cloneVolumes(sourceViewport, magnifyViewport) {\n        const actors = sourceViewport.getActors();\n        const volumeInputArray = actors\n            .filter((actor) => !isSegmentation(actor))\n            .map((actor) => ({ volumeId: actor.uid }));\n        magnifyViewport.setVolumes(volumeInputArray).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n        return magnifyViewport;\n    }\n    _cloneViewport(sourceViewport, magnifyElement) {\n        const { viewportId: magnifyViewportId } = this;\n        const renderingEngine = sourceViewport.getRenderingEngine();\n        const { options: sourceViewportOptions } = sourceViewport;\n        const viewportInput = {\n            element: magnifyElement,\n            viewportId: magnifyViewportId,\n            type: sourceViewport.type,\n            defaultOptions: { ...sourceViewportOptions },\n        };\n        renderingEngine.enableElement(viewportInput);\n        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));\n        if (this._isStackViewport(sourceViewport)) {\n            this._cloneStack(sourceViewport, magnifyViewport);\n        }\n        else if (this._isVolumeViewport(sourceViewport)) {\n            this._cloneVolumes(sourceViewport, magnifyViewport);\n        }\n        this._inheritBorderRadius(magnifyElement);\n        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n        this._sourceToolGroup = toolGroups.sourceToolGroup;\n        this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n    }\n    _cancelMouseEventCallback(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    }\n    _browserMouseUpCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _browserMouseDownCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n        document.addEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _mouseDragCallback(evt) {\n        if (!state.isInteractingWithTool) {\n            return;\n        }\n        const { _autoPan: autoPan } = this;\n        if (!autoPan.enabled || !this._canAutoPan) {\n            return;\n        }\n        const { currentPoints } = evt.detail;\n        const { viewport } = this._enabledElement;\n        const { canvasToWorld } = viewport;\n        const { canvas: canvasCurrent } = currentPoints;\n        const { radius: magnifyRadius } = this;\n        const canvasCenter = [magnifyRadius, magnifyRadius];\n        const dist = distanceToPoint(canvasCenter, canvasCurrent);\n        const maxDist = magnifyRadius - autoPan.padding;\n        if (dist <= maxDist) {\n            return;\n        }\n        const panDist = dist - maxDist;\n        const canvasDeltaPos = vec2.sub(vec2.create(), canvasCurrent, canvasCenter);\n        vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n        vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n        const newCanvasPosition = vec2.add(vec2.create(), this.position, canvasDeltaPos);\n        const currentWorldPos = canvasToWorld(this.position);\n        const newWorldPos = canvasToWorld(newCanvasPosition);\n        const worldDeltaPos = vec3.sub(vec3.create(), newWorldPos, currentWorldPos);\n        const autoPanCallbackData = {\n            points: {\n                currentPosition: {\n                    canvas: this.position,\n                    world: currentWorldPos,\n                },\n                newPosition: {\n                    canvas: newCanvasPosition,\n                    world: newWorldPos,\n                },\n            },\n            delta: {\n                canvas: canvasDeltaPos,\n                world: worldDeltaPos,\n            },\n        };\n        autoPan.callback(autoPanCallbackData);\n    }\n    _addBrowserEventListeners(element) {\n        document.addEventListener('mousedown', this._browserMouseDownCallback, true);\n        element.addEventListener('mousedown', this._cancelMouseEventCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n        element.addEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _removeBrowserEventListeners(element) {\n        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n        element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _addEventListeners(element) {\n        eventTarget.addEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._addBrowserEventListeners(element);\n    }\n    _removeEventListeners(element) {\n        eventTarget.removeEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._removeBrowserEventListeners(element);\n    }\n    _initialize() {\n        const { _sourceEnabledElement: sourceEnabledElement } = this;\n        const { viewport: sourceViewport } = sourceEnabledElement;\n        const { canvas: sourceCanvas } = sourceViewport;\n        const magnifyElement = this._createViewportNode();\n        sourceCanvas.parentNode.appendChild(magnifyElement);\n        this._addEventListeners(magnifyElement);\n        this._cloneViewport(sourceViewport, magnifyElement);\n        this._enabledElement = getEnabledElement(magnifyElement);\n    }\n    _syncViewportsCameras(sourceViewport, magnifyViewport) {\n        const worldPos = sourceViewport.canvasToWorld(this.position);\n        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);\n        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n            Math.pow(focalPoint[1] - position[1], 2) +\n            Math.pow(focalPoint[2] - position[2], 2));\n        const updatedFocalPoint = [\n            worldPos[0],\n            worldPos[1],\n            worldPos[2],\n        ];\n        const updatedPosition = [\n            updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n            updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n            updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n        ];\n        magnifyViewport.setCamera({\n            parallelScale,\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n    }\n    _syncStackViewports(sourceViewport, magnifyViewport) {\n        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n    }\n    _syncViewports() {\n        const { viewport: sourceViewport } = this._sourceEnabledElement;\n        const { viewport: magnifyViewport } = this._enabledElement;\n        const sourceProperties = sourceViewport.getProperties();\n        const imageData = magnifyViewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        magnifyViewport.setProperties(sourceProperties);\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        if (this._isStackViewport(sourceViewport)) {\n            this._syncStackViewports(sourceViewport, magnifyViewport);\n        }\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        magnifyViewport.render();\n    }\n    _resizeViewport() {\n        const { viewport } = this._enabledElement;\n        const renderingEngine = viewport.getRenderingEngine();\n        renderingEngine.resize();\n    }\n}\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\nexport { AdvancedMagnifyTool as default };\n","import { BaseTool, AnnotationTool } from './base';\nimport { getAnnotations, getAnnotation, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass AnnotationEraserTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'mouse');\n        };\n        this.preTouchStartCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'touch');\n        };\n    }\n    _deleteNearbyAnnotations(evt, interactionType) {\n        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        if (!toolGroup) {\n            return false;\n        }\n        const tools = toolGroup._toolInstances;\n        const annotationsToRemove = [];\n        for (const toolName in tools) {\n            const toolInstance = tools[toolName];\n            if (typeof toolInstance.isPointNearTool !== 'function' ||\n                typeof toolInstance.filterInteractableAnnotationsForElement !==\n                    'function') {\n                continue;\n            }\n            const annotations = getAnnotations(toolName, element);\n            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);\n            if (!interactableAnnotations) {\n                continue;\n            }\n            for (const annotation of interactableAnnotations) {\n                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {\n                    annotationsToRemove.push(annotation.annotationUID);\n                }\n            }\n        }\n        for (const annotationUID of annotationsToRemove) {\n            setAnnotationSelected(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            AnnotationTool.createAnnotationMemo(element, annotation, {\n                deleting: true,\n            });\n            removeAnnotation(annotationUID);\n        }\n        evt.preventDefault();\n        return true;\n    }\n}\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nconst EPSILON = 1e-3;\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            handleRadius: 3,\n            enableHDPIHandles: false,\n            referenceLinesCenterGapRadius: 20,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCrosshairs = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                console.warn('For crosshairs to operate, at least two viewports must be given.');\n                return;\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            const toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            this.setToolCenter(toolCenter);\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                    triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                        toolGroupId: this.toolGroupId,\n                        toolCenter: this.toolCenter,\n                    });\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCrosshairs();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const centerGap = this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    let handleRadius = this.configuration.handleRadius *\n                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);\n                    let opacity = 1;\n                    if (this.configuration.mobile?.enabled) {\n                        handleRadius = this.configuration.mobile.handleRadius;\n                        opacity = this.configuration.mobile.opacity;\n                    }\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const volumeIds = viewport.getAllVolumeIds();\n            const otherVolumeIds = otherViewport.getAllVolumeIds();\n            return (volumeIds.length === otherVolumeIds.length &&\n                volumeIds.every((id) => otherVolumeIds.includes(id)));\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = this.editData.annotation.data.handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    setToolCenter(toolCenter, suppressEvents = false) {\n        this.toolCenter = toolCenter;\n        const viewportsInfo = this._getViewportsInfo();\n        triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        if (!suppressEvents) {\n            triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                toolCenter: this.toolCenter,\n            });\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const volumeId = viewport.getVolumeId();\n        if (!volumeId) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds, toolGroupId } = this.configuration;\n        const viewports = renderingEngine.getViewports().filter((vp) => {\n            if (targetViewportIds?.indexOf(vp.id) >= 0) {\n                return true;\n            }\n            const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n            if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n                return true;\n            }\n            return false;\n        });\n        viewports.forEach((viewport) => {\n            if (viewport instanceof VolumeViewport) {\n                viewport.jumpToWorld(brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store/state';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._hasBeenRemoved = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportProperties = viewport.getProperties();\n            const { rotation: originalViewportRotation } = viewport.getViewPresentation();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                if (this._hasBeenRemoved) {\n                    return;\n                }\n                magnifyViewport.setProperties(viewportProperties);\n                magnifyViewport.setViewPresentation({\n                    rotation: originalViewportRotation,\n                });\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            const { element } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this._hasBeenRemoved = true;\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            this._hasBeenRemoved = false;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { BaseTool } from './base';\nimport { Enums, eventTarget, getEnabledElementByIds, getRenderingEngines, } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nvar OverlayMarkerType;\n(function (OverlayMarkerType) {\n    OverlayMarkerType[OverlayMarkerType[\"ANNOTATED_CUBE\"] = 1] = \"ANNOTATED_CUBE\";\n    OverlayMarkerType[OverlayMarkerType[\"AXES\"] = 2] = \"AXES\";\n    OverlayMarkerType[OverlayMarkerType[\"CUSTOM\"] = 3] = \"CUSTOM\";\n})(OverlayMarkerType || (OverlayMarkerType = {}));\nclass OrientationMarkerTool extends BaseTool {\n    static { this.CUBE = 1; }\n    static { this.AXIS = 2; }\n    static { this.VTPFILE = 3; }\n    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            orientationWidget: {\n                enabled: true,\n                viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n                viewportSize: 0.15,\n                minPixelSize: 100,\n                maxPixelSize: 300,\n            },\n            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n            overlayConfiguration: {\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n                    faceProperties: {\n                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },\n                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },\n                        yPlus: {\n                            text: 'P',\n                            faceColor: '#00ffff',\n                            fontColor: 'white',\n                            faceRotation: 180,\n                        },\n                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n                        zPlus: { text: 'S' },\n                        zMinus: { text: 'I' },\n                    },\n                    defaultStyle: {\n                        fontStyle: 'bold',\n                        fontFamily: 'Arial',\n                        fontColor: 'black',\n                        fontSizeScale: (res) => res / 2,\n                        faceColor: '#0000ff',\n                        edgeThickness: 0.1,\n                        edgeColor: 'black',\n                        resolution: 400,\n                    },\n                },\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this.onSetToolEnabled = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolActive = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolDisabled = () => {\n            this.cleanUpData();\n            this._unsubscribeToViewportNewVolumeSet();\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resize = (viewportId) => {\n            const orientationMarker = this.orientationMarkers[viewportId];\n            if (!orientationMarker) {\n                return;\n            }\n            const { orientationWidget } = orientationMarker;\n            orientationWidget.updateViewport();\n        };\n        this.orientationMarkers = {};\n        this.updatingOrientationMarker = {};\n    }\n    _unsubscribeToViewportNewVolumeSet() {\n        const unsubscribe = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = this._resizeObservers.get(viewportId);\n                resizeObserver.unobserve(element);\n            });\n        };\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            unsubscribe();\n            this.initViewports();\n        });\n    }\n    _subscribeToViewportEvents() {\n        const subscribeToElementResize = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                this.initViewports();\n                element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => {\n                        const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                        if (!element) {\n                            return;\n                        }\n                        const { viewport } = element;\n                        this.resize(viewportId);\n                        viewport.render();\n                    }, 100);\n                });\n                resizeObserver.observe(element);\n                this._resizeObservers.set(viewportId, resizeObserver);\n            });\n        };\n        subscribeToElementResize();\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            subscribeToElementResize();\n            this.initViewports();\n        });\n    }\n    cleanUpData() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach((viewport) => {\n            const orientationMarker = this.orientationMarkers[viewport.id];\n            if (!orientationMarker) {\n                return;\n            }\n            const { actor, orientationWidget } = orientationMarker;\n            orientationWidget?.setEnabled(false);\n            orientationWidget?.delete();\n            actor?.delete();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .offscreenMultiRenderWindow.getRenderWindow();\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            delete this.orientationMarkers[viewport.id];\n        });\n    }\n    initViewports() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        if (!renderingEngine) {\n            return;\n        }\n        let viewports = renderingEngine.getViewports();\n        viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n        viewports.forEach((viewport) => {\n            const widget = viewport.getWidget(this.getToolName());\n            if (!widget || widget.isDeleted()) {\n                this.addAxisActorInViewport(viewport);\n            }\n        });\n    }\n    async addAxisActorInViewport(viewport) {\n        const viewportId = viewport.id;\n        if (!this.updatingOrientationMarker[viewportId]) {\n            this.updatingOrientationMarker[viewportId] = true;\n            const type = this.configuration.overlayMarkerType;\n            const overlayConfiguration = this.configuration.overlayConfiguration[type];\n            if (this.orientationMarkers[viewportId]) {\n                const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n                viewport.getRenderer().removeActor(actor);\n                orientationWidget.setEnabled(false);\n            }\n            let actor;\n            if (type === 1) {\n                actor = this.createAnnotationCube(overlayConfiguration);\n            }\n            else if (type === 2) {\n                actor = vtkAxesActor.newInstance();\n            }\n            else if (type === 3) {\n                actor = await this.createCustomActor();\n            }\n            const renderer = viewport.getRenderer();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .offscreenMultiRenderWindow.getRenderWindow();\n            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor,\n                interactor: renderWindow.getInteractor(),\n                parentRenderer: renderer,\n            });\n            orientationWidget.setEnabled(enabled);\n            orientationWidget.setViewportCorner(viewportCorner);\n            orientationWidget.setViewportSize(viewportSize);\n            orientationWidget.setMinPixelSize(minPixelSize);\n            orientationWidget.setMaxPixelSize(maxPixelSize);\n            orientationWidget.updateMarkerOrientation();\n            this.orientationMarkers[viewportId] = {\n                orientationWidget,\n                actor,\n            };\n            viewport.addWidget(this.getToolName(), orientationWidget);\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            this.updatingOrientationMarker[viewportId] = false;\n        }\n    }\n    async createCustomActor() {\n        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n            .polyDataURL;\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const vtpReader = vtkXMLPolyDataReader.newInstance();\n        vtpReader.parseAsArrayBuffer(arrayBuffer);\n        vtpReader.update();\n        const polyData = vtkPolyData.newInstance();\n        polyData.shallowCopy(vtpReader.getOutputData());\n        polyData.getPointData().setActiveScalars('Color');\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        mapper.setColorModeToDirectScalars();\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.rotateZ(180);\n        return actor;\n    }\n    createAnnotationCube(overlayConfiguration) {\n        const actor = vtkAnnotatedCubeActor.newInstance();\n        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n        actor.setXPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.xPlus,\n        });\n        actor.setXMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.xMinus,\n        });\n        actor.setYPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.yPlus,\n        });\n        actor.setYMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.yMinus,\n        });\n        actor.setZPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.zPlus,\n        });\n        actor.setZMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.zMinus,\n        });\n        return actor;\n    }\n    async createAnnotatedCubeActor() {\n        const axes = vtkAnnotatedCubeActor.newInstance();\n        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n        axes.setDefaultStyle(defaultStyle);\n        Object.keys(faceProperties).forEach((key) => {\n            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;\n            axes[methodName](faceProperties[key]);\n        });\n        return axes;\n    }\n}\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { vec3 } from 'gl-matrix';\nimport { metaData, CONSTANTS, getRenderingEngine, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass OverlayGridTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceImageIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolActive = () => {\n            this._init();\n        };\n        this._init = () => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            if (!sourceImageIds?.length) {\n                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');\n                return;\n            }\n            const imagePlaneModule = metaData.get('imagePlaneModule', sourceImageIds[0]);\n            if (!imagePlaneModule) {\n                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');\n                return;\n            }\n            const { frameOfReferenceUID } = imagePlaneModule;\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn('OverlayGridTool: No viewports found');\n                return;\n            }\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const pointSets = sourceImageIds.map((id) => {\n                    return this.calculateImageIdPointSets(id);\n                });\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        viewportData: new Map(),\n                        pointSets,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.calculateImageIdPointSets = (imageId) => {\n            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = metaData.get('imagePlaneModule', imageId);\n            const topLeft = [...imagePositionPatient];\n            const topRight = [...imagePositionPatient];\n            const bottomLeft = [...imagePositionPatient];\n            const bottomRight = [...imagePositionPatient];\n            vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);\n            vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);\n            vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            return { pointSet1, pointSet2 };\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            let renderStatus = false;\n            if (!sourceImageIds?.length) {\n                return renderStatus;\n            }\n            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n            const targetImageIds = targetViewport.getImageIds();\n            if (targetImageIds.length < 2) {\n                return renderStatus;\n            }\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));\n            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSets = annotation.data.pointSets;\n            const viewportData = annotation.data.viewportData;\n            for (let i = 0; i < sourceImageIds.length; i++) {\n                const { pointSet1, pointSet2 } = pointSets[i];\n                const targetData = viewportData.get(targetViewport.id) ||\n                    this.initializeViewportData(viewportData, targetViewport.id);\n                if (!targetData.pointSetsToUse[i]) {\n                    let pointSetToUse = pointSet1;\n                    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n                    topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                        pointSetToUse = pointSet2;\n                    }\n                    targetData.pointSetsToUse[i] = pointSetToUse;\n                    targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n                    targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n                }\n                const lineStartWorld = targetData.lineStartsWorld[i];\n                const lineEndWorld = targetData.lineEndsWorld[i];\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n                const dataId = `${annotationUID}-line`;\n                const lineUID = `${i}`;\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n            }\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.initializeViewportData = (viewportData, id) => {\n            viewportData.set(id, {\n                pointSetsToUse: [],\n                lineStartsWorld: [],\n                lineEndsWorld: [],\n            });\n            return viewportData.get(id);\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    getImageIdNormal(imageId) {\n        const { imageOrientationPatient } = metaData.get('imagePlaneModule', imageId);\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n    }\n}\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        if (deltaPointsWorld[0] === 0 &&\n            deltaPointsWorld[1] === 0 &&\n            deltaPointsWorld[2] === 0) {\n            return;\n        }\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import { BaseVolumeViewport, getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseWheelCallback = (evt) => {\n            const { element, wheel } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { invert } = this.configuration;\n            const angle = wheel.direction * 10 * (invert ? -1 : 1);\n            this.setAngle(viewport, angle);\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle)) {\n            return;\n        }\n        this.setAngle(viewport, angle);\n    }\n    setAngle(viewport, angle) {\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getViewPresentation();\n            viewport.setViewPresentation({\n                rotation: (rotation + angle + 360) % 360,\n            });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('No enabled element found');\n            }\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp) {\n                throw new Error('Camera not found');\n            }\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0) {\n                return null;\n            }\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null) {\n                return;\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor) {\n                return;\n            }\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n                return;\n            }\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2) {\n                return;\n            }\n            if (!this._currentCanvasPosition) {\n                return;\n            }\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID) {\n                    return renderStatus;\n                }\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e))) {\n                    return renderStatus;\n                }\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                hideElementCursor(element.viewport.element);\n            }\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                resetElementCursor(element.viewport.element);\n            }\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos) {\n            return;\n        }\n        if (!annotation.data?.handles?.points) {\n            return;\n        }\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0) {\n            return [];\n        }\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport) {\n            return [];\n        }\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint) {\n            return [];\n        }\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1) {\n            return [];\n        }\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n            return;\n        }\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null) {\n                return;\n            }\n            if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n                viewport.setImageIdIndex(closestIndex);\n            }\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal) {\n                return;\n            }\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5) {\n                return;\n            }\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine) {\n                    renderingEngine.renderViewport(viewport.id);\n                }\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n            enforceSameFrameOfReference: true,\n            showFullDimension: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport?.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData?.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewportId: sourceViewport.id,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolConfiguration = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            if (!this.editData) {\n                return false;\n            }\n            const { annotation, sourceViewportId } = this.editData;\n            let renderStatus = false;\n            const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            if (this.configuration.enforceSameFrameOfReference &&\n                sourceViewport.getFrameOfReferenceUID() !==\n                    targetViewport.getFrameOfReferenceUID()) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            if (this.configuration.showFullDimension) {\n                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);\n            }\n            if (canvasCoordinates.length < 2) {\n                return renderStatus;\n            }\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {\n        const renderingEngine = targetViewport.getRenderingEngine();\n        const targetId = this.getTargetId(targetViewport);\n        const targetImage = this.getTargetImageData(targetId);\n        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);\n        if (referencedImageId && targetImage) {\n            try {\n                const { imageData, dimensions } = targetImage;\n                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [\n                    imageData.indexToWorld([0, 0, 0]),\n                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),\n                    imageData.indexToWorld([\n                        dimensions[0] - 1,\n                        dimensions[1] - 1,\n                        0,\n                    ]),\n                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                const [lineStartImageCoord, lineEndImageCoord] = [\n                    lineStartWorld,\n                    lineEndWorld,\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                canvasCoordinates = [\n                    [topLeftImageCoord, topRightImageCoord],\n                    [topRightImageCoord, bottomRightImageCoord],\n                    [bottomLeftImageCoord, bottomRightImageCoord],\n                    [topLeftImageCoord, bottomLeftImageCoord],\n                ]\n                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))\n                    .filter((point) => point && this.isInBound(point, dimensions))\n                    .map((point) => {\n                    const world = csUtils.imageToWorldCoords(referencedImageId, point);\n                    return targetViewport.worldToCanvas(world);\n                });\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        return canvasCoordinates;\n    }\n    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {\n        const [x1, y1] = line1Start;\n        const [x2, y2] = line1End;\n        const [x3, y3] = line2Start;\n        const [x4, y4] = line2End;\n        const a1 = y2 - y1;\n        const b1 = x1 - x2;\n        const c1 = x2 * y1 - x1 * y2;\n        const a2 = y4 - y3;\n        const b2 = x3 - x4;\n        const c2 = x4 * y3 - x3 * y4;\n        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n            return;\n        }\n        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n        return [x, y];\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    isInBound(point, dimensions) {\n        return (point[0] >= 0 &&\n            point[0] <= dimensions[0] &&\n            point[1] >= 0 &&\n            point[1] <= dimensions[1]);\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds) {\n                return;\n            }\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData?.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            enabledElements.forEach((element) => {\n                const { viewport } = element;\n                if (!viewportsWithAnnotations.includes(viewport.id)) {\n                    const newAnnotation = {\n                        metadata: {\n                            toolName: this.getToolName(),\n                            viewPlaneNormal: [...viewPlaneNormal],\n                            viewUp: [...viewUp],\n                            FrameOfReferenceUID,\n                            referencedImageId: null,\n                        },\n                        data: {\n                            handles: {\n                                points: csUtils.getViewportImageCornersInWorld(viewport),\n                            },\n                            viewportId: viewport.id,\n                        },\n                    };\n                    viewportsWithAnnotations.push(viewport.id);\n                    addAnnotation(newAnnotation, viewport.element);\n                    annotation = newAnnotation;\n                }\n            });\n            if (this.editData?.annotation &&\n                this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData || !this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width / window.devicePixelRatio || 1,\n            height: canvas.height / window.devicePixelRatio || 1,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates, ChangeTypes, } from '../enums';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport { distancePointToContour } from './distancePointToContour';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass SculptorTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minSpacing: 1,\n            referencedToolNames: [\n                'PlanarFreehandROI',\n                'PlanarFreehandContourSegmentationTool',\n            ],\n            toolShape: 'circle',\n            referencedToolName: 'PlanarFreehandROI',\n            updateCursorSize: 'dynamic',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.registeredShapes = new Map();\n        this.isActive = false;\n        this.commonData = {\n            activeAnnotationUID: null,\n            viewportIdsToRender: [],\n            isEditingOpenContour: false,\n            canvasLocation: undefined,\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.configureToolSize(evt);\n            this.selectFreehandTool(eventData);\n            if (this.commonData.activeAnnotationUID === null) {\n                return;\n            }\n            this.isActive = true;\n            hideElementCursor(element);\n            this.activateModify(element);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.configureToolSize(evt);\n                this.updateCursor(evt);\n            }\n            else {\n                this.commonData.canvasLocation = undefined;\n            }\n        };\n        this.endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const config = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            this.isActive = false;\n            this.deactivateModify(element);\n            resetElementCursor(element);\n            const { renderingEngineId, viewportId } = enabledElement;\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (toolInstance.configuration.calculateStats) {\n                activeAnnotation.invalidated = true;\n            }\n            triggerAnnotationModified(activeAnnotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this.dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.updateCursor(evt);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (!annotations?.length || !this.isActive) {\n                return;\n            }\n            const points = activeAnnotation.data.contour.polyline;\n            this.sculpt(eventData, points);\n        };\n        this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n        this.setToolShape(this.configuration.toolShape);\n    }\n    registerShapes(shapeName, shapeClass) {\n        const shape = new shapeClass();\n        this.registeredShapes.set(shapeName, shape);\n    }\n    sculpt(eventData, points) {\n        const config = this.configuration;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        this.sculptData = {\n            mousePoint: eventData.currentPoints.world,\n            mouseCanvasPoint: eventData.currentPoints.canvas,\n            deltaWorld: eventData.deltaPoints.world,\n            points,\n            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n            element: element,\n        };\n        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n        if (pushedHandles.first !== undefined) {\n            this.insertNewHandles(pushedHandles);\n        }\n    }\n    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {\n        const { element } = this.sculptData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const nextHandleIndex = contourIndex(i + 1, points.length);\n        const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n        const distanceToNextHandle = point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);\n        if (distanceToNextHandle > maxSpacing) {\n            indicesToInsertAfter.push(i);\n        }\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        this.commonData.viewportIdsToRender = [viewport.id];\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n        this.commonData.canvasLocation = eventData.currentPoints.canvas;\n        if (this.isActive) {\n            activeAnnotation.highlighted = true;\n        }\n        else {\n            const cursorShape = this.registeredShapes.get(this.selectedShape);\n            const canvasCoords = eventData.currentPoints.canvas;\n            if (this.configuration.updateCursorSize === 'dynamic') {\n                cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n            }\n        }\n        triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);\n    }\n    filterSculptableAnnotationsForElement(element) {\n        const config = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const sculptableAnnotations = [];\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n        config.referencedToolNames.forEach((referencedToolName) => {\n            const annotations = getAnnotations(referencedToolName, element);\n            if (annotations) {\n                sculptableAnnotations.push(...annotations);\n            }\n        });\n        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);\n    }\n    configureToolSize(evt) {\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.configureToolSize(evt);\n    }\n    insertNewHandles(pushedHandles) {\n        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n        let newIndexModifier = 0;\n        for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n            this.insertHandleRadially(insertIndex);\n            newIndexModifier++;\n        }\n    }\n    findNewHandleIndices(pushedHandles) {\n        const { points, maxSpacing } = this.sculptData;\n        const indicesToInsertAfter = [];\n        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);\n        }\n        return indicesToInsertAfter;\n    }\n    insertHandleRadially(insertIndex) {\n        const { points } = this.sculptData;\n        if (insertIndex > points.length - 1 &&\n            this.commonData.isEditingOpenContour) {\n            return;\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        const previousIndex = insertIndex - 1;\n        const nextIndex = contourIndex(insertIndex, points.length);\n        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);\n        const handleData = insertPosition;\n        points.splice(insertIndex, 0, handleData);\n    }\n    selectFreehandTool(eventData) {\n        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);\n        if (closestAnnotationUID === undefined) {\n            return;\n        }\n        this.commonData.activeAnnotationUID = closestAnnotationUID;\n    }\n    getClosestFreehandToolOnElement(eventData) {\n        const { element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const config = this.configuration;\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const canvasPoints = eventData.currentPoints.canvas;\n        const closest = {\n            distance: Infinity,\n            toolIndex: undefined,\n            annotationUID: undefined,\n        };\n        for (let i = 0; i < annotations?.length; i++) {\n            if (annotations[i].isLocked || !annotations[i].isVisible) {\n                continue;\n            }\n            const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);\n            if (distanceFromTool === -1) {\n                continue;\n            }\n            if (distanceFromTool < closest.distance) {\n                closest.distance = distanceFromTool;\n                closest.toolIndex = i;\n                closest.annotationUID = annotations[i].annotationUID;\n            }\n        }\n        this.commonData.isEditingOpenContour =\n            !annotations[closest.toolIndex].data.contour.closed;\n        config.referencedToolName =\n            annotations[closest.toolIndex].metadata.toolName;\n        return closest.annotationUID;\n    }\n    activateModify(element) {\n        element.addEventListener(Events.MOUSE_UP, this.endCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.addEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.addEventListener(Events.TOUCH_END, this.endCallback);\n        element.addEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    deactivateModify(element) {\n        element.removeEventListener(Events.MOUSE_UP, this.endCallback);\n        element.removeEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.removeEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.removeEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.removeEventListener(Events.TOUCH_END, this.endCallback);\n        element.removeEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    setToolShape(toolShape) {\n        this.selectedShape =\n            this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const viewportIdsToRender = this.commonData.viewportIdsToRender;\n        if (!this.commonData.canvasLocation ||\n            this.mode !== ToolModes.Active ||\n            !viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        let color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Default, this.mode);\n        if (this.isActive) {\n            color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Highlighted, this.mode);\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n            color,\n        });\n    }\n}\nexport const contourIndex = (i, length) => {\n    return (i + length) % length;\n};\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            opacity: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._init = () => {\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn(this.getToolName() + 'Tool: No viewports found');\n                return;\n            }\n            const firstViewport = getRenderingEngine(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);\n            if (!firstViewport) {\n                return;\n            }\n            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const actorsWorldPointsMap = new Map();\n                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        actorsWorldPointsMap,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            let renderStatus = false;\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n            const actorEntries = viewport.getActors();\n            const cacheId = getCacheId(viewport);\n            actorEntries.forEach((actorEntry) => {\n                if (!actorEntry?.clippingFilter) {\n                    return;\n                }\n                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n                if (!actorWorldPointMap) {\n                    return;\n                }\n                if (!actorWorldPointMap.get(cacheId)) {\n                    return;\n                }\n                let polyLineIdx = 1;\n                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n                for (let i = 0; i < worldPointsSet.length; i++) {\n                    const worldPoints = worldPointsSet[i];\n                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));\n                    const options = {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: this.configuration.opacity,\n                        closePath: true,\n                        lineWidth: 2,\n                    };\n                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n                    drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);\n                    polyLineIdx++;\n                }\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nfunction calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n    });\n}\nfunction calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n    actorEntries.forEach((actorEntry) => {\n        if (!actorEntry?.clippingFilter) {\n            return;\n        }\n        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n        if (!actorWorldPointsMap) {\n            actorWorldPointsMap = new Map();\n            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n        }\n        if (!actorWorldPointsMap.get(cacheId)) {\n            const polyData = actorEntry.clippingFilter.getOutputData();\n            const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n            if (!worldPointsSet) {\n                return;\n            }\n            const colorArray = actorEntry.actor.getProperty().getColor();\n            const color = colorToString(colorArray);\n            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n        }\n    });\n}\nfunction getCacheId(viewport) {\n    const { viewPlaneNormal } = viewport.getCamera();\n    const imageIndex = viewport.getCurrentImageIdIndex();\n    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\nfunction colorToString(colorArray) {\n    function colorComponentToString(component) {\n        let componentString = Math.floor(component * 255).toString(16);\n        if (componentString.length === 1) {\n            componentString = '0' + componentString;\n        }\n        return componentString;\n    }\n    return ('#' +\n        colorComponentToString(colorArray[0]) +\n        colorComponentToString(colorArray[1]) +\n        colorComponentToString(colorArray[2]));\n}\nfunction removeExtraPoints(viewport, worldPointsSet) {\n    return worldPointsSet.map((worldPoints) => {\n        const canvasPoints = worldPoints.map((point) => {\n            const canvasPoint = viewport.worldToCanvas(point);\n            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n        });\n        let lastPoint;\n        const newWorldPoints = [];\n        let newCanvasPoints = [];\n        for (let i = 0; i < worldPoints.length; i++) {\n            if (lastPoint) {\n                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n                    newWorldPoints.push(worldPoints[i]);\n                    newCanvasPoints.push(canvasPoints[i]);\n                }\n            }\n            lastPoint = canvasPoints[i];\n        }\n        const firstPoint = newCanvasPoints[0];\n        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {\n            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n                newCanvasPoints = newCanvasPoints.slice(0, j);\n                return newWorldPoints.slice(0, j);\n            }\n        }\n        return newWorldPoints;\n    });\n}\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { getEnabledElementByIds, getEnabledElement, VolumeViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseWheelCallback(evt) {\n        this._scroll(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        this._scrollDrag(evt);\n    }\n    _scrollDrag(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            utilities.scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _scroll(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        utilities.scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId: viewport instanceof BaseVolumeViewport\n                ? viewport.getVolumeId()\n                : undefined,\n            scrollSlabs: this.configuration.scrollSlabs,\n        });\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = viewport.getNumberOfSlices();\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport { eventTarget, getEnabledElement, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.onSetToolActive = () => {\n            const subscribeToElementResize = () => {\n                const viewportsInfo = this._getViewportsInfo();\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n        };\n        this.onSetToolDisabled = () => {\n            this._resizeObservers.forEach((resizeObserver, viewportId) => {\n                resizeObserver.disconnect();\n                this._resizeObservers.delete(viewportId);\n            });\n            if (this._viewportAddedListener) {\n                eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n                this._viewportAddedListener = null;\n            }\n        };\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 30,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { windowLevel } from '../utilities/voi';\nclass WindowLevelRegionTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minWindowWidth: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            removeAnnotation(annotation.annotationUID);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationCompleted(annotation);\n            this.applyWindowLevelRegion(annotation, element);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            const DEFAULT_HANDLE_INDEX = 3;\n            points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n            const bottomLeftCanvas = worldToCanvas(points[0]);\n            const topRightCanvas = worldToCanvas(points[3]);\n            const bottomRightCanvas = [\n                topRightCanvas[0],\n                bottomLeftCanvas[1],\n            ];\n            const topLeftCanvas = [\n                bottomLeftCanvas[0],\n                topRightCanvas[1],\n            ];\n            const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n            const topLeftWorld = canvasToWorld(topLeftCanvas);\n            points[1] = bottomRightWorld;\n            points[2] = topLeftWorld;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this.applyWindowLevelRegion = (annotation, element) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const startCanvas = canvasCoordinates[0];\n            const endCanvas = canvasCoordinates[3];\n            let left = Math.min(startCanvas[0], endCanvas[0]);\n            let top = Math.min(startCanvas[1], endCanvas[1]);\n            let width = Math.abs(startCanvas[0] - endCanvas[0]);\n            let height = Math.abs(startCanvas[1] - endCanvas[1]);\n            left = utilities.clip(left, 0, imageData.width);\n            top = utilities.clip(top, 0, imageData.height);\n            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n            const pixelLuminanceData = windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);\n            const minMaxMean = windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);\n            if (this.configuration.minWindowWidth === undefined) {\n                this.configuration.minWindowWidth = 10;\n            }\n            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);\n            const windowCenter = minMaxMean.mean;\n            const voiLutFunction = viewport.getProperties().VOILUTFunction;\n            const voiRange = utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n            viewport.setProperties({ voiRange });\n            viewport.render();\n        };\n        this.cancel = () => {\n            return null;\n        };\n        this.isPointNearTool = () => {\n            return null;\n        };\n        this.toolSelectedCallback = () => {\n            return null;\n        };\n        this.handleSelectedCallback = () => {\n            return null;\n        };\n        this._activateModify = () => {\n            return null;\n        };\n        this._deactivateModify = () => {\n            return null;\n        };\n    }\n}\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, cache, utilities, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        const properties = viewport.getProperties();\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n            viewportsContainingVolumeUID =\n                utilities.getViewportsWithVolumeId(volumeId);\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                throw new Error('Volume not found ' + volumeId);\n            }\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (properties.voiRange) {\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT && isPreScaled) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (newRange.lower >= newRange.upper) {\n            return;\n        }\n        viewport.setProperties({\n            voiRange: newRange,\n        });\n        viewport.render();\n        if (viewport instanceof VolumeViewport) {\n            viewportsContainingVolumeUID.forEach((vp) => {\n                if (viewport !== vp) {\n                    vp.render();\n                }\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        const voiLutFunction = viewport.getProperties().VOILUTFunction;\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { voxelManager } = viewport.getImageData();\n            const middleSlicePixelData = voxelManager.getMiddleSliceData();\n            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {\n                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];\n            }, [Infinity, -Infinity]);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        return ratio > 1 ? Math.round(ratio) : ratio;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData, voxelManager } = viewport.getImageData();\n        if (voxelManager?.getRange) {\n            const range = voxelManager.getRange();\n            return range[1] - range[0];\n        }\n        const dimensions = imageData.getDimensions();\n        if (imageData.getRange) {\n            const imageDataRange = imageData.getRange();\n            return imageDataRange[1] - imageDataRange[0];\n        }\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars().getData();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Enums, getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { Events } from '../enums';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.001,\n            maxZoomScale: 3000,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            const parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                spacing = imageData.spacing;\n                const { dimensions } = imageData;\n                const imageWidth = dimensions[0] * spacing[0];\n                const imageHeight = dimensions[1] * spacing[1];\n                const canvasAspect = size[0] / size[1];\n                const displayArea = viewport.options?.displayArea;\n                const imageAreaScaleX = displayArea?.imageArea?.[0] ?? 1.1;\n                const imageAreaScaleY = displayArea?.imageArea?.[1] ?? 1.1;\n                const scaledImageWidth = imageWidth * imageAreaScaleX;\n                const scaledImageHeight = imageHeight * imageAreaScaleY;\n                const scaledImageAspect = scaledImageWidth / scaledImageHeight;\n                let minParallelScaleRequired;\n                if (scaledImageAspect > canvasAspect) {\n                    minParallelScaleRequired = (scaledImageWidth / canvasAspect) * 0.5;\n                }\n                else {\n                    minParallelScaleRequired = scaledImageHeight * 0.5;\n                }\n                const { minZoomScale, maxZoomScale } = this.configuration;\n                const minScaleInWorld = minParallelScaleRequired / maxZoomScale;\n                const maxScaleInWorld = minParallelScaleRequired / minZoomScale;\n                if (parallelScaleToSet < minScaleInWorld) {\n                    cappedParallelScale = minScaleInWorld;\n                    thresholdExceeded = true;\n                }\n                else if (parallelScaleToSet > maxScaleInWorld) {\n                    cappedParallelScale = maxScaleInWorld;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    mouseWheelCallback(evt) {\n        this._zoom(evt);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _zoom(evt) {\n        const { element, points } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const wheelData = evt.detail.wheel;\n        const direction = wheelData.direction;\n        const eventDetails = {\n            detail: {\n                element,\n                eventName: Events.MOUSE_WHEEL,\n                renderingEngineId: enabledElement.renderingEngineId,\n                viewportId: viewport.id,\n                camera: {},\n                deltaPoints: {\n                    page: points.page,\n                    client: points.client,\n                    world: points.world,\n                    canvas: [0, -direction * 5],\n                },\n                startPoints: points,\n                lastPoints: points,\n                currentPoints: points,\n            },\n        };\n        if (viewport.type === Enums.ViewportType.STACK) {\n            this.preMouseDownCallback(eventDetails);\n        }\n        this._dragCallback(eventDetails);\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawPath as drawPathSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass AngleTool extends AnnotationTool {\n    static { this.toolName = 'Angle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            showAngleArc: false,\n            arcOffset: 5,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            if (!point3) {\n                return false;\n            }\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation.annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (this.configuration.showAngleArc) {\n                    const center = canvasCoordinates[1];\n                    const offset = this.configuration.arcOffset;\n                    const radius = Math.min(lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;\n                    const anglePoints = [];\n                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);\n                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);\n                    if (endAngle < startAngle) {\n                        endAngle += 2 * Math.PI;\n                    }\n                    const angleDifference = endAngle - startAngle;\n                    if (angleDifference > Math.PI) {\n                        const temp = startAngle;\n                        startAngle = endAngle;\n                        endAngle = temp + 2 * Math.PI;\n                    }\n                    const segments = 32;\n                    for (let i = 0; i <= segments; i++) {\n                        const angle = startAngle + (i / segments) * (endAngle - startAngle);\n                        anglePoints.push([\n                            center[0] + radius * Math.cos(angle),\n                            center[1] + radius * Math.sin(angle),\n                        ]);\n                    }\n                    drawPathSvg(svgDrawingHelper, annotationUID, '3', anglePoints, {\n                        color: color,\n                        width: lineWidth,\n                        lineDash: angleArcLineDash,\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            const { dimensions, imageData } = this.getTargetImageData(targetId);\n            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n                .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n                .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n            cachedStats[targetId] = {\n                angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    if (isNaN(angle)) {\n        return [`${angle}`];\n    }\n    const textLines = [\n        `${csUtils.roundNumber(angle)} ${String.fromCharCode(176)}`,\n    ];\n    return textLines;\n}\nexport default AngleTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { setAnnotationLabel } from '../../utilities';\nclass ArrowAnnotateTool extends AnnotationTool {\n    static { this.toolName = 'ArrowAnnotate'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n            arrowHeadStyle: 'legacy',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const { arrowFirst } = this.configuration;\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        arrowFirst,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((text) => {\n                    if (!text) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.text = text;\n                    triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n                    triggerAnnotationCompleted(annotation);\n                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });\n                    setAnnotationLabel(annotation, element, text);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                });\n            }\n            else if (!movingTextBox) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, text } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                renderStatus = true;\n                if (!text) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, points, text, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                text: text || '',\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const enabledElement = getEnabledElement(element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default ArrowAnnotateTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    static { this.toolName = 'Bidirectional'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nexport default BidirectionalTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    static { this.toolName = 'CircleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const radius = getCanvasCircleRadius(canvasCoordinates);\n            const radiusPoint = getCanvasCircleRadius([\n                canvasCoordinates[0],\n                canvasCoords,\n            ]);\n            if (Math.abs(radiusPoint - radius) < proximity / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            data.handles.points = [\n                data.handles.points[0],\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0) {\n                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n                const canvasCenter = currentCanvasPoints;\n                const canvasEnd = [\n                    canvasCoordinates[1][0] + dXCanvas,\n                    canvasCoordinates[1][1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasCenter);\n                points[1] = canvasToWorld(canvasEnd);\n            }\n            else {\n                points[1] = canvasToWorld(currentCanvasPoints);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const wasInvalidated = annotation.invalidated;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        pointsInShape,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        isEmptyArea,\n                        areaUnit,\n                        radius: worldWidth / 2 / scale,\n                        radiusUnit: unit,\n                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            if (wasInvalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { radius, radiusUnit, area, mean, stdDev, max, min, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(radius)) {\n        const radiusLine = isEmptyArea\n            ? `Radius: Oblique not supported`\n            : `Radius: ${csUtils.roundNumber(radius)} ${radiusUnit}`;\n        textLines.push(radiusLine);\n    }\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default CircleROITool;\n","import { vec3 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass CobbAngleTool extends AnnotationTool {\n    static { this.toolName = 'CobbAngle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            showArcLines: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n                viewport,\n                points: data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n                viewport,\n                points: annotation.data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined &&\n                (isNearFirstLine || isNearSecondLine)) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                if (isNearFirstLine) {\n                    const firstLinePoints = [points[0], points[1]];\n                    firstLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                else if (isNearSecondLine) {\n                    const secondLinePoints = [points[2], points[3]];\n                    secondLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length < 4) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.angleStartedNotYetCompleted = false;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                        arc1Angle: null,\n                        arc2Angle: null,\n                        points: {\n                            world: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                            canvas: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                        },\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];\n                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];\n                let lineUID = 'line1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = 'line2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = 'linkLine';\n                const mid1 = midPoint2(firstLine[0], firstLine[1]);\n                const mid2 = midPoint2(secondLine[0], secondLine[1]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;\n                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n                if (this.configuration.showArcLines) {\n                    lineUID = 'arc1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                    lineUID = 'arc2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = 'cobbAngleText';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n                if (this.configuration.showArcLines) {\n                    const arc1TextBoxUID = 'arcAngle1';\n                    const arc1TextLine = [\n                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                    const arc2TextBoxUID = 'arcAngle2';\n                    const arc2TextLine = [\n                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                }\n            }\n            return renderStatus;\n        };\n        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n            const [point1, point2, point3, point4] = points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            let isNearFirstLine = false;\n            let isNearSecondLine = false;\n            if (distanceToPoint <= proximity) {\n                isNearFirstLine = true;\n            }\n            else if (distanceToPoint2 <= proximity) {\n                isNearSecondLine = true;\n            }\n            return {\n                distanceToPoint,\n                distanceToPoint2,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n        };\n        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {\n            const linkLine = [mid1, mid2];\n            const arc1Angle = angleBetweenLines(firstLine, linkLine);\n            const arc2Angle = angleBetweenLines(secondLine, linkLine);\n            const arc1Side = arc1Angle > 90 ? 1 : 0;\n            const arc2Side = arc2Angle > 90 ? 0 : 1;\n            const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +\n                (linkLine[1][1] - linkLine[0][1]) ** 2);\n            const ratio = 0.1;\n            const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n            const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n            const directionVectorStartArc1 = [\n                firstLine[arc1Side][0] - midFirstLine[0],\n                firstLine[arc1Side][1] - midFirstLine[1],\n            ];\n            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);\n            const normalizedDirectionStartArc1 = [\n                directionVectorStartArc1[0] / magnitudeStartArc1,\n                directionVectorStartArc1[1] / magnitudeStartArc1,\n            ];\n            const arc1Start = [\n                midFirstLine[0] +\n                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n                midFirstLine[1] +\n                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc1 = [\n                midLinkLine[0] - mid1[0],\n                midLinkLine[1] - mid1[1],\n            ];\n            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);\n            const normalizedDirectionEndArc1 = [\n                directionVectorEndArc1[0] / magnitudeEndArc1,\n                directionVectorEndArc1[1] / magnitudeEndArc1,\n            ];\n            const arc1End = [\n                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorStartArc2 = [\n                secondLine[arc2Side][0] - midSecondLine[0],\n                secondLine[arc2Side][1] - midSecondLine[1],\n            ];\n            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);\n            const normalizedDirectionStartArc2 = [\n                directionVectorStartArc2[0] / magnitudeStartArc2,\n                directionVectorStartArc2[1] / magnitudeStartArc2,\n            ];\n            const arc2Start = [\n                midSecondLine[0] +\n                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n                midSecondLine[1] +\n                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc2 = [\n                midLinkLine[0] - mid2[0],\n                midLinkLine[1] - mid2[1],\n            ];\n            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);\n            const normalizedDirectionEndArc2 = [\n                directionVectorEndArc2[0] / magnitudeEndArc2,\n                directionVectorEndArc2[1] / magnitudeEndArc2,\n            ];\n            const arc2End = [\n                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n            ];\n            return {\n                arc1Start,\n                arc1End,\n                arc2Start,\n                arc2End,\n                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n            };\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 25, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const firstLine = [canvasPoints[0], canvasPoints[1]];\n        const secondLine = [canvasPoints[2], canvasPoints[3]];\n        const mid1 = midPoint2(firstLine[0], firstLine[1]);\n        const mid2 = midPoint2(secondLine[0], secondLine[1]);\n        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({\n            firstLine,\n            secondLine,\n            mid1,\n            mid2,\n        });\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            cachedStats[targetId] = {\n                angle: angleBetweenLines(seg1, seg2),\n                arc1Angle,\n                arc2Angle,\n                points: {\n                    canvas: {\n                        arc1Start,\n                        arc1End,\n                        arc2End,\n                        arc2Start,\n                    },\n                    world: {\n                        arc1Start: viewport.canvasToWorld(arc1Start),\n                        arc1End: viewport.canvasToWorld(arc1End),\n                        arc2End: viewport.canvasToWorld(arc2End),\n                        arc2Start: viewport.canvasToWorld(arc2Start),\n                    },\n                },\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n    return textLines;\n}\nexport default CobbAngleTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nclass DragProbeTool extends ProbeTool {\n    static { this.toolName = 'DragProbe'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const { color } = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].value === null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n    return textLines;\n}\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawLine } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../../utilities/math/circle';\nimport { vec3 } from 'gl-matrix';\nconst CROSSHAIR_SIZE = 5;\nclass ETDRSGridTool extends AnnotationTool {\n    static { this.toolName = 'ETDRSGrid'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            degrees: [45, 135, 225, 315],\n            diameters: [10, 30, 60],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                    },\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const center = viewport.worldToCanvas(points[0]);\n            const radius = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radius) < proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                canvasToWorld(currentCanvasPoints),\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { deltaPoints } = eventDetail;\n            const worldPosDelta = deltaPoints.world;\n            const points = data.handles.points;\n            points.forEach((point) => {\n                point[0] += worldPosDelta[0];\n                point[1] += worldPosDelta[1];\n                point[2] += worldPosDelta[2];\n            });\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n            const canvasCenter = currentCanvasPoints;\n            const canvasEnd = [\n                canvasCoordinates[1][0] + dXCanvas,\n                canvasCoordinates[1][1] + dYCanvas,\n            ];\n            points[0] = canvasToWorld(canvasCenter);\n            points[1] = canvasToWorld(canvasEnd);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const { renderingEngine } = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                let lineUID = `${annotationUID}-crosshair-vertical`;\n                let start = [center[0], center[1] + CROSSHAIR_SIZE];\n                let end = [center[0], center[1] - CROSSHAIR_SIZE];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                lineUID = `${annotationUID}-crosshair-horizontal`;\n                start = [center[0] + CROSSHAIR_SIZE, center[1]];\n                end = [center[0] - CROSSHAIR_SIZE, center[1]];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));\n                for (let i = 0; i < diametersCanvas.length; i++) {\n                    const dataId = `${annotationUID}-circle-${i}`;\n                    const circleUID = `${annotationUID}-circle-${i}`;\n                    drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    }, dataId);\n                }\n                const degreesRad = (x) => (x * Math.PI) / 180;\n                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));\n                for (let i = 0; i < angleRadians.length; i++) {\n                    const lineUID = `${annotationUID}-line-${i}`;\n                    const start = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],\n                    ];\n                    const end = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],\n                    ];\n                    drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n    worldMeasureToCanvas(measurement, viewport) {\n        const p1 = viewport.canvasToWorld([\n            viewport.canvas.width / 2,\n            viewport.canvas.height / 2,\n        ]);\n        const { viewUp } = viewport.getCamera();\n        const p2 = vec3.scaleAndAdd(vec3.create(), p1, viewUp, measurement);\n        const p1Canvas = viewport.worldToCanvas(p1);\n        const p2Canvas = viewport.worldToCanvas(p2);\n        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +\n            Math.pow(p2Canvas[1] - p1Canvas[1], 2));\n        return distance;\n    }\n}\nexport default ETDRSGridTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawEllipseByCoordinates as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2 } from 'gl-matrix';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    static { this.toolName = 'EllipticalROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    initialRotation: viewport.getRotation(),\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerWorld: worldPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const [bottom, top, left, right] = canvasCoordinates;\n            const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n            const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n            const angle = Math.atan2(left[1] - right[1], left[0] - right[0]);\n            const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n            const minorEllipse = {\n                center,\n                xRadius: (w - proximity) / 2,\n                yRadius: (h - proximity) / 2,\n                angle,\n            };\n            const majorEllipse = {\n                center,\n                xRadius: (w + proximity) / 2,\n                yRadius: (h + proximity) / 2,\n                angle,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let centerWorld;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const { viewport } = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n                centerWorld = canvasToWorld(centerCanvas);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerWorld,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const post2Index = transformWorldToIndex(imageData, worldPos2);\n                post2Index[0] = Math.floor(post2Index[0]);\n                post2Index[1] = Math.floor(post2Index[1]);\n                post2Index[2] = Math.floor(post2Index[2]);\n                this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);\n                const iMin = Math.min(pos1Index[0], post2Index[0]);\n                const iMax = Math.max(pos1Index[0], post2Index[0]);\n                const jMin = Math.min(pos1Index[1], post2Index[1]);\n                const jMax = Math.max(pos1Index[1], post2Index[1]);\n                const kMin = Math.min(pos1Index[2], post2Index[2]);\n                const kMax = Math.max(pos1Index[2], post2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = [\n                    (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                    (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                    (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                ];\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                const handles = [pos1Index, post2Index];\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n                    scale /\n                    scale;\n                const pixelUnitsOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                let pointsInShape;\n                if (voxelManager) {\n                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                        boundsIJK,\n                        imageData,\n                        isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                        returnPoints: this.configuration.storePointData,\n                    });\n                }\n                const stats = this.configuration.statsCalculator.getStatistics();\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    mean: stats.mean?.value,\n                    max: stats.max?.value,\n                    min: stats.min?.value,\n                    stdDev: stats.stdDev?.value,\n                    statsArray: stats.array,\n                    pointsInShape,\n                    isEmptyArea,\n                    areaUnit,\n                    modalityUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    _pointInEllipseCanvas(ellipse, location) {\n        const { xRadius, yRadius, center, angle } = ellipse;\n        const rotLocation = vec2.rotate(vec2.create(), location, center, -angle);\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const normalized = [rotLocation[0] - center[0], rotLocation[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default EllipticalROITool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawHeight as drawHeightSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass HeightTool extends AnnotationTool {\n    static { this.toolName = 'Height'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const heightUID = '0';\n                drawHeightSvg(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash: lineDash,\n                });\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateHeight(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        const dz = pos2[2] - pos1[2];\n        if (dx == 0) {\n            if (dy != 0) {\n                return Math.abs(dz);\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (dy == 0) {\n            return Math.abs(dz);\n        }\n        else if (dz == 0) {\n            return Math.abs(dy);\n        }\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n            const outside = this._isInsideVolume(index1, index2, dimensions);\n            this.isHandleOutsideImage = outside;\n            cachedStats[targetId] = {\n                height,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { height, unit } = cachedVolumeStats;\n    if (height === undefined || height === null || isNaN(height)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(height)} ${unit}`];\n    return textLines;\n}\nexport default HeightTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg, drawHandles as drawHandlesSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass KeyImageTool extends AnnotationTool {\n    static { this.toolName = 'KeyImage'; }\n    static { this.dataSeries = {\n        data: {\n            seriesLevel: true,\n        },\n    }; }\n    static { this.dataPoint = {\n        data: {\n            isPoint: true,\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextCallback,\n            changeTextCallback,\n            canvasPosition: [10, 10],\n            canvasSize: 10,\n            handleRadius: '6',\n            seriesLevel: false,\n            isPoint: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const worldPos = currentPoints.world;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                    seriesLevel: this.configuration.seriesLevel,\n                    isPoint: this.configuration.isPoint,\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((text) => {\n                if (!text) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                annotation.data.text = text;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            if (!data?.isPoint) {\n                return false;\n            }\n            const { canvasPosition, canvasSize } = this.configuration;\n            if (!canvasPosition?.length) {\n                return false;\n            }\n            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n                canvasSize / 2 &&\n                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n                    canvasSize / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            annotation.highlighted = true;\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.createMemo(element, annotation);\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.isDrawing = false;\n            this.doneEditMemo();\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { canvasPosition, canvasSize } = this.configuration;\n                const arrowUID = '1';\n                if (data?.isPoint) {\n                    const point = data.handles.points[0];\n                    const canvasCoordinates = viewport.worldToCanvas(point);\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {\n                        color,\n                        lineWidth,\n                        handleRadius: this.configuration.handleRadius,\n                    });\n                }\n                else if (canvasPosition?.length) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {\n                        color,\n                        width: 1,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {\n        annotation.data.isPoint = isPoint;\n        triggerAnnotationModified(annotation, element);\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    cancel(element) {\n        if (this.isDrawing) {\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default KeyImageTool;\n","import { vec2 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass LabelTool extends AnnotationTool {\n    static { this.toolName = 'Label'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotationUID } = annotation;\n            const point = annotation.data.handles.points[0];\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            const dist = vec2.distance(canvasCoords, annotationCanvasCoordinate);\n            if (dist < proximity) {\n                return true;\n            }\n            const svgLayer = element.querySelector('svg');\n            if (!svgLayer) {\n                return false;\n            }\n            const textGroup = svgLayer.querySelector(`g[data-annotation-uid=\"${annotationUID}\"]`);\n            if (!textGroup) {\n                return false;\n            }\n            const textGroupElement = textGroup;\n            const bbox = textGroupElement.getBBox();\n            const transform = textGroupElement.getAttribute('transform');\n            let translateX = 0;\n            let translateY = 0;\n            if (transform) {\n                const matches = transform.match(/translate\\(([-\\d.]+)\\s+([-\\d.]+)\\)/);\n                if (matches) {\n                    translateX = parseFloat(matches[1]);\n                    translateY = parseFloat(matches[2]);\n                }\n            }\n            const x = bbox.x + translateX;\n            const y = bbox.y + translateY;\n            const isNear = canvasCoords[0] >= x &&\n                canvasCoords[0] <= x + bbox.width &&\n                canvasCoords[1] >= y &&\n                canvasCoords[1] <= y + bbox.height;\n            return isNear;\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID: null,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n                offset: [0, 0, 0],\n            };\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((text) => {\n                if (!text) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                resetElementCursor(element);\n                annotation.data.text = text;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            let offset = [0, 0, 0];\n            if (currentPoints && currentPoints.world) {\n                const initialWorldPos = currentPoints.world;\n                const anchorWorldPos = annotation.data.handles.points[0];\n                offset = [\n                    anchorWorldPos[0] - initialWorldPos[0],\n                    anchorWorldPos[1] - initialWorldPos[1],\n                    anchorWorldPos[2] - initialWorldPos[2],\n                ];\n            }\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                offset,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, offset } = this.editData;\n            if (offset) {\n                annotation.data.handles.points[0] = [\n                    worldPos[0] + offset[0],\n                    worldPos[1] + offset[1],\n                    worldPos[2] + offset[2],\n                ];\n            }\n            else {\n                annotation.data.handles.points[0] = [...worldPos];\n            }\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const point = data.handles.points[0];\n                styleSpecifier.annotationUID = annotationUID;\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!data.text) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                const textBoxUID = '1';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [data.text], canvasCoordinates, {\n                    ...options,\n                    padding: 0,\n                });\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, position, text, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                text,\n                handles: {\n                    points: [position],\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle, interactionType) { }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nLabelTool.toolName = 'Label';\nexport default LabelTool;\n","import { Events, ChangeTypes } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    static { this.toolName = 'Length'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const length = this._calculateLength(worldPos1, worldPos2) / scale;\n            if (this._isInsideVolume(index1, index2, dimensions)) {\n                this.isHandleOutsideImage = false;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n            }\n            cachedStats[targetId] = {\n                length,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n    if (length === undefined || length === null || isNaN(length)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(length)} ${unit}`];\n    return textLines;\n}\nexport default LengthTool;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n    static { this.toolName = 'LivewireContourSegmentationTool'; }\n    updateInterpolatedAnnotation(annotation, enabledElement) {\n        if (this.editData ||\n            !annotation.invalidated ||\n            !annotation.data.handles.interpolationSources) {\n            return;\n        }\n        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n        queueMicrotask(() => {\n            if (!annotation.data.handles.interpolationSources) {\n                return;\n            }\n            const { points } = annotation.data.handles;\n            const { element } = enabledElement.viewport;\n            this.setupBaseEditData(points[0], element, annotation);\n            const { length: count } = points;\n            const { scissors } = this;\n            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;\n            annotation.data.handles.originalPoints = points;\n            const { worldToSlice, sliceToWorld } = this.editData;\n            const handleSmoothing = [];\n            if (nearestEdge) {\n                let lastPoint = worldToSlice(points[points.length - 1]);\n                points.forEach((point, hIndex) => {\n                    const testPoint = worldToSlice(point);\n                    lastPoint = testPoint;\n                    handleSmoothing.push(testPoint);\n                    scissors.startSearch(lastPoint);\n                    scissors.findPathToPoint(testPoint);\n                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));\n                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n                    if (!csUtils.isEqual(testPoint, minPoint)) {\n                        handleSmoothing[hIndex] = minPoint;\n                        lastPoint = minPoint;\n                        points[hIndex] = sliceToWorld(minPoint);\n                    }\n                });\n            }\n            const acceptedPath = new LivewirePath();\n            for (let i = 0; i < count; i++) {\n                scissors.startSearch(worldToSlice(points[i]));\n                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));\n                acceptedPath.addPoints(path);\n            }\n            this.updateAnnotation(acceptedPath);\n            this.scissors = null;\n            this.scissorsNext = null;\n            this.editData = null;\n            annotation.data.handles.interpolationSources = null;\n            if (repeatInterpolation) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.InterpolationUpdated);\n            }\n        });\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { showInterpolationPolyline } = this.configuration.interpolation || {};\n        this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n        const { originalPolyline } = annotation.data.contour;\n        const rendered = super.renderAnnotationInstance(renderContext);\n        if (showInterpolationPolyline &&\n            originalPolyline &&\n            annotation.autoGenerated) {\n            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);\n            polylineCanvasPoints.push(polylineCanvasPoints[0]);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {\n                color: '#70ffff',\n                lineWidth: 1,\n                fillOpacity: 0,\n            });\n        }\n        return rendered;\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n}\nexport default LivewireContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, VolumeViewport, utilities, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport * as math from '../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale, throttle } from '../../utilities';\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'LivewireContour'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextLines: defaultGetTextLines,\n            calculateStats: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            snapHandleNearby: 2,\n            interpolation: {\n                enabled: false,\n                nearestEdge: 2,\n                showInterpolationPolyline: false,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            actions: {\n                cancelInProgress: {\n                    method: 'cancelInProgress',\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const proximitySquared = proximity * proximity;\n            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            let startPoint = canvasPoints[canvasPoints.length - 1];\n            for (let i = 0; i < canvasPoints.length; i++) {\n                const endPoint = canvasPoints[i];\n                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);\n                if (distanceToPointSquared <= proximitySquared) {\n                    return true;\n                }\n                startPoint = endPoint;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt, clearAnnotation = false) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            if ((this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) ||\n                clearAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n                this.clearEditData();\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                return;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);\n            this.clearEditData();\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {\n            if (changeType === ChangeTypes.Completed) {\n                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);\n            }\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;\n            if (this.editData.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n            let worldPos = worldPosOriginal;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const controlPoints = this.editData.currentPath.getControlPoints();\n            let closePath = controlPoints.length >= 2 && doubleClick;\n            this.doneEditMemo();\n            this.createMemo(element, annotation, {\n                newAnnotation: newAnnotation && controlPoints.length === 1,\n            });\n            if (controlPoints.length >= 2) {\n                const closestHandlePoint = {\n                    index: -1,\n                    distSquared: Infinity,\n                };\n                for (let i = 0, len = controlPoints.length; i < len; i++) {\n                    const controlPoint = controlPoints[i];\n                    const worldControlPoint = sliceToWorld(controlPoint);\n                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);\n                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n                        distSquared < closestHandlePoint.distSquared) {\n                        closestHandlePoint.distSquared = distSquared;\n                        closestHandlePoint.index = i;\n                    }\n                }\n                if (closestHandlePoint.index === 0) {\n                    closePath = true;\n                }\n            }\n            const { snapHandleNearby } = this.configuration;\n            if (snapHandleNearby && !this.editData.closed) {\n                const currentPath = new LivewirePath();\n                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);\n                const pathPoints = this.scissors.findPathToPoint(snapPoint);\n                currentPath.addPoints(pathPoints);\n                currentPath.prependPath(this.editData.confirmedPath);\n                worldPos = sliceToWorld(snapPoint);\n                this.editData.currentPath = currentPath;\n            }\n            this.editData.closed = this.editData.closed || closePath;\n            this.editData.confirmedPath = this.editData.currentPath;\n            const lastPoint = this.editData.currentPath.getLastPoint();\n            this.editData.confirmedPath.addControlPoint(lastPoint);\n            annotation.data.handles.points.push(sliceToWorld(lastPoint));\n            this.scissors.startSearch(worldToSlice(worldPos));\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (this.editData.closed) {\n                this.updateAnnotation(this.editData.confirmedPath);\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { element, currentPoints } = evt.detail;\n            const { world: worldPos, canvas: canvasPos } = currentPoints;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = canvasPos;\n            const { width: imgWidth, height: imgHeight } = this.scissors;\n            const { worldToSlice } = this.editData;\n            const slicePoint = worldToSlice(worldPos);\n            if (slicePoint[0] < 0 ||\n                slicePoint[1] < 0 ||\n                slicePoint[0] >= imgWidth ||\n                slicePoint[1] >= imgHeight) {\n                return;\n            }\n            const pathPoints = this.scissors.findPathToPoint(slicePoint);\n            const currentPath = new LivewirePath();\n            currentPath.addPoints(pathPoints);\n            currentPath.prependPath(this.editData.confirmedPath);\n            this.editData.currentPath = currentPath;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                console.warn('Drag annotation not implemented');\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                this.editHandle(worldPos, element, annotation, handleIndex);\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            if (newAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.scissors = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit: areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.contour.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const viewportImageData = viewport.getImageData();\n        const { imageData: vtkImageData } = viewportImageData;\n        let worldToSlice;\n        let sliceToWorld;\n        let width;\n        let height;\n        let scalarData;\n        if (!(viewport instanceof VolumeViewport)) {\n            width = viewportImageData.dimensions[0];\n            height = viewportImageData.dimensions[1];\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                return [ijkPoint[0], ijkPoint[1]];\n            };\n            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n            scalarData = viewportImageData.scalarData;\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);\n                return [slicePoint[0], slicePoint[1]];\n            };\n            sliceToWorld = (point) => {\n                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);\n                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n            };\n            scalarData = sliceImageData.scalarData;\n            width = sliceImageData.width;\n            height = sliceImageData.height;\n        }\n        else {\n            throw new Error('Viewport not supported');\n        }\n        scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n        const { voiRange } = viewport.getProperties();\n        const startPos = worldToSlice(worldPos);\n        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n        if (nextPos) {\n            this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n            this.scissorsNext.startSearch(worldToSlice(nextPos));\n        }\n        this.scissors.startSearch(startPos);\n        const newAnnotation = !nextPos;\n        const confirmedPath = new LivewirePath();\n        const currentPath = new LivewirePath();\n        const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n        confirmedPath.addPoint(startPos);\n        confirmedPath.addControlPoint(startPos);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            newAnnotation,\n            hasMoved: false,\n            lastCanvasPoint,\n            confirmedPath,\n            currentPath,\n            confirmedPathNext: currentPathNext,\n            closed: false,\n            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n            worldToSlice,\n            sliceToWorld,\n            contourHoleProcessingEnabled,\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const annotation = this.createAnnotation(evt);\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);\n        this.addAnnotation(annotation, element);\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(this.editData.viewportIdsToRender);\n        return annotation;\n    }\n    clearEditData() {\n        this.editData = null;\n        this.scissors = null;\n        this.scissorsNext = null;\n        this.isDrawing = false;\n    }\n    editHandle(worldPos, element, annotation, handleIndex) {\n        const { data } = annotation;\n        const { points: handlePoints } = data.handles;\n        const { length: numHandles } = handlePoints;\n        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n        if (!this.editData?.confirmedPathNext) {\n            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n            const { polyline } = data.contour;\n            const confirmedPath = new LivewirePath();\n            const confirmedPathNext = new LivewirePath();\n            const { worldToSlice } = this.editData;\n            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);\n            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n            if (nextIndex === -1 || previousIndex === -1) {\n                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);\n            }\n            if (handleIndex === 0) {\n                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));\n            }\n            else {\n                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));\n                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));\n            }\n            this.editData.confirmedPath = confirmedPath;\n            this.editData.confirmedPathNext = confirmedPathNext;\n        }\n        const { editData, scissors } = this;\n        const { worldToSlice, sliceToWorld } = editData;\n        const { activeHandleIndex } = data.handles;\n        if (activeHandleIndex === null || activeHandleIndex === undefined) {\n            data.handles.activeHandleIndex = handleIndex;\n        }\n        else if (activeHandleIndex !== handleIndex) {\n            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);\n        }\n        const slicePos = worldToSlice(worldPos);\n        if (slicePos[0] < 0 ||\n            slicePos[0] >= scissors.width ||\n            slicePos[1] < 0 ||\n            slicePos[1] >= scissors.height) {\n            return;\n        }\n        handlePoints[handleIndex] = sliceToWorld(slicePos);\n        const pathPointsLeft = scissors.findPathToPoint(slicePos);\n        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n        const currentPath = new LivewirePath();\n        currentPath.prependPath(editData.confirmedPath);\n        if (handleIndex !== 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        currentPath.addPoints(pathPointsRight.reverse());\n        currentPath.appendPath(editData.confirmedPathNext);\n        if (handleIndex === 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        editData.currentPath = currentPath;\n        annotation.invalidated = true;\n        editData.hasMoved = true;\n        editData.closed = true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        this.updateAnnotation(this.editData?.currentPath);\n        return super.renderAnnotation(enabledElement, svgDrawingHelper);\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const contourSegmentationAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n            },\n        });\n        return annotation;\n    }\n    cancelInProgress(element, config, evt) {\n        if (!this.editData) {\n            this.undo();\n            return;\n        }\n        this._endCallback(evt, true);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const { worldToCanvas } = viewport;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color } = annotationStyle;\n        if (highlighted ||\n            (newAnnotation &&\n                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {\n            const handleGroupUID = '0';\n            const canvasHandles = handles.points.map(worldToCanvas);\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {\n                color,\n                lineDash,\n                lineWidth,\n            });\n        }\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId]?.areaUnit === null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        return true;\n    }\n    updateAnnotation(livewirePath) {\n        if (!this.editData || !livewirePath) {\n            return;\n        }\n        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;\n        let { pointArray: imagePoints } = livewirePath;\n        if (imagePoints.length > 1) {\n            imagePoints = [...imagePoints, imagePoints[0]];\n        }\n        const targetWindingDirection = newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n        this.updateContourPolyline(annotation, {\n            points: imagePoints,\n            closed,\n            targetWindingDirection,\n        }, {\n            canvasToWorld: sliceToWorld,\n            worldToCanvas: worldToSlice,\n        });\n    }\n}\nexport default LivewireContourTool;\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    static { this.toolName = 'Probe'; }\n    static { this.probeDefaults = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            handleRadius: '6',\n            textCanvasOffset: {\n                x: 6,\n                y: -6,\n            },\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps) {\n        super(toolProps, AnnotationTool.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats) {\n                    data.cachedStats = {};\n                }\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].value === null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, ChangeTypes.StatsUpdated);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,\n                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        return vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n    }\n    toolSelectedCallback() { }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = ChangeTypes.StatsUpdated) {\n        const data = annotation.data;\n        const { renderingEngineId, viewport } = enabledElement;\n        const { element } = viewport;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const pixelUnitsOptions = {\n                isPreScaled: isViewportPreScaled(viewport, targetId),\n                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n            };\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata, voxelManager } = image;\n            const modality = metadata.Modality;\n            let ijk = transformWorldToIndex(imageData, worldPos);\n            ijk = vec3.round(ijk, ijk);\n            if (csUtils.indexWithinDimensions(ijk, dimensions)) {\n                this.isHandleOutsideImage = false;\n                let value = voxelManager.getAtIJKPoint(ijk);\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = csUtils.getViewportsWithImageURI(imageURI);\n                    const viewport = viewports[0];\n                    ijk[2] = viewport.getCurrentImageIdIndex();\n                }\n                let modalityUnit;\n                if (modality === 'US') {\n                    const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n                        ijk,\n                    ]);\n                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);\n                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);\n                    modalityUnit = hasEnhancedRegionValues\n                        ? calibratedResults.units\n                        : 'raw';\n                }\n                else {\n                    modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                }\n                cachedStats[targetId] = {\n                    index: ijk,\n                    value,\n                    Modality: modality,\n                    modalityUnit,\n                };\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index: ijk,\n                    Modality: modality,\n                };\n            }\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, changeType);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined || !index) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    if (value instanceof Array && modalityUnit instanceof Array) {\n        for (let i = 0; i < value.length; i++) {\n            textLines.push(`${csUtils.roundNumber(value[i])} ${modalityUnit[i]}`);\n        }\n    }\n    else {\n        textLines.push(`${csUtils.roundNumber(value)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default ProbeTool;\n","import { cache, utilities as csUtils, getEnabledElement, } from '@cornerstonejs/core';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nimport { calculateGrowCutSeeds } from '../../utilities/segmentation/growCut/runOneClickGrowCut';\nimport { ToolModes } from '../../enums';\nclass RegionSegmentPlusTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegmentPlus'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: false,\n            positiveSeedVariance: 0.4,\n            negativeSeedVariance: 0.9,\n            subVolumePaddingPercentage: 0.1,\n            islandRemoval: {\n                enabled: false,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseTimer = null;\n        this.allowedToProceed = false;\n    }\n    mouseMoveCallback(evt) {\n        if (this.mode !== ToolModes.Active) {\n            return;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const { world: worldPoint } = currentPoints;\n        element.style.cursor = 'default';\n        if (this.mouseTimer !== null) {\n            window.clearTimeout(this.mouseTimer);\n            this.mouseTimer = null;\n        }\n        this.mouseTimer = window.setTimeout(() => {\n            this.onMouseStable(evt, worldPoint, element);\n        }, this.configuration.mouseStabilityDelay || 500);\n    }\n    async onMouseStable(evt, worldPoint, element) {\n        await super.preMouseDownCallback(evt);\n        const refVolume = cache.getVolume(this.growCutData.segmentation.referencedVolumeId);\n        const seeds = calculateGrowCutSeeds(refVolume, worldPoint, {}) || {\n            positiveSeedIndices: new Set(),\n            negativeSeedIndices: new Set(),\n        };\n        const { positiveSeedIndices, negativeSeedIndices } = seeds;\n        let cursor;\n        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||\n            negativeSeedIndices.size < 30) {\n            cursor = 'not-allowed';\n            this.allowedToProceed = false;\n        }\n        else {\n            cursor = 'copy';\n            this.allowedToProceed = true;\n        }\n        const enabledElement = getEnabledElement(element);\n        if (element) {\n            element.style.cursor = cursor;\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== cursor) {\n                    element.style.cursor = cursor;\n                }\n            });\n        }\n        if (this.allowedToProceed) {\n            this.seeds = seeds;\n        }\n        if (enabledElement && enabledElement.viewport) {\n            enabledElement.viewport.render();\n        }\n    }\n    async preMouseDownCallback(evt) {\n        if (!this.allowedToProceed) {\n            return false;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        if (enabledElement) {\n            element.style.cursor = 'wait';\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== 'wait') {\n                    element.style.cursor = 'wait';\n                }\n            });\n        }\n        const { world: worldPoint } = currentPoints;\n        await super.preMouseDownCallback(evt);\n        this.growCutData = csUtils.deepMerge(this.growCutData, {\n            worldPoint,\n            islandRemoval: {\n                worldIslandPoints: [worldPoint],\n            },\n        });\n        this.growCutData.worldPoint = worldPoint;\n        this.growCutData.islandRemoval = {\n            worldIslandPoints: [worldPoint],\n        };\n        await this.runGrowCut();\n        if (element) {\n            element.style.cursor = 'default';\n        }\n        return true;\n    }\n    getRemoveIslandData(growCutData) {\n        const { worldPoint } = growCutData;\n        return {\n            worldIslandPoints: [worldPoint],\n        };\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;\n        const { subVolumePaddingPercentage } = this.configuration;\n        const mergedOptions = {\n            ...options,\n            subVolumePaddingPercentage,\n            seeds: this.seeds,\n        };\n        return growCut.runOneClickGrowCut({\n            referencedVolumeId,\n            worldPosition: worldPoint,\n            options: mergedOptions,\n        });\n    }\n}\nexport default RegionSegmentPlusTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getRenderingEngine, } from '@cornerstonejs/core';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nclass RegionSegmentTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegment'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positiveSeedVariance: 0.5,\n            negativeSeedVariance: 0.9,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.growCutData.circleBorderPoint = currentWorldPoint;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        await super.preMouseDownCallback(evt);\n        Object.assign(this.growCutData, {\n            circleCenterPoint: worldPoint,\n            circleBorderPoint: worldPoint,\n        });\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const worldCircleRadius = vec3.len(vec3.sub(vec3.create(), circleCenterPoint, circleBorderPoint));\n        const sphereInfo = {\n            center: circleCenterPoint,\n            radius: worldCircleRadius,\n        };\n        return growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;\n        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);\n        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);\n        const vecCenterToBorder = vec2.sub(vec2.create(), canvasBorderPoint, canvasCenterPoint);\n        const circleRadius = vec2.len(vecCenterToBorder);\n        if (csUtils.isEqual(circleRadius, 0)) {\n            return;\n        }\n        const annotationUID = 'growcut';\n        const circleUID = '0';\n        const { color } = this.getSegmentStyle({\n            segmentationId: segmentationData.segmentationId,\n            segmentIndex: segmentationData.segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {\n            color,\n        });\n    }\n}\nexport default RegionSegmentTool;\n","import { eventTarget, utilities } from '@cornerstonejs/core';\nimport SplineROITool from './SplineROITool';\nimport { Events } from '../../enums';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nclass SplineContourSegmentationTool extends SplineROITool {\n    static { this.toolName = 'SplineContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.annotationCutMergeCompletedBinded =\n            this.annotationCutMergeCompleted.bind(this);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    annotationCutMergeCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (!this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n}\nexport default SplineContourSegmentationTool;\n","import { getEnabledElement, eventTarget, triggerEvent, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getChildAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, MouseBindings, KeyboardBindings, ChangeTypes, } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport * as math from '../../utilities/math';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\nconst DEFAULT_SPLINE_CONFIG = {\n    resolution: 20,\n    controlPointAdditionDistance: 6,\n    controlPointDeletionDistance: 6,\n    showControlPointsConnectors: false,\n    controlPointAdditionEnabled: true,\n    controlPointDeletionEnabled: true,\n};\nvar SplineTypesEnum;\n(function (SplineTypesEnum) {\n    SplineTypesEnum[\"Cardinal\"] = \"CARDINAL\";\n    SplineTypesEnum[\"Linear\"] = \"LINEAR\";\n    SplineTypesEnum[\"CatmullRom\"] = \"CATMULLROM\";\n    SplineTypesEnum[\"BSpline\"] = \"BSPLINE\";\n})(SplineTypesEnum || (SplineTypesEnum = {}));\nvar SplineToolActions;\n(function (SplineToolActions) {\n    SplineToolActions[\"AddControlPoint\"] = \"addControlPoint\";\n    SplineToolActions[\"DeleteControlPoint\"] = \"deleteControlPoint\";\n})(SplineToolActions || (SplineToolActions = {}));\nclass SplineROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'SplineROI'; }\n    static { this.SplineTypes = SplineTypesEnum; }\n    static { this.Actions = SplineToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            simplifiedSpline: false,\n            getTextLines: defaultGetTextLines,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            spline: {\n                configuration: {\n                    [SplineTypesEnum.Cardinal]: {\n                        Class: CardinalSpline,\n                        scale: 0.5,\n                    },\n                    [SplineTypesEnum.CatmullRom]: {\n                        Class: CatmullRomSpline,\n                    },\n                    [SplineTypesEnum.Linear]: {\n                        Class: LinearSpline,\n                    },\n                    [SplineTypesEnum.BSpline]: {\n                        Class: BSpline,\n                        controlPointAdditionEnabled: false,\n                        controlPointDeletionEnabled: false,\n                        showControlPointsConnectors: true,\n                    },\n                },\n                type: SplineTypesEnum.CatmullRom,\n                drawPreviewEnabled: true,\n                enableTwoPointPreview: false,\n                lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n            },\n            actions: {\n                [SplineToolActions.AddControlPoint]: {\n                    method: 'addControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n                [SplineToolActions.DeleteControlPoint]: {\n                    method: 'deleteControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Ctrl,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.splineToolNames = [\n            'CatmullRomSplineROI',\n            'LinearSplineROI',\n            'BSplineROI',\n            'CardinalSplineROI',\n        ];\n        this.isHandleOutsideImage = false;\n        this.fireChangeOnUpdate = null;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { instance: spline } = annotation.data.spline;\n            return spline.isPointNearCurve(canvasCoords, proximity);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            annotation.autoGenerated = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));\n            const { imageData, dimensions } = image;\n            this.isHandleOutsideImage = data.handles.points\n                .map((p) => utilities.transformWorldToIndex(imageData, p))\n                .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            if (!this.fireChangeOnUpdate) {\n                this.fireChangeOnUpdate = {\n                    annotationUID: annotation.annotationUID,\n                    changeType,\n                    contourHoleProcessingEnabled,\n                };\n            }\n            else {\n                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n                this.fireChangeOnUpdate.changeType = changeType;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._keyDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const key = eventDetail.key ?? '';\n            const { lastControlPointDeletionKeys } = this.configuration.spline;\n            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n            if (!deleteLastPoint) {\n                return;\n            }\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length === SPLINE_MIN_POINTS) {\n                this.cancel(element);\n                return;\n            }\n            else {\n                const controlPointIndex = data.handles.points.length - 1;\n                this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { drawPreviewEnabled } = this.configuration.spline;\n            if (!drawPreviewEnabled) {\n                return;\n            }\n            const { element } = evt.detail;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            if (data.contour.closed) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n            let closeContour = data.handles.points.length >= 2 && doubleClick;\n            let addNewPoint = true;\n            if (data.handles.points.length) {\n                this.createMemo(element, annotation, {\n                    newAnnotation: data.handles.points.length === 1,\n                });\n            }\n            if (data.handles.points.length >= 3) {\n                this.createMemo(element, annotation);\n                const { instance: spline } = data.spline;\n                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                if (closestControlPoint?.index === 0) {\n                    addNewPoint = false;\n                    closeContour = true;\n                }\n            }\n            if (addNewPoint) {\n                data.handles.points.push(worldPoint);\n            }\n            data.contour.closed = data.contour.closed || closeContour;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (data.contour.closed) {\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                this.moveAnnotation(annotation, worldPosDelta);\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n                changeType: ChangeTypes.Completed,\n                contourHoleProcessingEnabled,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {\n            if (changeType === ChangeTypes.Completed) {\n                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                this.triggerAnnotationModified(annotation, enabledElement, changeType);\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.spline.instance.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.addControlPointCallback = (evt, annotation) => {\n            const { data } = annotation;\n            const splineType = data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointAdditionDistance;\n            if (splineConfig.controlPointAdditionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { instance: spline } = data.spline;\n            const canvasPos = evt.detail.currentPoints.canvas;\n            const closestPointInfo = spline.getClosestPoint(canvasPos);\n            if (closestPointInfo.distance > maxDist) {\n                return;\n            }\n            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);\n            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n            annotation.invalidated = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.deleteControlPointCallback = (evt, annotation) => {\n            const splineType = annotation.data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointDeletionDistance;\n            if (splineConfig.controlPointDeletionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { canvas: canvasPos } = currentPoints;\n            const { instance: spline } = annotation.data.spline;\n            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);\n            if (!closestControlPoint) {\n                return;\n            }\n            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n        this.annotationCompletedBinded = this.annotationCompleted.bind(this);\n    }\n    annotationCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (!this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline ||\n            !this.isContourSegmentationTool()) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.removeListeners();\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { canvas: canvasPos } = currentPoints;\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        const annotation = this.createAnnotation(evt);\n        this.isDrawing = true;\n        this.addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n            lastCanvasPoint: canvasPos,\n            contourHoleProcessingEnabled,\n        };\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n        if (newAnnotation) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        super.cancelAnnotation(annotation);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { element } = viewport;\n        const annotation = renderContext.annotation;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const { points: controlPoints, activeHandleIndex } = handles;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;\n        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));\n        const { drawPreviewEnabled } = this.configuration.spline;\n        const splineType = annotation.data.spline.type;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = annotation.data.spline.instance;\n        const childAnnotations = getChildAnnotations(annotation);\n        const missingAnnotation = childAnnotations.findIndex((it) => !it);\n        if (missingAnnotation !== -1) {\n            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);\n        }\n        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));\n        splineAnnotationsGroup.forEach((annotation) => {\n            const spline = this._updateSplineInstance(element, annotation);\n            const splinePolylineCanvas = spline.getPolylinePoints();\n            this.updateContourPolyline(annotation, {\n                points: splinePolylineCanvas,\n                closed: data.contour.closed,\n                targetWindingDirection: ContourWindingDirection.Clockwise,\n            }, viewport, { updateWindingDirection: data.contour.closed });\n        });\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        let activeHandleCanvasCoords;\n        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n        }\n        if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                color,\n                lineWidth,\n                handleRadius: '3',\n            });\n        }\n        if (drawPreviewEnabled &&\n            spline.numControlPoints >= 1 &&\n            this.editData?.lastCanvasPoint &&\n            !spline.closed) {\n            const { lastCanvasPoint } = this.editData;\n            const { enableTwoPointPreview } = this.configuration.spline;\n            if (spline.numControlPoints === 1 && enableTwoPointPreview) {\n                const firstPoint = canvasCoordinates[0];\n                const previewPolylinePoints = [firstPoint, lastCanvasPoint];\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n            else if (spline.numControlPoints > 1) {\n                const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n        }\n        if (splineConfig.showControlPointsConnectors) {\n            const controlPointsConnectors = [...canvasCoordinates];\n            if (spline.closed) {\n                controlPointsConnectors.push(canvasCoordinates[0]);\n            }\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {\n                color: 'rgba(255, 255, 255, 0.5)',\n                lineWidth: 1,\n            });\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);\n            this.fireChangeOnUpdate = null;\n        }\n        annotation.invalidated = false;\n        return true;\n    }\n    createInterpolatedSplineControl(annotation) {\n        if (annotation.data.handles.points?.length) {\n            return;\n        }\n        const { polyline } = annotation.data.contour;\n        if (!polyline || !polyline.length) {\n            return;\n        }\n        annotation.data.handles.points = [];\n        const { points } = annotation.data.handles;\n        const increment = Math.max(10, Math.floor(polyline.length / 20));\n        for (let i = 0; i < polyline.length - increment; i += increment) {\n            points.push(polyline[i]);\n        }\n        points.push(polyline[polyline.length - 1]);\n    }\n    createAnnotation(evt) {\n        const contourAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const { type: splineType } = this.configuration.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        const createSpline = () => ({\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        });\n        let onInterpolationComplete;\n        if (this.configuration.interpolation?.enabled) {\n            onInterpolationComplete = (annotation) => {\n                annotation.data.spline ||= createSpline();\n                this.createInterpolatedSplineControl(annotation);\n            };\n        }\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n                spline: createSpline(),\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n    }\n    _deleteControlPointByIndex(element, annotation, controlPointIndex) {\n        const enabledElement = getEnabledElement(element);\n        const { points: controlPoints } = annotation.data.handles;\n        if (controlPoints.length === 3) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        else {\n            controlPoints.splice(controlPointIndex, 1);\n        }\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        annotation.invalidated = true;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    _isSplineROIAnnotation(annotation) {\n        return !!annotation.data?.spline;\n    }\n    _getSplineConfig(type) {\n        const { configuration: config } = this;\n        const splineConfigs = config.spline.configuration;\n        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n    }\n    _updateSplineInstance(element, annotation) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { data } = annotation;\n        const { type: splineType, instance: spline } = annotation.data.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const worldPoints = data.handles.points;\n        const canvasPoints = worldPoints.map(worldToCanvas);\n        const resolution = splineConfig.resolution !== undefined\n            ? parseInt(splineConfig.resolution)\n            : undefined;\n        const scale = splineConfig.scale !== undefined\n            ? parseFloat(splineConfig.scale)\n            : undefined;\n        spline.setControlPoints(canvasPoints);\n        spline.closed = !!data.contour.closed;\n        if (!spline.fixedResolution &&\n            resolution !== undefined &&\n            spline.resolution !== resolution) {\n            spline.resolution = resolution;\n            annotation.invalidated = true;\n        }\n        if (spline instanceof CardinalSpline &&\n            !spline.fixedScale &&\n            scale !== undefined &&\n            spline.scale !== scale) {\n            spline.scale = scale;\n            annotation.invalidated = true;\n        }\n        return spline;\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (points.length < SPLINE_MIN_POINTS) {\n            console.warn('Spline requires at least 3 control points');\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);\n        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;\n        const splineConfig = instance._getSplineConfig(splineType);\n        const SplineClass = splineConfig.Class;\n        const splineInstance = new SplineClass();\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n                label: '',\n                cachedStats: {},\n                spline: {\n                    type: splineType,\n                    instance: splineInstance,\n                },\n                contour: {\n                    closed: true,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${utilities.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\nexport default SplineROITool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandle as drawHandleSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { lineSegment } from '../../utilities/math';\nconst { transformWorldToIndex } = csUtils;\nclass UltrasoundDirectionalTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundDirectionalTool'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            displayBothAxesDistances: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.startedDrawing) {\n                return;\n            }\n            this.startedDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');\n            }\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.startedDrawing && data.handles.points.length === 1) {\n                this.editData.handleIndex = 1;\n                return;\n            }\n            this.startedDrawing = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.startedDrawing = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].xValues == null) {\n                    data.cachedStats[targetId] = {\n                        xValues: [0, 0],\n                        yValues: [0, 0],\n                        isHorizontal: false,\n                        units: [''],\n                        isUnitless: false,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let handleGroupUID = '0';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {\n                    color,\n                }, 0);\n                renderStatus = true;\n                if (canvasCoordinates.length !== 2) {\n                    return renderStatus;\n                }\n                handleGroupUID = '1';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {\n                    color,\n                }, 1);\n                const isUnitless = data.cachedStats[targetId].isUnitless;\n                if (!isUnitless) {\n                    const canvasPoint1 = canvasCoordinates[0];\n                    const canvasPoint2 = canvasCoordinates[1];\n                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                    const isHorizontal = data.cachedStats[targetId].isHorizontal;\n                    let projectedPointCanvas = [0, 0];\n                    if (isHorizontal) {\n                        projectedPointCanvas = [\n                            canvasPoint1[0] + canvasDeltaX,\n                            canvasPoint1[1],\n                        ];\n                    }\n                    else {\n                        projectedPointCanvas = [\n                            canvasPoint1[0],\n                            canvasPoint1[1] + canvasDeltaY,\n                        ];\n                    }\n                    let dataId = `${annotationUID}-line-1`;\n                    let lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                    dataId = `${annotationUID}-line-2`;\n                    lineUID = '2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        lineDash: [1, 1],\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                else {\n                    const dataId = `${annotationUID}-line-1`;\n                    const lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {\n        return;\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        this.editData = {\n            handleIndex,\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 2) {\n            return;\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData } = image;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n            const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n            const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n            let xValues, yValues, units, isHorizontal;\n            let isUnitless = false;\n            if (units1[0] !== units2[0] ||\n                units1[1] !== units2[1] ||\n                (units1[0] === 'raw' && units2[0] === 'raw')) {\n                const value = distanceToPoint(worldPos1, worldPos2);\n                xValues = [value, 0];\n                yValues = [value, 0];\n                units = ['px'];\n                isUnitless = true;\n            }\n            else {\n                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n                xValues = [values1[0], values2[0]];\n                yValues = [values1[1], values2[1]];\n                units = [units1[0], units1[1]];\n            }\n            cachedStats[targetId] = {\n                xValues,\n                yValues,\n                isHorizontal,\n                units,\n                isUnitless,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId, configuration) {\n    const cachedStats = data.cachedStats[targetId];\n    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n    if (isUnitless) {\n        return [`${csUtils.roundNumber(xValues[0])} px`];\n    }\n    if (configuration.displayBothAxesDistances) {\n        const dist1 = Math.abs(xValues[1] - xValues[0]);\n        const dist2 = Math.abs(yValues[1] - yValues[0]);\n        return [\n            `${csUtils.roundNumber(dist1)} ${units[0]}`,\n            `${csUtils.roundNumber(dist2)} ${units[1]}`,\n        ];\n    }\n    if (isHorizontal) {\n        const dist = Math.abs(xValues[1] - xValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[0]}`];\n    }\n    else {\n        const dist = Math.abs(yValues[1] - yValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[1]}`];\n    }\n}\nexport default UltrasoundDirectionalTool;\n","import { Events, ChangeTypes } from '../../../enums';\nimport { getEnabledElement, utilities, metaData, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawFan as drawFanSvg, } from '../../../drawingSvg';\nimport { state } from '../../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { angleFromCenter, calculateInnerFanPercentage, clipInterval, intervalFromPoints, mergeIntervals, subtractIntervals, } from '../../../utilities/math/fan/fanUtils';\nimport { calculateFanGeometry } from './utils/fanExtraction';\nconst { transformIndexToWorld } = utilities;\nclass UltrasoundPleuraBLineTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundPleuraBLineTool'; }\n    static { this.USPleuraBLineAnnotationType = {\n        BLINE: 'bLine',\n        PLEURA: 'pleura',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            center: null,\n            innerRadius: null,\n            outerRadius: null,\n            startAngle: null,\n            endAngle: null,\n            bLineColor: 'rgb(60, 255, 60)',\n            pleuraColor: 'rgb(0, 4, 255)',\n            drawDepthGuide: true,\n            depth_ratio: 0.5,\n            depthGuideColor: 'rgb(0, 255, 255)',\n            depthGuideThickness: 4,\n            depthGuideDashLength: 20,\n            depthGuideDashGap: 16,\n            depthGuideOpacity: 0.2,\n            fanOpacity: 0.1,\n            showFanAnnotations: true,\n            updatePercentageCallback: null,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.pleuraAnnotations = [];\n        this.bLineAnnotations = [];\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    annotationType: this.getActiveAnnotationType(),\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element) || {};\n            if (!viewport) {\n                return;\n            }\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                const allPointsInsideShape = points.every((point) => {\n                    const newPoint = [\n                        point[0] + worldPosDelta[0],\n                        point[1] + worldPosDelta[1],\n                        point[2] + worldPosDelta[2],\n                    ];\n                    return this.isInsideFanShape(viewport, newPoint);\n                });\n                if (allPointsInsideShape) {\n                    points.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                    annotation.invalidated = true;\n                }\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                if (this.isInsideFanShape(viewport, worldPos)) {\n                    data.handles.points[handleIndex] = [...worldPos];\n                    annotation.invalidated = true;\n                }\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            if (!this.getFanShapeGeometryParameters(viewport)) {\n                return;\n            }\n            const { imageData } = viewport.getImageData() || {};\n            if (!imageData) {\n                return renderStatus;\n            }\n            if (this.configuration.drawDepthGuide) {\n                this.drawDepthGuide(svgDrawingHelper, viewport);\n            }\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const fanCenter = viewport.worldToCanvas(transformIndexToWorld(imageData, this.configuration.center));\n            const indexToCanvasRatio = this.getIndexToCanvasRatio(viewport);\n            const innerRadius = this.configuration.innerRadius * indexToCanvasRatio;\n            const outerRadius = this.configuration.outerRadius * indexToCanvasRatio;\n            const currentImageId = viewport.getCurrentImageId();\n            const unMergedPleuraIntervals = annotations\n                .filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId)\n                .map((annotation) => {\n                const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n                const interval = intervalFromPoints(fanCenter, canvasCoordinates);\n                return interval;\n            });\n            const mergedPleuraIntervals = mergeIntervals(unMergedPleuraIntervals);\n            const pleuraIntervalsDisplayed = [];\n            const bLineIntervalsDisplayed = [];\n            const drawAnnotation = (annotation) => {\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    return;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color: this.getColorForLineType(annotation),\n                        fill: this.getColorForLineType(annotation),\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color: this.getColorForLineType(annotation),\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                if (this.configuration.showFanAnnotations) {\n                    const lineInterval = intervalFromPoints(fanCenter, canvasCoordinates);\n                    let fanNumber = 0;\n                    if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                        const uncoveredIntervals = subtractIntervals(bLineIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval) => {\n                            const clippedIntervals = clipInterval(interval, mergedPleuraIntervals);\n                            clippedIntervals.forEach((clippedInterval) => {\n                                fanNumber++;\n                                const fanIndex = fanNumber;\n                                const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                                const fanUID = `2-${fanIndex}`;\n                                drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, clippedInterval[0], clippedInterval[1], {\n                                    color: 'transparent',\n                                    fill: this.getColorForLineType(annotation),\n                                    fillOpacity: this.configuration.fanOpacity,\n                                    width: lineWidth,\n                                    lineDash,\n                                    shadow,\n                                }, fanDataId, 10);\n                                bLineIntervalsDisplayed.push(clippedInterval);\n                            });\n                        });\n                    }\n                    else if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                        const uncoveredIntervals = subtractIntervals(pleuraIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval, index) => {\n                            fanNumber++;\n                            const fanIndex = fanNumber;\n                            const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                            const fanUID = `2-${fanIndex}`;\n                            drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, interval[0], interval[1], {\n                                color: 'transparent',\n                                fill: this.getColorForLineType(annotation),\n                                fillOpacity: this.configuration.fanOpacity,\n                                width: lineWidth,\n                                lineDash,\n                                shadow,\n                            }, fanDataId, 5);\n                            pleuraIntervalsDisplayed.push(interval);\n                        });\n                    }\n                }\n            };\n            const pleuraAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId);\n            pleuraAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            const bLineAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n                annotation.metadata.referencedImageId === currentImageId);\n            bLineAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            renderStatus = true;\n            if (this.configuration.updatePercentageCallback && viewport) {\n                this.configuration.updatePercentageCallback(this.calculateBLinePleuraPercentage(viewport));\n            }\n            return renderStatus;\n        };\n        this.activeAnnotationType =\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE;\n    }\n    static filterAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return [];\n        }\n        const filteredAnnotations = annotations.filter((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            return filterFunction(currentImageId);\n        });\n        return filteredAnnotations;\n    }\n    static countAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        const { viewport } = getEnabledElement(element);\n        const imageIds = viewport.getImageIds();\n        const getImageIdIndex = (imageId) => {\n            const index = imageIds.findIndex((id) => id === imageId);\n            if (index === -1) {\n                return 0;\n            }\n            return index;\n        };\n        if (!annotations?.length) {\n            return;\n        }\n        const annotationMapping = new Map();\n        annotations.forEach((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            if (!filterFunction(currentImageId)) {\n                return;\n            }\n            const { annotationType } = annotation.data;\n            let counts;\n            if (annotationMapping.has(currentImageId)) {\n                counts = annotationMapping.get(currentImageId);\n            }\n            else {\n                counts = {\n                    frame: getImageIdIndex(currentImageId),\n                    bLine: 0,\n                    pleura: 0,\n                };\n            }\n            if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                counts.pleura++;\n            }\n            else if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                counts.bLine++;\n            }\n            annotationMapping.set(currentImageId, counts);\n        });\n        return annotationMapping;\n    }\n    static deleteAnnotations(element, filterFunction = () => false) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return;\n        }\n        annotations.forEach((annotation) => {\n            if (!filterFunction(annotation.metadata.referencedImageId)) {\n                return;\n            }\n            removeAnnotation(annotation.annotationUID);\n        });\n    }\n    setActiveAnnotationType(type) {\n        this.activeAnnotationType = type;\n    }\n    getActiveAnnotationType() {\n        return this.activeAnnotationType;\n    }\n    deleteLastAnnotationType(element, type) {\n        let annotationList;\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA);\n        }\n        else if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE);\n        }\n        if (annotationList?.length > 0) {\n            const annotation = annotationList.pop();\n            removeAnnotation(annotation.annotationUID);\n        }\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(UltrasoundPleuraBLineTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    isInsideFanShape(viewport, point) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return false;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (imageData) {\n            const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            const angle = angleFromCenter(fanCenter, canvasCoordinates);\n            return (angle >= this.configuration.startAngle &&\n                angle <= this.configuration.endAngle);\n        }\n    }\n    updateFanGeometryConfiguration(fanGeometry) {\n        if (!fanGeometry) {\n            return;\n        }\n        if (this.isFanShapeGeometryParametersValid(fanGeometry)) {\n            this.configuration.center = [\n                fanGeometry.center[0],\n                fanGeometry.center[1],\n                0,\n            ];\n        }\n        this.configuration.innerRadius = fanGeometry.innerRadius;\n        this.configuration.outerRadius = fanGeometry.outerRadius;\n        this.configuration.startAngle = fanGeometry.startAngle;\n        this.configuration.endAngle = fanGeometry.endAngle;\n    }\n    deriveFanGeometryFromViewport(viewport) {\n        const imageId = viewport.getCurrentImageId();\n        const { fanGeometry } = calculateFanGeometry(imageId) || {};\n        if (fanGeometry) {\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n    }\n    isFanShapeGeometryParametersValid(fanGeometry) {\n        if (!fanGeometry) {\n            fanGeometry = this.configuration;\n        }\n        return (fanGeometry?.center &&\n            fanGeometry?.innerRadius > 0 &&\n            fanGeometry?.outerRadius &&\n            fanGeometry?.startAngle > 0 &&\n            fanGeometry?.startAngle < 360 &&\n            fanGeometry?.endAngle > 0 &&\n            fanGeometry?.endAngle < 360);\n    }\n    getFanShapeGeometryParameters(viewport) {\n        if (this.isFanShapeGeometryParametersValid()) {\n            return true;\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            const imageId = viewport.getCurrentImageId();\n            const fanGeometry = metaData.get('ultrasoundFanShapeGeometry', imageId);\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            this.deriveFanGeometryFromViewport(viewport);\n        }\n        return this.isFanShapeGeometryParametersValid();\n    }\n    calculateBLinePleuraPercentage(viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const { element } = viewport;\n        const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n        const currentImageId = viewport.getCurrentImageId();\n        const annotations = getAnnotations(this.getToolName(), element) || [];\n        const pleuraIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        const bLineIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        return calculateInnerFanPercentage(fanCenter, pleuraIntervals, bLineIntervals);\n    }\n    getColorForLineType(annotation) {\n        const { annotationType } = annotation.data;\n        const { bLineColor, pleuraColor } = this.configuration;\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            return bLineColor;\n        }\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            return pleuraColor;\n        }\n        return bLineColor;\n    }\n    getIndexToCanvasRatio(viewport) {\n        const { imageData } = viewport.getImageData() || {};\n        const v1 = viewport.worldToCanvas(imageData.indexToWorld([1, 0, 0]));\n        const v2 = viewport.worldToCanvas(imageData.indexToWorld([2, 0, 0]));\n        const diffVector = [v2[0] - v1[0], v2[1] - v1[1]];\n        const vectorSize = Math.sqrt(diffVector[0] * diffVector[0] + diffVector[1] * diffVector[1]);\n        return vectorSize;\n    }\n    drawDepthGuide(svgDrawingHelper, viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const radToDegree = (rad) => (rad * 180) / Math.PI;\n        const degreeToRad = (degree) => (degree * Math.PI) / 180;\n        const indexToCanvas = (point) => {\n            return viewport.worldToCanvas(transformIndexToWorld(imageData, point));\n        };\n        const depth_radius = this.configuration.innerRadius +\n            this.configuration.depth_ratio *\n                (this.configuration.outerRadius - this.configuration.innerRadius);\n        const theta_start = this.configuration.startAngle;\n        const theta_end = this.configuration.endAngle;\n        const theta_range = theta_end - theta_start;\n        const arc_length = degreeToRad(theta_range) * depth_radius;\n        let num_dashes = Math.round(arc_length /\n            (this.configuration.depthGuideDashLength +\n                this.configuration.depthGuideDashGap));\n        if (num_dashes <= 0) {\n            num_dashes = Math.max(15, Math.round(theta_range / 5));\n        }\n        const theta_step = theta_range / num_dashes;\n        for (let i = 0; i < num_dashes; i++) {\n            const theta1 = degreeToRad(theta_start + i * theta_step);\n            const theta2 = degreeToRad(theta_start +\n                i * theta_step +\n                radToDegree(this.configuration.depthGuideDashLength) / depth_radius);\n            const start_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta1),\n                this.configuration.center[1] + depth_radius * Math.sin(theta1),\n                0,\n            ];\n            const end_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta2),\n                this.configuration.center[1] + depth_radius * Math.sin(theta2),\n                0,\n            ];\n            drawLineSvg(svgDrawingHelper, viewport.id, `depthGuide-${i}`, indexToCanvas(start_point), indexToCanvas(end_point), {\n                color: this.configuration.depthGuideColor,\n                lineWidth: this.configuration.depthGuideThickness,\n                strokeOpacity: this.configuration.depthGuideOpacity,\n            });\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (utilities.indexWithinDimensions(index1, dimensions) &&\n            utilities.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    return [''];\n}\nexport default UltrasoundPleuraBLineTool;\n","export function pickPoints(hull, slack = 7) {\n    if (!hull.length) {\n        throw new Error('Convex hull is empty');\n    }\n    const n = hull.length;\n    const next = (i) => (i + 1) % n;\n    const walk = (from, to) => {\n        const idx = [];\n        for (let i = from;; i = next(i)) {\n            idx.push(i);\n            if (i === to) {\n                break;\n            }\n        }\n        return idx;\n    };\n    let i2 = 0, i3 = 0;\n    for (let i = 1; i < n; i++) {\n        if (hull[i][0] < hull[i2][0]) {\n            i2 = i;\n        }\n        if (hull[i][0] > hull[i3][0]) {\n            i3 = i;\n        }\n    }\n    const P2 = hull[i2];\n    const P3 = hull[i3];\n    const pathA = walk(i2, i3);\n    const pathB = walk(i3, i2);\n    const globalYmin = Math.min(...hull.map((p) => p[1]));\n    const upperPath = pathA.some((i) => hull[i][1] === globalYmin)\n        ? pathA\n        : pathB;\n    const topY = Math.min(...upperPath.map((i) => hull[i][1]));\n    let arcPts = upperPath\n        .map((i) => hull[i])\n        .filter((p) => Math.abs(p[1] - topY) <= slack);\n    if (arcPts.length < 2) {\n        arcPts = upperPath\n            .map((i) => hull[i])\n            .sort((a, b) => a[1] - b[1])\n            .slice(0, 2);\n    }\n    const P1 = arcPts.reduce((best, p) => (p[0] < best[0] ? p : best), arcPts[0]);\n    const P4 = arcPts.reduce((best, p) => (p[0] > best[0] ? p : best), arcPts[0]);\n    return { P1, P2, P3, P4 };\n}\nexport function computeEdgeBuffer(buffer, width, height) {\n    const total = width * height;\n    const channels = buffer.length / total;\n    if (![1, 3, 4].includes(channels)) {\n        throw new Error('Buffer must be 1,3 or 4 channels per pixel');\n    }\n    const gray = new Float32Array(total);\n    for (let i = 0; i < total; i++) {\n        if (channels === 1) {\n            gray[i] = buffer[i];\n        }\n        else {\n            const base = i * channels;\n            const r = buffer[base];\n            const g = buffer[base + 1];\n            const b = buffer[base + 2];\n            gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;\n        }\n    }\n    const edgeBuf = new Float32Array(total);\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            const idx = y * width + x;\n            const i00 = idx - width - 1;\n            const i01 = idx - width;\n            const i02 = idx - width + 1;\n            const i10 = idx - 1;\n            const i11 = idx;\n            const i12 = idx + 1;\n            const i20 = idx + width - 1;\n            const i21 = idx + width;\n            const i22 = idx + width + 1;\n            const gx = -gray[i00] +\n                gray[i02] +\n                -2 * gray[i10] +\n                2 * gray[i12] +\n                -gray[i20] +\n                gray[i22];\n            const gy = gray[i00] +\n                2 * gray[i01] +\n                gray[i02] -\n                gray[i20] -\n                2 * gray[i21] -\n                gray[i22];\n            edgeBuf[idx] = Math.hypot(gx, gy);\n        }\n    }\n    return edgeBuf;\n}\nexport function refineCornersDirectional(edgeBuf, width, height, rough, contour, opts = {}) {\n    const { maxDist = 15, slack = 2 } = opts;\n    const directions = {\n        P1: { dx: -1, dy: -1 },\n        P2: { dx: -1, dy: +1 },\n        P3: { dx: +1, dy: +1 },\n        P4: { dx: +1, dy: -1 },\n    };\n    function snapQuadrant(pt, { dx, dy }, threshold = 5) {\n        const xmin = dx < 0 ? pt[0] - maxDist : pt[0] - slack;\n        const xmax = dx < 0 ? pt[0] + slack : pt[0] + maxDist;\n        const ymin = dy < 0 ? pt[1] - maxDist : pt[1] - slack;\n        const ymax = dy < 0 ? pt[1] + slack : pt[1] + maxDist;\n        let best = pt;\n        for (const [cx, cy] of contour) {\n            if (cx < xmin || cx > xmax || cy < ymin || cy > ymax) {\n                continue;\n            }\n            const xi = Math.round(cx);\n            const yi = Math.round(cy);\n            if (xi < 0 || xi >= width || yi < 0 || yi >= height) {\n                continue;\n            }\n            const xAlign = (xi - best[0]) * dx;\n            const yAlign = (yi - best[0]) * dy;\n            const v = edgeBuf[yi * width + xi];\n            if (v > threshold && (xAlign > 0 || yAlign > 0)) {\n                best = [cx, cy];\n            }\n        }\n        return best;\n    }\n    return {\n        P1: snapQuadrant(rough.P1, directions.P1),\n        P2: snapQuadrant(rough.P2, directions.P2),\n        P3: snapQuadrant(rough.P3, directions.P3),\n        P4: snapQuadrant(rough.P4, directions.P4),\n    };\n}\nexport function calculateFanShapeCorners(imageBuffer, width, height, hull, roughContour) {\n    const rough = pickPoints(hull);\n    const refined = refineCornersDirectional(imageBuffer, width, height, rough, roughContour, {\n        maxDist: 20,\n        step: 0.5,\n    });\n    return refined;\n}\n","import { intersectLine } from '../../../../utilities/math/line';\nfunction angleRad(center, p) {\n    return Math.atan2(p[1] - center[1], p[0] - center[0]);\n}\nexport function deriveFanGeometry(params) {\n    const { P1, P2, P3, P4 } = params;\n    const centerResult = intersectLine(P1, P2, P4, P3, true);\n    if (!centerResult) {\n        throw new Error('Fan edges appear parallel  no apex found');\n    }\n    const center = centerResult;\n    let startAngle = angleRad(center, P1) * (180 / Math.PI);\n    let endAngle = angleRad(center, P4) * (180 / Math.PI);\n    if (endAngle <= startAngle) {\n        const tempAngle = startAngle;\n        startAngle = endAngle;\n        endAngle = tempAngle;\n    }\n    const d1 = Math.hypot(P1[0] - center[0], P1[1] - center[1]);\n    const d4 = Math.hypot(P4[0] - center[0], P4[1] - center[1]);\n    const d2 = Math.hypot(P2[0] - center[0], P2[1] - center[1]);\n    const d3 = Math.hypot(P3[0] - center[0], P3[1] - center[1]);\n    const innerRadius = Math.min(d1, d4);\n    const outerRadius = Math.max(d2, d3);\n    return {\n        center,\n        startAngle,\n        endAngle,\n        innerRadius,\n        outerRadius,\n    };\n}\n","import { cache } from '@cornerstonejs/core';\nimport { segmentLargestUSOutlineFromBuffer } from './segmentLargestUSOutlineFromBuffer';\nimport { generateConvexHullFromContour } from './generateConvexHullFromContour';\nimport { calculateFanShapeCorners } from './calculateFanShapeCorners';\nimport { deriveFanGeometry } from './deriveFanGeometry';\nexport function exportContourJpeg(pixelData, width, height, contour, opts = {}) {\n    const { strokeStyle = '#f00', lineWidth = 2, quality = 0.92 } = opts;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const totalPixels = width * height;\n    const channels = pixelData.length / totalPixels;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < totalPixels; i++) {\n        const baseIn = i * channels;\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[baseIn];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    if (contour.length > 0) {\n        ctx.strokeStyle = strokeStyle;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        ctx.moveTo(contour[0][0] + 0.5, contour[0][1] + 0.5);\n        for (let i = 1; i < contour.length; i++) {\n            ctx.lineTo(contour[i][0] + 0.5, contour[i][1] + 0.5);\n        }\n        ctx.closePath();\n        ctx.stroke();\n    }\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function getPixelData(imageId) {\n    const image = cache.getImage(imageId);\n    if (!image) {\n        return;\n    }\n    const width = image.width;\n    const height = image.height;\n    const pixelData = image.getPixelData();\n    return {\n        pixelData,\n        width,\n        height,\n    };\n}\nexport default function saveBinaryData(url, filename) {\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.click();\n    a.remove();\n}\nfunction exportFanJpeg(pixelData, width, height, fan, opts = {}) {\n    const { center, startAngle: startAngleInDegrees, endAngle: endAngleInDegrees, innerRadius, outerRadius, } = fan;\n    const { strokeStyle = '#0ff', lineWidth = 2, quality = 0.92 } = opts;\n    const startAngle = (startAngleInDegrees * Math.PI) / 180;\n    const endAngle = (endAngleInDegrees * Math.PI) / 180;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const total = width * height;\n    const channels = pixelData.length / total;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < total; i++) {\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[i];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            const baseIn = i * channels;\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    ctx.beginPath();\n    for (let a = startAngle; a <= endAngle; a += 0.01) {\n        const x = center[0] + innerRadius * Math.cos(a);\n        const y = center[1] + innerRadius * Math.sin(a);\n        if (a === startAngle) {\n            ctx.moveTo(x, y);\n        }\n        else {\n            ctx.lineTo(x, y);\n        }\n    }\n    for (let a = endAngle; a >= startAngle; a -= 0.01) {\n        const x = center[0] + outerRadius * Math.cos(a);\n        const y = center[1] + outerRadius * Math.sin(a);\n        ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function downloadFanJpeg(imageId, contourType = 5) {\n    const { contour, simplified, hull, refined, fanGeometry } = calculateFanGeometry(imageId);\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    let jpegDataUrl;\n    if (contourType === 1) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, contour);\n    }\n    else if (contourType === 2) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, simplified);\n    }\n    else if (contourType === 3) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, hull);\n    }\n    else if (contourType === 4) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, [\n            refined.P1,\n            refined.P2,\n            refined.P3,\n            refined.P4,\n        ]);\n    }\n    else {\n        jpegDataUrl = exportFanJpeg(pixelData, width, height, fanGeometry, {\n            strokeStyle: '#f00',\n            lineWidth: 3,\n            quality: 0.95,\n        });\n    }\n    saveBinaryData(jpegDataUrl, 'contour.jpg');\n}\nexport function calculateFanGeometry(imageId) {\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    const contour = segmentLargestUSOutlineFromBuffer(pixelData, width, height);\n    const { simplified, hull } = generateConvexHullFromContour(contour);\n    const refined = calculateFanShapeCorners(pixelData, width, height, hull, simplified);\n    const fanGeometry = deriveFanGeometry({\n        P1: refined.P1,\n        P2: refined.P2,\n        P3: refined.P3,\n        P4: refined.P4,\n    });\n    return { contour, simplified, hull, refined, fanGeometry };\n}\n","import { utilities } from '@cornerstonejs/tools';\nexport function generateConvexHullFromContour(contour) {\n    const simplified = utilities.math.polyline.decimate(contour, 2);\n    const hull = utilities.math.polyline.convexHull(simplified);\n    return { simplified, hull };\n}\n","import { floodFill } from '../../../../utilities/segmentation';\nexport function segmentLargestUSOutlineFromBuffer(buffer, width, height) {\n    const totalPixels = width * height;\n    const channelCount = buffer.length / totalPixels;\n    if (![1, 3, 4].includes(channelCount)) {\n        throw new Error('Buffer must be 1, 3, or 4 channels per pixel');\n    }\n    const mask = Array.from({ length: height }, () => new Array(width).fill(false));\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const pixelIndex = y * width + x;\n            const base = pixelIndex * channelCount;\n            let isForeground = false;\n            for (let c = 0; c < Math.min(3, channelCount); c++) {\n                if (buffer[base + c] > 0) {\n                    isForeground = true;\n                    break;\n                }\n            }\n            mask[y][x] = isForeground;\n        }\n    }\n    const labels = Array.from({ length: height }, () => new Array(width).fill(0));\n    let currentLabel = 0;\n    const regionSizes = {};\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (mask[y][x] && labels[y][x] === 0) {\n                currentLabel++;\n                const getter = (px, py) => {\n                    if (px < 0 || px >= width || py < 0 || py >= height) {\n                        return false;\n                    }\n                    return mask[py][px] && labels[py][px] === 0;\n                };\n                let pixelCount = 0;\n                const options = {\n                    onFlood: (px, py) => {\n                        labels[py][px] = currentLabel;\n                        pixelCount++;\n                    },\n                    diagonals: false,\n                };\n                floodFill(getter, [x, y], options);\n                regionSizes[currentLabel] = pixelCount;\n            }\n        }\n    }\n    if (currentLabel === 0) {\n        return [];\n    }\n    const largestLabel = Object.keys(regionSizes).reduce((a, b) => regionSizes[a] > regionSizes[b] ? a : b);\n    function isBorder(x, y) {\n        if (labels[y][x] !== +largestLabel) {\n            return false;\n        }\n        for (const [dx, dy] of [\n            [1, 0],\n            [-1, 0],\n            [0, 1],\n            [0, -1],\n        ]) {\n            const nx = x + dx, ny = y + dy;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                labels[ny][nx] !== +largestLabel) {\n                return true;\n            }\n        }\n        return false;\n    }\n    let start = null;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (isBorder(x, y)) {\n                start = [x, y];\n                break outer;\n            }\n        }\n    }\n    if (!start) {\n        return [];\n    }\n    const dirs = [\n        [1, 0],\n        [1, 1],\n        [0, 1],\n        [-1, 1],\n        [-1, 0],\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n    ];\n    const contour = [];\n    let current = start;\n    let prev = [start[0] - 1, start[1]];\n    do {\n        contour.push([current[0], current[1]]);\n        const dx0 = prev[0] - current[0], dy0 = prev[1] - current[1];\n        let startDir = dirs.findIndex((d) => d[0] === dx0 && d[1] === dy0);\n        if (startDir < 0) {\n            startDir = 0;\n        }\n        let nextPt = null;\n        for (let k = 1; k <= 8; k++) {\n            const [dx, dy] = dirs[(startDir + k) % 8];\n            const nx = current[0] + dx, ny = current[1] + dy;\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height && isBorder(nx, ny)) {\n                nextPt = [nx, ny];\n                const [bdx, bdy] = dirs[(startDir + k - 1 + 8) % 8];\n                prev = [current[0] + bdx, current[1] + bdy];\n                break;\n            }\n        }\n        if (!nextPt) {\n            break;\n        }\n        current = nextPt;\n    } while (current[0] !== start[0] || current[1] !== start[1]);\n    return contour;\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, cache, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { drawHandles as drawHandlesSvg, drawRedactionRect as drawRedactionRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nclass VideoRedactionTool extends AnnotationTool {\n    static { this.toolName = 'VideoRedaction'; }\n    constructor(toolConfiguration = {}) {\n        super(toolConfiguration, {\n            supportedInteractionTypes: ['Mouse', 'Touch'],\n            configuration: { shadow: true, preventHandleOutsideImage: false },\n        });\n        this.addNewAnnotation = (evt) => {\n            const eventData = evt.detail;\n            const { currentPoints, element } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            return annotation;\n        };\n        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n                const near = vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;\n                if (near === true) {\n                    data.handles.activeHandleIndex = i;\n                    return point;\n                }\n            }\n            data.handles.activeHandleIndex = null;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.active = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventData;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                data.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventData;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                data.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                const data = annotation.data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return;\n                }\n                let activeHandleCanvasCoords;\n                if (!this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRedactionRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color: 'black',\n                    lineDash,\n                    lineWidth,\n                });\n            }\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetUIDs = Object.keys(cachedStats);\n            for (let i = 0; i < targetUIDs.length; i++) {\n                const targetUID = targetUIDs[i];\n                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);\n                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;\n                const worldPos1Index = vec3.fromValues(0, 0, 0);\n                const worldPos2Index = vec3.fromValues(0, 0, 0);\n                imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = worldWidth * worldHeight;\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportUID,\n                    renderingEngineUID,\n                    sceneUID: sceneUID,\n                    changeType: ChangeTypes.StatsUpdated,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._getTargetVolumeUID = (scene) => {\n            if (this.configuration.volumeUID) {\n                return this.configuration.volumeUID;\n            }\n            const volumeActors = scene.getVolumeActors();\n            if (!volumeActors && !volumeActors.length) {\n                return;\n            }\n            return volumeActors[0].uid;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportUIDsToRender } = this.editData;\n        const { data } = annotation;\n        data.active = false;\n        data.handles.activeHandleIndex = null;\n        triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        this.editData = null;\n        return annotation.metadata.annotationUID;\n    }\n    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n        let imageVolume, viewport;\n        if (targetUID.startsWith('stackTarget')) {\n            const coloneIndex = targetUID.indexOf(':');\n            const viewportUID = targetUID.substring(coloneIndex + 1);\n            const viewport = renderingEngine.getViewport(viewportUID);\n            imageVolume = viewport.getImageData();\n        }\n        else {\n            imageVolume = cache.getVolume(targetUID);\n        }\n        return { imageVolume, viewport };\n    }\n    _getTargetStackUID(viewport) {\n        return `stackTarget:${viewport.uid}`;\n    }\n}\nexport default VideoRedactionTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nconst ISLAND_PIXEL_RANGE = [1000, 1900];\nconst { transformWorldToIndex, transformIndexToWorld } = csUtils;\nclass WholeBodySegmentTool extends GrowCutBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positivePixelRange: POSITIVE_PIXEL_RANGE,\n            negativePixelRange: NEGATIVE_PIXEL_RANGE,\n            islandRemoval: {\n                enabled: true,\n                islandPixelRange: ISLAND_PIXEL_RANGE,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);\n            this.growCutData.horizontalLines[1] = linePoints;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            await this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);\n        await super.preMouseDownCallback(evt);\n        this.growCutData.horizontalLines = [linePoints, linePoints];\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { segmentation: segmentationData, horizontalLines } = this.growCutData;\n        if (horizontalLines.length !== 2) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentationId, segmentIndex } = segmentationData;\n        const [line1, line2] = horizontalLines;\n        const [worldLine1P1, worldLine1P2] = line1;\n        const [worldLine2P1, worldLine2P2] = line2;\n        const canvasPoints = [\n            worldLine1P1,\n            worldLine1P2,\n            worldLine2P2,\n            worldLine2P1,\n        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));\n        const annotationUID = 'growCutRect';\n        const squareGroupUID = '0';\n        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({\n            segmentationId,\n            segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawPolylineSvg(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {\n            color,\n            fillColor,\n            fillOpacity,\n            lineWidth,\n            lineDash,\n            closePath: true,\n        });\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const [line1, line2] = horizontalLines;\n        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);\n        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);\n        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);\n        const boundingBoxInfo = {\n            boundingBox: {\n                ijkTopLeft,\n                ijkBottomRight,\n            },\n        };\n        const config = this.configuration;\n        const options = {\n            positiveSeedValue: segmentIndex,\n            negativeSeedValue: 255,\n            negativePixelRange: config.negativePixelRange,\n            positivePixelRange: config.positivePixelRange,\n        };\n        return growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);\n    }\n    getRemoveIslandData() {\n        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const labelmapVolume = cache.getVolume(labelmapVolumeId);\n        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();\n        const { islandPixelRange } = this.configuration.islandRemoval;\n        const islandPointIndexes = [];\n        for (let i = 0, len = labelmapData.length; i < len; i++) {\n            if (labelmapData[i] !== segmentIndex) {\n                continue;\n            }\n            const pixelValue = referencedVolumeData[i];\n            if (pixelValue >= islandPixelRange[0] &&\n                pixelValue <= islandPixelRange[1]) {\n                islandPointIndexes.push(i);\n            }\n        }\n        return {\n            islandPointIndexes,\n        };\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);\n        const axis = vecDirection.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        if (axis === -1) {\n            throw new Error('Non-orthogonal direction vector');\n        }\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {\n        const { viewPlaneNormal } = viewport.getCamera();\n        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);\n    }\n    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {\n        const cuboidPoints = [];\n        const volume = this._getViewportVolume(viewport);\n        worldSquarePoints.forEach((worldSquarePoint) => {\n            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);\n            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));\n            cuboidPoints.push(...worldEdgePoints);\n        });\n        return cuboidPoints;\n    }\n    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {\n        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);\n        const topLeft = [...worldCuboidPoints[0]];\n        const bottomRight = [...worldCuboidPoints[0]];\n        worldCuboidPoints.forEach((worldPoint) => {\n            vec3.min(topLeft, topLeft, worldPoint);\n            vec3.max(bottomRight, bottomRight, worldPoint);\n        });\n        return { topLeft, bottomRight };\n    }\n    _getViewportVolume(viewport) {\n        if (!(viewport instanceof BaseVolumeViewport)) {\n            throw new Error('Viewport is not a BaseVolumeViewport');\n        }\n        const volumeId = viewport.getAllVolumeIds()[0];\n        return cache.getVolume(volumeId);\n    }\n    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);\n        const { viewUp, viewPlaneNormal } = viewport.getCamera();\n        const vecRow = vec3.cross(vec3.create(), viewUp, viewPlaneNormal);\n        const axis = vecRow.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);\n        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);\n        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);\n        return [worldPoint1, worldPoint2];\n    }\n}\nWholeBodySegmentTool.toolName = 'WholeBodySegment';\nexport default WholeBodySegmentTool;\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(mat4.create(), mat4.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);\nclass BSpline extends CubicSpline {\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { BSpline as default, BSpline };\n","import { CubicSpline } from './CubicSpline';\nclass CardinalSpline extends CubicSpline {\n    constructor(props) {\n        super(props);\n        this._scale = props?.scale ?? 0.5;\n        this._fixedScale = props?.fixedScale ?? false;\n    }\n    get scale() {\n        return this._scale;\n    }\n    set scale(scale) {\n        if (this._fixedScale || this._scale === scale) {\n            return;\n        }\n        this._scale = scale;\n        this.invalidated = true;\n    }\n    get fixedScale() {\n        return this._fixedScale;\n    }\n    getTransformMatrix() {\n        const { scale: s } = this;\n        const s2 = 2 * s;\n        return [\n            0, 1, 0, 0,\n            -s, 0, s, 0,\n            s2, s - 3, 3 - s2, -s,\n            -s, 2 - s, s - 2, s\n        ];\n    }\n}\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass CatmullRomSpline extends CardinalSpline {\n    constructor() {\n        super({ scale: 0.5, fixedScale: true });\n    }\n}\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { vec4 } from 'gl-matrix';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nconst MAX_U_ERROR = 1e-8;\nclass CubicSpline extends Spline {\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n        const endCurveSegIndex = closeSpline\n            ? previewNumCurveSegments\n            : previewNumCurveSegments - 1;\n        const transformMatrix = this.getTransformMatrix();\n        const controlPoints = [...this.controlPoints];\n        const curveSegments = [];\n        if (!closeSpline) {\n            controlPoints.push(controlPointPreview);\n        }\n        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);\n            curveSegments.push(curveSegment);\n        }\n        return curveSegments;\n    }\n    getSplineCurves() {\n        const numCurveSegments = this._getNumCurveSegments();\n        const curveSegments = new Array(numCurveSegments);\n        if (numCurveSegments <= 0) {\n            return [];\n        }\n        const transformMatrix = this.getTransformMatrix();\n        let previousCurveSegmentsLength = 0;\n        for (let i = 0; i < numCurveSegments; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix);\n            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n            curveSegments[i] = curveSegment;\n            previousCurveSegmentsLength += curveSegment.length;\n        }\n        return curveSegments;\n    }\n    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {\n        return closed\n            ? controlPoints.length\n            : Math.max(0, controlPoints.length - 1);\n    }\n    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const uInt = Math.floor(u);\n        let curveSegmentIndex = uInt % numCurveSegments;\n        const t = u - uInt;\n        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n        if (curveSegmentIndexOutOfBounds) {\n            if (this.closed) {\n                curveSegmentIndex =\n                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n            }\n            else {\n                return;\n            }\n        }\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const tt = t * t;\n        const ttt = tt * t;\n        const tValues = vec4.fromValues(1, t, tt, ttt);\n        const qValues = vec4.transformMat4(vec4.create(), tValues, transformMatrix);\n        return [\n            vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n            vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n        ];\n    }\n    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const p1Index = curveSegmentIndex;\n        const p0Index = p1Index - 1;\n        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n        const p3Index = p2Index + 1;\n        const p1 = controlPoints[p1Index];\n        const p2 = controlPoints[p2Index];\n        let p0;\n        let p3;\n        if (p0Index >= 0) {\n            p0 = controlPoints[p0Index];\n        }\n        else {\n            p0 = closed\n                ? controlPoints[controlPoints.length - 1]\n                : math.point.mirror(p2, p1);\n        }\n        if (p3Index < controlPoints.length) {\n            p3 = controlPoints[p3Index];\n        }\n        else {\n            p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n        }\n        return { p0, p1, p2, p3 };\n    }\n    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const numLineSegments = this.resolution + 1;\n        const inc = 1 / numLineSegments;\n        const minU = curveSegmentIndex;\n        let maxU = minU + 1;\n        if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n            maxU -= MAX_U_ERROR;\n        }\n        const lineSegments = [];\n        let startPoint;\n        let endPoint;\n        let previousLineSegmentsLength = 0;\n        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n            u = u > maxU ? maxU : u;\n            const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n            if (!i) {\n                startPoint = point;\n                continue;\n            }\n            endPoint = point;\n            const dx = endPoint[0] - startPoint[0];\n            const dy = endPoint[1] - startPoint[1];\n            const length = Math.sqrt(dx ** 2 + dy ** 2);\n            const aabb = {\n                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n            };\n            lineSegments.push({\n                points: {\n                    start: startPoint,\n                    end: endPoint,\n                },\n                aabb,\n                length,\n                previousLineSegmentsLength,\n            });\n            startPoint = endPoint;\n            previousLineSegmentsLength += length;\n        }\n        return lineSegments;\n    }\n    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);\n        let curveSegmentLength = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n            minX = Math.min(minX, lineSegAABB.minX);\n            minY = Math.min(minY, lineSegAABB.minY);\n            maxX = Math.max(maxX, lineSegAABB.maxX);\n            maxY = Math.max(maxY, lineSegAABB.maxY);\n            curveSegmentLength += lineSegLength;\n        });\n        return {\n            controlPoints: { p0, p1, p2, p3 },\n            aabb: { minX, minY, maxX, maxY },\n            length: curveSegmentLength,\n            previousCurveSegmentsLength: 0,\n            lineSegments,\n        };\n    }\n}\nexport { CubicSpline as default, CubicSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass LinearSpline extends CardinalSpline {\n    constructor() {\n        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });\n    }\n}\nexport { LinearSpline as default, LinearSpline };\n","import { QuadraticSpline } from './QuadraticSpline';\nconst TRANSFORM_MATRIX = [\n    1, 0, 0,\n    -2, 2, 0,\n    1, -2, 1,\n];\nclass QuadraticBezier extends QuadraticSpline {\n    hasTangentPoints() {\n        return true;\n    }\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { QuadraticBezier as default, QuadraticBezier };\n","import { Spline } from './Spline';\nclass QuadraticSpline extends Spline {\n    getSplineCurves() {\n        return [];\n    }\n    getLineSegments() {\n        return [];\n    }\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        return [];\n    }\n}\nexport { QuadraticSpline as default, QuadraticSpline };\n","import * as math from '../../../utilities/math';\nclass Spline {\n    constructor(props) {\n        this._controlPoints = [];\n        this._invalidated = false;\n        this._length = 0;\n        this._controlPoints = [];\n        this._resolution = props?.resolution ?? 20;\n        this._fixedResolution = props?.fixedResolution ?? false;\n        this._closed = props?.closed ?? false;\n        this._invalidated = true;\n    }\n    get controlPoints() {\n        return this._controlPoints;\n    }\n    get numControlPoints() {\n        return this._controlPoints.length;\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._fixedResolution || this._resolution === resolution) {\n            return;\n        }\n        this._resolution = resolution;\n        this.invalidated = true;\n    }\n    get fixedResolution() {\n        return this._fixedResolution;\n    }\n    get closed() {\n        return this._closed;\n    }\n    set closed(closed) {\n        if (this._closed === closed) {\n            return;\n        }\n        this._closed = closed;\n        this.invalidated = true;\n    }\n    get aabb() {\n        this._update();\n        return this._aabb;\n    }\n    get length() {\n        this._update();\n        return this._length;\n    }\n    get invalidated() {\n        return this._invalidated;\n    }\n    set invalidated(invalidated) {\n        this._invalidated = invalidated;\n    }\n    hasTangentPoints() {\n        return false;\n    }\n    addControlPoint(point) {\n        this._controlPoints.push([point[0], point[1]]);\n        this.invalidated = true;\n    }\n    addControlPoints(points) {\n        points.forEach((point) => this.addControlPoint(point));\n    }\n    addControlPointAtU(u) {\n        const lineSegment = this._getLineSegmentAt(u);\n        const { start: startPoint, end: endPoint } = lineSegment.points;\n        const curveSegmentIndex = Math.floor(u);\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const t = u - Math.floor(curveSegmentIndex);\n        const controlPointPos = [\n            startPoint[0] + t * (endPoint[0] - startPoint[0]),\n            startPoint[1] + t * (endPoint[1] - startPoint[1]),\n        ];\n        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n        this._controlPoints.splice(insertIndex, 0, controlPointPos);\n        this.invalidated = true;\n        return {\n            index: insertIndex,\n            point: controlPointPos,\n        };\n    }\n    deleteControlPointByIndex(index) {\n        const minControlPoints = this._closed ? 3 : 1;\n        const canDelete = index >= 0 &&\n            index < this._controlPoints.length &&\n            this._controlPoints.length > minControlPoints;\n        if (!canDelete) {\n            return false;\n        }\n        this._controlPoints.splice(index, 1);\n        this.invalidated = true;\n        return true;\n    }\n    clearControlPoints() {\n        this._controlPoints = [];\n        this.invalidated = true;\n    }\n    setControlPoints(points) {\n        this.clearControlPoints();\n        this.addControlPoints(points);\n    }\n    updateControlPoint(index, newControlPoint) {\n        if (index < 0 || index >= this._controlPoints.length) {\n            throw new Error('Index out of bounds');\n        }\n        this._controlPoints[index] = [...newControlPoint];\n        this.invalidated = true;\n    }\n    getControlPoints() {\n        return this._controlPoints.map((controlPoint) => [\n            controlPoint[0],\n            controlPoint[1],\n        ]);\n    }\n    getClosestControlPoint(point) {\n        const controlPoints = this._controlPoints;\n        let minSquaredDist = Infinity;\n        let closestPointIndex = -1;\n        for (let i = 0, len = controlPoints.length; i < len; i++) {\n            const controlPoint = controlPoints[i];\n            const dx = point[0] - controlPoint[0];\n            const dy = point[1] - controlPoint[1];\n            const squaredDist = dx * dx + dy * dy;\n            if (squaredDist < minSquaredDist) {\n                minSquaredDist = squaredDist;\n                closestPointIndex = i;\n            }\n        }\n        return {\n            index: closestPointIndex,\n            point: closestPointIndex === -1\n                ? undefined\n                : [...controlPoints[closestPointIndex]],\n            distance: Math.sqrt(minSquaredDist),\n        };\n    }\n    getClosestControlPointWithinDistance(point, maxDist) {\n        const closestControlPoint = this.getClosestControlPoint(point);\n        return closestControlPoint.distance <= maxDist\n            ? closestControlPoint\n            : undefined;\n    }\n    getClosestPoint(point) {\n        this._update();\n        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        if (!curveSegmentsDistInfo.length) {\n            return;\n        }\n        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);\n        let closestPoint;\n        let closestPointCurveSegmentIndex = -1;\n        let minDistSquared = Infinity;\n        let minDistCurveSegment;\n        let minDistLineSegment;\n        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n            const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n                continue;\n            }\n            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n            const { lineSegments } = curveSegment;\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineSegDistSquared < minDistSquared) {\n                    minDistLineSegment = lineSegment;\n                    closestPointCurveSegmentIndex = curveSegmentIndex;\n                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n                    closestPoint = lineSegPoint;\n                    minDistSquared = lineSegDistSquared;\n                }\n            }\n        }\n        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +\n            math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n        const u = closestPointCurveSegmentIndex + t;\n        return {\n            point: closestPoint,\n            uValue: u,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getClosestPointOnControlPointLines(point) {\n        const linePoints = [...this._controlPoints];\n        if (this._closed) {\n            linePoints.push(this._controlPoints[0]);\n        }\n        if (!linePoints.length) {\n            return;\n        }\n        let closestPoint;\n        let minDistSquared = Infinity;\n        let startPoint = linePoints[0];\n        for (let i = 1, len = linePoints.length; i < len; i++) {\n            const endPoint = linePoints[i];\n            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);\n            if (lineSegDistSquared < minDistSquared) {\n                closestPoint = lineSegPoint;\n                minDistSquared = lineSegDistSquared;\n            }\n            startPoint = endPoint;\n        }\n        return {\n            point: closestPoint,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getPolylinePoints() {\n        this._update();\n        return this._convertCurveSegmentsToPolyline(this._curveSegments);\n    }\n    getPreviewPolylinePoints(controlPointPreview, closeDistance) {\n        if (this._closed) {\n            return [];\n        }\n        this._update();\n        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);\n        const closeSpline = closestControlPoint?.index === 0;\n        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);\n        return previewCurveSegments?.length\n            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n            : [];\n    }\n    isPointNearCurve(point, maxDist) {\n        this._update();\n        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n        const maxDistSquared = maxDist * maxDist;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const { lineSegments } = curveSegments[i];\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const lineDistSquared = math.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineDistSquared <= maxDistSquared) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    containsPoint(point) {\n        this._update();\n        const controlPoints = this._controlPoints;\n        if (controlPoints.length < 3) {\n            return false;\n        }\n        const curveSegments = [...this._curveSegments];\n        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();\n        if (closingCurveSegment) {\n            curveSegments.push(closingCurveSegment);\n        }\n        let numIntersections = 0;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const { aabb: curveSegAABB } = curveSegment;\n            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&\n                point[1] >= curveSegAABB.minY &&\n                point[1] < curveSegAABB.maxY;\n            if (!mayIntersectCurveSegment) {\n                continue;\n            }\n            const { lineSegments } = curveSegment;\n            for (let i = 0; i < lineSegments.length; i++) {\n                const lineSegment = lineSegments[i];\n                const { aabb: lineSegmentAABB } = lineSegment;\n                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&\n                    point[1] >= lineSegmentAABB.minY &&\n                    point[1] < lineSegmentAABB.maxY;\n                if (mayIntersectLineSegment) {\n                    const { start: p1, end: p2 } = lineSegment.points;\n                    const isVerticalLine = p1[0] === p2[0];\n                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                    numIntersections +=\n                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n                }\n            }\n        }\n        return numIntersections % 2 === 1;\n    }\n    _update() {\n        if (!this._invalidated) {\n            return;\n        }\n        const curveSegments = this.getSplineCurves();\n        let length = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        for (let i = 0, len = curveSegments.length; i < len; i++) {\n            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n            length += curveSegLength;\n        }\n        this._curveSegments = curveSegments;\n        this._aabb = { minX, minY, maxX, maxY };\n        this._length = length;\n        this._invalidated = false;\n    }\n    _convertCurveSegmentsToPolyline(curveSegments) {\n        this._update();\n        const polylinePoints = [];\n        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n            lineSegments.forEach((lineSegment, lineSegIndex) => {\n                if (curveSegIndex === 0 && lineSegIndex === 0) {\n                    polylinePoints.push([...lineSegment.points.start]);\n                }\n                polylinePoints.push([...lineSegment.points.end]);\n            });\n        });\n        return polylinePoints;\n    }\n    _getCurveSegmmentsDistanceSquaredInfo(point) {\n        this._update();\n        const curveSegmentsDistanceSquared = [];\n        const { _curveSegments: curveSegments } = this;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const distanceSquared = math.aabb.distanceToPointSquared(curveSegment.aabb, point);\n            curveSegmentsDistanceSquared.push({\n                curveSegmentIndex: i,\n                curveSegment,\n                distanceSquared,\n            });\n        }\n        return curveSegmentsDistanceSquared;\n    }\n    _getCurveSegmmentsWithinDistance(point, maxDist) {\n        this._update();\n        const maxDistSquared = maxDist * maxDist;\n        if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n            return [];\n        }\n        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        const curveSegmentsWithinRange = [];\n        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];\n            if (curveSegmentDistSquared <= maxDistSquared) {\n                curveSegmentsWithinRange.push(curveSegment);\n            }\n        }\n        return curveSegmentsWithinRange;\n    }\n    _getLineSegmentAt(u) {\n        this._update();\n        const curveSegmentIndex = Math.floor(u);\n        const t = u - curveSegmentIndex;\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const { lineSegments } = curveSegment;\n        const pointLength = curveSegment.length * t;\n        for (let i = 0; i < lineSegments.length; i++) {\n            const lineSegment = lineSegments[i];\n            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;\n            if (pointLength >= lineSegment.previousLineSegmentsLength &&\n                pointLength <= lengthEnd) {\n                return lineSegment;\n            }\n        }\n    }\n    _getClosingCurveSegmentWithStraightLineSegment() {\n        if (this.closed) {\n            return;\n        }\n        const controlPoints = this._controlPoints;\n        const startControlPoint = controlPoints[0];\n        const endControlPoint = controlPoints[controlPoints.length - 1];\n        const closingLineSegment = {\n            points: {\n                start: [...startControlPoint],\n                end: [...endControlPoint],\n            },\n            aabb: {\n                minX: Math.min(startControlPoint[0], endControlPoint[0]),\n                minY: Math.min(startControlPoint[1], endControlPoint[1]),\n                maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n                maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n            },\n        };\n        return {\n            aabb: {\n                minX: closingLineSegment.aabb.minX,\n                minY: closingLineSegment.aabb.minY,\n                maxX: closingLineSegment.aabb.maxX,\n                maxY: closingLineSegment.aabb.maxY,\n            },\n            lineSegments: [closingLineSegment],\n        };\n    }\n}\nexport { Spline as default, Spline };\n","import { utilities, getEnabledElement, cache, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nclass AnnotationDisplayTool extends BaseTool {\n    constructor() {\n        super(...arguments);\n        this.onImageSpacingCalibrated = (evt) => {\n            const { element, imageId } = evt.detail;\n            const imageURI = utilities.imageIdToURI(imageId);\n            const annotationManager = getAnnotationManager();\n            const framesOfReference = annotationManager.getFramesOfReference();\n            framesOfReference.forEach((frameOfReference) => {\n                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];\n                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n                    return;\n                }\n                toolSpecificAnnotations.forEach((annotation) => {\n                    if (!annotation.metadata?.referencedImageId) {\n                        return;\n                    }\n                    const referencedImageURI = utilities.imageIdToURI(annotation.metadata.referencedImageId);\n                    if (referencedImageURI === imageURI) {\n                        annotation.invalidated = true;\n                        annotation.data.cachedStats = {};\n                    }\n                });\n                triggerAnnotationRender(element);\n            });\n        };\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations?.length) {\n            return [];\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        return filterAnnotationsForDisplay(viewport, annotations);\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const viewReference = viewport.getViewReference({ points: [worldPos] });\n        return {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                ...viewReference,\n                referencedImageId,\n                viewUp,\n                cameraPosition,\n            },\n            data: {\n                cachedStats: {},\n                handles: {\n                    points: [],\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n            },\n        };\n    }\n    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const imageVolume = cache.getVolume(volumeId);\n            referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n        }\n        return referencedImageId;\n    }\n    getStyle(property, specifications, annotation) {\n        return getStyleProperty(property, specifications, getState(annotation), this.mode);\n    }\n}\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import { utilities } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nconst { DefaultHistoryMemo } = utilities.HistoryMemo;\nclass BaseTool {\n    static { this.defaults = {\n        configuration: {\n            strategies: {},\n            defaultStrategy: undefined,\n            activeStrategy: undefined,\n            strategyOptions: {},\n        },\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        const mergedDefaults = BaseTool.mergeDefaultProps(BaseTool.defaults, defaultToolProps);\n        const initialProps = utilities.deepMerge(mergedDefaults, toolProps);\n        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;\n        this.toolGroupId = toolGroupId;\n        this.supportedInteractionTypes = supportedInteractionTypes || [];\n        this.configuration = Object.assign({}, configuration);\n        this.mode = ToolModes.Disabled;\n    }\n    static mergeDefaultProps(defaultProps = {}, additionalProps) {\n        if (!additionalProps) {\n            return defaultProps;\n        }\n        return utilities.deepMerge(defaultProps, additionalProps);\n    }\n    get toolName() {\n        return this.getToolName();\n    }\n    getToolName() {\n        return this.constructor.toolName;\n    }\n    applyActiveStrategy(enabledElement, operationData) {\n        const { strategies, activeStrategy } = this.configuration;\n        return strategies[activeStrategy]?.call(this, enabledElement, operationData);\n    }\n    applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {\n        const { strategies, activeStrategy } = this.configuration;\n        if (!strategies[activeStrategy]) {\n            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);\n        }\n        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData, ...extraArgs);\n    }\n    setConfiguration(newConfiguration) {\n        this.configuration = utilities.deepMerge(this.configuration, newConfiguration);\n    }\n    setActiveStrategy(strategyName) {\n        this.setConfiguration({ activeStrategy: strategyName });\n    }\n    getTargetImageData(targetId) {\n        if (targetId.startsWith('imageId:')) {\n            const imageId = targetId.split('imageId:')[1];\n            const imageURI = utilities.imageIdToURI(imageId);\n            let viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            viewports = viewports.filter((viewport) => {\n                return viewport.getCurrentImageId() === imageId;\n            });\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('volumeId:')) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const viewports = utilities.getViewportsWithVolumeId(volumeId);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('videoId:')) {\n            const imageURI = utilities.imageIdToURI(targetId);\n            const viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else {\n            throw new Error('getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"');\n        }\n    }\n    getTargetId(viewport) {\n        const targetId = viewport.getViewReferenceId?.();\n        if (targetId) {\n            return targetId;\n        }\n        throw new Error('getTargetId: viewport must have a getViewReferenceId method');\n    }\n    undo() {\n        this.doneEditMemo();\n        DefaultHistoryMemo.undo();\n    }\n    redo() {\n        DefaultHistoryMemo.redo();\n    }\n    static createZoomPanMemo(viewport) {\n        const state = {\n            pan: viewport.getPan(),\n            zoom: viewport.getZoom(),\n        };\n        const zoomPanMemo = {\n            restoreMemo: () => {\n                const currentPan = viewport.getPan();\n                const currentZoom = viewport.getZoom();\n                viewport.setZoom(state.zoom);\n                viewport.setPan(state.pan);\n                viewport.render();\n                state.pan = currentPan;\n                state.zoom = currentZoom;\n            },\n        };\n        DefaultHistoryMemo.push(zoomPanMemo);\n        return zoomPanMemo;\n    }\n    doneEditMemo() {\n        if (this.memo?.commitMemo?.()) {\n            DefaultHistoryMemo.push(this.memo);\n        }\n        this.memo = null;\n    }\n}\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { cache, getEnabledElementByViewportId, Enums, utilities, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { handleContourSegmentation } from './contourHandler/handleContourSegmentation';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport removeContourFromElement from './removeContourFromElement';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation/getUniqueSegmentIndices';\nimport { getAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nconst polySegConversionInProgressForViewportId = new Map();\nconst processedViewportSegmentations = new Map();\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeContourFromElement(viewportId, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let contourData = segmentation.representationData[Representations.Contour];\n    const polySeg = getPolySeg();\n    if (!contourData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Contour) &&\n        !polySegConversionInProgressForViewportId.get(viewport.id)) {\n        polySegConversionInProgressForViewportId.set(viewport.id, true);\n        contourData = await computeAndAddRepresentation(segmentationId, Representations.Contour, () => polySeg.computeContourData(segmentationId, { viewport }), () => undefined);\n        polySegConversionInProgressForViewportId.set(viewport.id, false);\n    }\n    else if (!contourData && !getPolySeg()) {\n        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!contourData) {\n        return;\n    }\n    if (!contourData.geometryIds?.length) {\n        return;\n    }\n    let hasContourDataButNotMatchingViewport = false;\n    const viewportNormal = viewport.getCamera().viewPlaneNormal;\n    if (contourData.annotationUIDsMap) {\n        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);\n    }\n    if (contourData.geometryIds.length > 0) {\n        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);\n    }\n    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();\n    if (hasContourDataButNotMatchingViewport &&\n        !polySegConversionInProgressForViewportId.get(viewport.id) &&\n        !viewportProcessed.has(segmentationId) &&\n        viewport.viewportStatus === Enums.ViewportStatus.RENDERED) {\n        polySegConversionInProgressForViewportId.set(viewport.id, true);\n        const segmentIndices = getUniqueSegmentIndices(segmentationId);\n        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {\n            segmentIndices,\n            viewport,\n        });\n        const geometryIds = surfacesInfo.geometryIds;\n        const pointsAndPolys = [];\n        for (const geometryId of geometryIds.values()) {\n            const geometry = cache.getGeometry(geometryId);\n            const data = geometry.data;\n            pointsAndPolys.push({\n                points: data.points,\n                polys: data.polys,\n                segmentIndex: data.segmentIndex,\n                id: data.segmentIndex,\n            });\n        }\n        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);\n        const rawResults = polySeg.extractContourData(polyDataCache);\n        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);\n        contourData.annotationUIDsMap = new Map([\n            ...contourData.annotationUIDsMap,\n            ...annotationUIDsMap,\n        ]);\n        viewportProcessed.add(segmentationId);\n        processedViewportSegmentations.set(viewport.id, viewportProcessed);\n        polySegConversionInProgressForViewportId.set(viewport.id, false);\n    }\n    handleContourSegmentation(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);\n}\nfunction _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {\n    let validGeometry = null;\n    let geometryData = null;\n    for (const geometryId of geometryIds) {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            continue;\n        }\n        const data = geometry.data;\n        if (data.contours?.[0]?.points?.length >= 3) {\n            validGeometry = geometry;\n            geometryData = data;\n            break;\n        }\n    }\n    if (!validGeometry || !geometryData) {\n        return false;\n    }\n    const contours = geometryData.contours;\n    const points = contours[0].points;\n    const point1 = points[0];\n    const point2 = points[1];\n    const point3 = points[2];\n    let normal = vec3.cross(vec3.create(), vec3.sub(vec3.create(), point2, point1), vec3.sub(vec3.create(), point3, point1));\n    normal = vec3.normalize(vec3.create(), normal);\n    const dotProduct = vec3.dot(normal, viewportNormal);\n    return Math.abs(dotProduct) > 0.9;\n}\nfunction _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {\n    const annotationUIDs = Array.from(annotationUIDsMap.values())\n        .flat()\n        .map((uidSet) => Array.from(uidSet))\n        .flat();\n    const randomAnnotationUIDs = utilities.getRandomSampleFromArray(annotationUIDs, 3);\n    for (const annotationUID of randomAnnotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        if (annotation?.metadata) {\n            if (!annotation.metadata.viewPlaneNormal) {\n                continue;\n            }\n            const annotationNormal = annotation.metadata.viewPlaneNormal;\n            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +\n                viewportNormal[1] * annotationNormal[1] +\n                viewportNormal[2] * annotationNormal[2]);\n            if (Math.abs(dotProduct - 1) > 0.01) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport default {\n    render,\n    removeRepresentation,\n};\n","import { getEnabledElementByViewportId, VolumeViewport, } from '@cornerstonejs/core';\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { getActiveSegmentation } from '../../../stateManagement/segmentation/activeSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { segmentationStyle } from '../../../stateManagement/segmentation/SegmentationStyle';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { getActiveSegmentIndex } from '../../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLabelmapActorEntries } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { defaultSegmentationStateManager } from '../../../stateManagement/segmentation/SegmentationStateManager';\nexport const MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\nlet polySegConversionInProgress = false;\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    labelMapConfigCache.forEach((value, key) => {\n        if (key.includes(segmentationId)) {\n            labelMapConfigCache.delete(key);\n        }\n    });\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeLabelmapFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId, config } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn('No segmentation found for segmentationId: ', segmentationId);\n        return;\n    }\n    let labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    let labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    if (!labelmapData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations.Labelmap) &&\n        !polySegConversionInProgress) {\n        polySegConversionInProgress = true;\n        const polySeg = getPolySeg();\n        labelmapData = await computeAndAddRepresentation(segmentationId, SegmentationRepresentations.Labelmap, () => polySeg.computeLabelmapData(segmentationId, { viewport }), () => null, () => {\n            defaultSegmentationStateManager.processLabelmapRepresentationAddition(viewport.id, segmentationId);\n            setTimeout(() => {\n                triggerSegmentationDataModified(segmentationId);\n            }, 0);\n        });\n        if (!labelmapData) {\n            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);\n        }\n        polySegConversionInProgress = false;\n    }\n    else if (!labelmapData && !getPolySeg()) {\n        console.debug(`No labelmap data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!labelmapData) {\n        return;\n    }\n    if (viewport instanceof VolumeViewport) {\n        if (!labelmapActorEntries?.length) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);\n        }\n        labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    }\n    else {\n        const labelmapImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        if (!labelmapImageIds?.length) {\n            return;\n        }\n        if (!labelmapActorEntries) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);\n        }\n        labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    }\n    if (!labelmapActorEntries?.length) {\n        return;\n    }\n    for (const labelmapActorEntry of labelmapActorEntries) {\n        _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);\n    }\n}\nfunction _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {\n    const { segmentationId } = segmentationRepresentation;\n    const { cfun, ofun } = segmentationRepresentation.config;\n    const { colorLUTIndex } = segmentationRepresentation;\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;\n    const labelmapStyle = segmentationStyle.getStyle({\n        viewportId,\n        type: SegmentationRepresentations.Labelmap,\n        segmentationId,\n    });\n    const renderInactiveSegmentations = segmentationStyle.getRenderInactiveSegmentations(viewportId);\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const numColors = Math.min(256, colorLUT.length);\n    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);\n    const segmentsHidden = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    });\n    for (let i = 0; i < numColors; i++) {\n        const segmentIndex = i;\n        const segmentColor = colorLUT[segmentIndex];\n        const perSegmentStyle = segmentationStyle.getStyle({\n            viewportId,\n            type: SegmentationRepresentations.Labelmap,\n            segmentationId,\n            segmentIndex,\n        });\n        const segmentSpecificLabelmapConfig = perSegmentStyle;\n        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);\n        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            segmentColor,\n            outlineWidth,\n            segmentsHidden: segmentsHidden,\n            cfun,\n            ofun,\n        });\n        if (forceColorUpdate) {\n            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);\n        }\n        if (forceOpacityUpdate) {\n            if (renderFill) {\n                const segmentOpacity = segmentsHidden.has(segmentIndex)\n                    ? 0\n                    : (segmentColor[3] / 255) * fillAlpha;\n                ofun.removePoint(segmentIndex);\n                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n            }\n            else {\n                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n            }\n        }\n    }\n    ofun.setClamping(false);\n    const labelmapActor = labelmapActorEntry.actor;\n    const { preLoad } = labelmapActor.get?.('preLoad') || { preLoad: null };\n    if (preLoad) {\n        preLoad({ cfun, ofun, actor: labelmapActor });\n    }\n    else {\n        labelmapActor.getProperty().setRGBTransferFunction(0, cfun);\n        labelmapActor.getProperty().setScalarOpacity(0, ofun);\n        labelmapActor.getProperty().setInterpolationTypeToNearest();\n    }\n    if (renderOutline) {\n        labelmapActor.getProperty().setUseLabelOutline(renderOutline);\n        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n        const activeSegmentIndex = getActiveSegmentIndex(segmentationRepresentation.segmentationId);\n        const outlineWidths = new Array(numColors - 1);\n        for (let i = 1; i < numColors; i++) {\n            const isHidden = segmentsHidden.has(i);\n            if (isHidden) {\n                outlineWidths[i - 1] = 0;\n                continue;\n            }\n            outlineWidths[i - 1] =\n                i === activeSegmentIndex\n                    ? outlineWidth + activeSegmentOutlineWidthDelta\n                    : outlineWidth;\n        }\n        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);\n        labelmapActor.modified();\n        labelmapActor.getProperty().modified();\n        labelmapActor.getMapper().modified();\n    }\n    else {\n        labelmapActor\n            .getProperty()\n            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));\n    }\n    const visible = isActiveLabelmap || renderInactiveSegmentations;\n    labelmapActor.setVisibility(visible);\n}\nfunction _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {\n    const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n    const configToUse = {\n        ...labelmapConfig,\n        ...segmentLabelmapConfig,\n    };\n    const fillAlpha = isActiveLabelmap\n        ? configToUse.fillAlpha\n        : configToUse.fillAlphaInactive;\n    const outlineWidth = isActiveLabelmap\n        ? configToUse.outlineWidth\n        : configToUse.outlineWidthInactive;\n    const renderFill = isActiveLabelmap\n        ? configToUse.renderFill\n        : configToUse.renderFillInactive;\n    const renderOutline = isActiveLabelmap\n        ? configToUse.renderOutline\n        : configToUse.renderOutlineInactive;\n    const outlineOpacity = isActiveLabelmap\n        ? configToUse.outlineOpacity\n        : configToUse.outlineOpacityInactive;\n    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;\n    return {\n        fillAlpha,\n        outlineWidth,\n        renderFill,\n        renderOutline,\n        outlineOpacity,\n        activeSegmentOutlineWidthDelta,\n    };\n}\nfunction _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {\n    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;\n    const oldConfig = labelMapConfigCache.get(cacheUID);\n    if (!oldConfig) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n        return {\n            forceOpacityUpdate: true,\n            forceColorUpdate: true,\n        };\n    }\n    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;\n    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||\n        oldSegmentColor[1] !== segmentColor[1] ||\n        oldSegmentColor[2] !== segmentColor[2];\n    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||\n        oldFillAlpha !== fillAlpha ||\n        oldRenderFill !== renderFill ||\n        oldRenderOutline !== renderOutline ||\n        oldOutlineWidth !== outlineWidth ||\n        oldSegmentsHidden !== segmentsHidden;\n    if (forceOpacityUpdate || forceColorUpdate) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n    }\n    return {\n        forceOpacityUpdate,\n        forceColorUpdate,\n    };\n}\nasync function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {\n    const result = await addLabelmapToElement(viewport.element, labelmapData, segmentationId, config);\n    return result || undefined;\n}\nexport default {\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n","import { cache, getEnabledElementByViewportId, Enums, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addOrUpdateSurfaceToElement from './addOrUpdateSurfaceToElement';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeSurfaceFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId, type } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let SurfaceData = segmentation.representationData[Representations.Surface];\n    if (!SurfaceData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Surface)) {\n        const polySeg = getPolySeg();\n        SurfaceData = await computeAndAddRepresentation(segmentationId, Representations.Surface, () => polySeg.computeSurfaceData(segmentationId, { viewport }), () => polySeg.updateSurfaceData(segmentationId, { viewport }));\n        if (!SurfaceData) {\n            throw new Error(`No Surface data found for segmentationId ${segmentationId} even we tried to compute it`);\n        }\n    }\n    else if (!SurfaceData && !getPolySeg()) {\n        console.debug(`No surface data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!SurfaceData) {\n        console.warn(`No Surface data found for segmentationId ${segmentationId}. Skipping render.`);\n        return;\n    }\n    const { geometryIds } = SurfaceData;\n    if (!geometryIds?.size) {\n        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);\n    }\n    const { colorLUTIndex } = representation;\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const surfaces = [];\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry?.data) {\n            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const { segmentIndex } = geometry.data;\n        const hiddenSegments = internalGetHiddenSegmentIndices(viewport.id, {\n            segmentationId,\n            type,\n        });\n        const isHidden = hiddenSegments.has(segmentIndex);\n        const surface = geometry.data;\n        const color = colorLUT[segmentIndex];\n        surface.color = color.slice(0, 3);\n        surface.visible = !isHidden;\n        surfaces.push(surface);\n        addOrUpdateSurfaceToElement(viewport.element, surface, segmentationId);\n    });\n    viewport.render();\n}\nexport default {\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n","import { getEnabledElement, eventTarget } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { Events, ToolModes, StrategyCallbacks } from '../../enums';\nimport { fillInsideSphere, thresholdInsideSphere, thresholdInsideSphereIsland, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nimport { getStrategyData } from './strategies/utils/getStrategyData';\nclass BrushTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland,\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n            useCenterSegmentIndex: false,\n            preview: {\n                enabled: false,\n                previewColors: {\n                    0: [255, 255, 255, 128],\n                },\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.Interpolate]: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'i',\n                        },\n                    ],\n                    configuration: {\n                        useBallStructuringElement: true,\n                        noUseDistanceTransform: true,\n                        noUseExtrapolation: true,\n                    },\n                },\n                interpolateExtrapolation: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'e',\n                        },\n                    ],\n                    configuration: {},\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { startPoint, timer, timerStart, isDrag } = this._previewData;\n                if (isDrag) {\n                    return;\n                }\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (!isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            if (this._previewData.isDrag) {\n                this._previewData.timer = null;\n                return;\n            }\n            this._previewData.timer = null;\n            const operationData = this.getOperationData(this._previewData.element);\n            const enabledElement = getEnabledElement(this._previewData.element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const activeStrategy = this.configuration.activeStrategy;\n            const strategyData = getStrategyData({\n                operationData,\n                viewport,\n                strategy: activeStrategy,\n            });\n            if (!operationData) {\n                return;\n            }\n            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), {\n                ...operationData,\n                ...strategyData,\n                memo,\n            }, StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            if (this._previewData.timer) {\n                window.clearTimeout(this._previewData.timer);\n                this._previewData.timer = null;\n            }\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentPoints.canvas;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n            }\n            this.doneEditMemo();\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy?.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    getStatistics(element, segmentIndices) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.GetStatistics, segmentIndices);\n        return stats;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        super.acceptPreview(element);\n    }\n    interpolate(element, config) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.Interpolate, config.configuration);\n        this._previewData.isDrag = true;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,\n        });\n        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { StackViewport, cache, getEnabledElement, utilities as csUtils, utilities as coreUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, removeAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, } from '../../utilities/getCalibratedUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    volumeId,\n                    spacingInNormal,\n                    enabledElement,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        statistics: [],\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let tempStartCoordinate = startCoordinate;\n                let tempEndCoordinate = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);\n                    data.startCoordinate = tempStartCoordinate;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);\n                    data.endCoordinate = tempEndCoordinate;\n                }\n                const roundedStartCoordinate = coreUtils.roundToPrecision(data.startCoordinate);\n                const roundedEndCoordinate = coreUtils.roundToPrecision(data.endCoordinate);\n                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCameraCoordinate = coreUtils.roundToPrecision(cameraCoordinate);\n                if (roundedCameraCoordinate <\n                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||\n                    roundedCameraCoordinate >\n                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {\n                    continue;\n                }\n                const middleCoordinate = coreUtils.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);\n                let isMiddleSlice = false;\n                if (roundedCameraCoordinate === middleCoordinate) {\n                    isMiddleSlice = true;\n                }\n                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;\n                if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    isMiddleSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineWidthToUse = lineWidth;\n                let lineDashToUse = lineDash;\n                if (isMiddleSlice) {\n                    lineWidthToUse = lineWidth;\n                    lineDashToUse = [];\n                }\n                else {\n                    lineDashToUse = [5, 5];\n                }\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth: lineWidthToUse,\n                });\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const handlesToStart = csUtils.deepClone(points);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        if (projectionAxisIndex == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n            handlesToStart[0][2] = startCoordinate;\n            handlesToStart[1][2] = startCoordinate;\n        }\n        else if (projectionAxisIndex == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n            handlesToStart[0][0] = startCoordinate;\n            handlesToStart[1][0] = startCoordinate;\n        }\n        else if (projectionAxisIndex == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n            handlesToStart[0][1] = startCoordinate;\n            handlesToStart[1][1] = startCoordinate;\n        }\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        vec3.normalize(direction, direction);\n        const newProjectionPoints = [];\n        const basePoints = points;\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(basePoints.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n        const pos1 = viewport.canvasToWorld(topLeftCanvas);\n        const pos2 = viewport.canvasToWorld(bottomRightCanvas);\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, pos1, pos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(Math.PI *\n            (worldWidth / measureInfo.scale / 2) *\n            (worldHeight / aspect / measureInfo.scale / 2));\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const centerWorld = projectionPoints[i][0];\n            const canvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = centerWorld;\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n        const startPos = vec3.create();\n        vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass CircleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n                ERASE_INSIDE: eraseInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData.Labelmap;\n            if (!labelmapData) {\n                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');\n            }\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { Events, SegmentationRepresentations } from '../../enums';\nimport { eventTarget, utilities, getRenderingEngine, } from '@cornerstonejs/core';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\nimport BrushTool from './BrushTool';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport { getSegmentationRepresentationsBySegmentationId } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nclass LabelMapEditWithContourTool extends PlanarFreehandContourSegmentationTool {\n    static { this.toolName = 'LabelMapEditWithContour'; }\n    static { this.annotationsToViewportMap = new Map(); }\n    static { this.viewportIdsChecked = []; }\n    constructor(toolProps = {}) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.onViewportAddedToToolGroupBinded =\n            this.onViewportAddedToToolGroup.bind(this);\n        this.onSegmentationModifiedBinded = this.onSegmentationModified.bind(this);\n    }\n    initializeListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroupBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n    }\n    cleanUpListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroup.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n    }\n    async checkContourSegmentation(viewportId) {\n        if (LabelMapEditWithContourTool.viewportIdsChecked.includes(viewportId)) {\n            return;\n        }\n        const activeSeg = segmentation.getActiveSegmentation(viewportId);\n        if (!activeSeg) {\n            console.log('No active segmentation detected');\n            return false;\n        }\n        const segmentationId = activeSeg.segmentationId;\n        if (!activeSeg.representationData.Contour) {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n            await segmentation.addContourRepresentationToViewport(viewportId, [\n                {\n                    segmentationId,\n                    type: SegmentationRepresentations.Contour,\n                },\n            ]);\n            segmentation.addRepresentationData({\n                segmentationId,\n                type: SegmentationRepresentations.Contour,\n                data: {},\n            });\n        }\n        else {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n        }\n        return true;\n    }\n    onViewportAddedToToolGroup(evt) {\n        const { toolGroupId, viewportId } = evt.detail;\n        if (toolGroupId !== this.toolGroupId) {\n            return;\n        }\n        this.checkContourSegmentation(viewportId);\n    }\n    onSegmentationModified(evt) {\n        const { segmentationId } = evt.detail || {};\n        if (!segmentationId) {\n            return;\n        }\n        const representations = getSegmentationRepresentationsBySegmentationId(segmentationId);\n        if (!representations) {\n            return;\n        }\n        representations.forEach(async ({ viewportId }) => await this.checkContourSegmentation(viewportId));\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.cleanUpListeners();\n    }\n    annotationModified(evt) {\n        const { annotation, renderingEngineId, viewportId } = evt.detail;\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        if (!viewport) {\n            return;\n        }\n        LabelMapEditWithContourTool.annotationsToViewportMap.set(annotation.annotationUID, viewport);\n    }\n    annotationCompleted(evt) {\n        const { annotation } = evt.detail;\n        const { polyline } = annotation.data?.contour || {};\n        if (annotation?.metadata?.toolName !== LabelMapEditWithContourTool.toolName) {\n            return;\n        }\n        if (!polyline) {\n            return;\n        }\n        if (LabelMapEditWithContourTool.annotationsToViewportMap.has(annotation.annotationUID)) {\n            const viewport = LabelMapEditWithContourTool.annotationsToViewportMap.get(annotation.annotationUID);\n            if (polyline.length > 3) {\n                BrushTool.viewportContoursToLabelmap(viewport);\n            }\n        }\n    }\n}\nexport default LabelMapEditWithContourTool;\n","import { cache, getEnabledElement, utilities as csUtils, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            let dimensions;\n            let direction;\n            let index;\n            let voxelManager;\n            this.doneEditMemo();\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n                const segmentation = cache.getVolume(volumeId);\n                ({ dimensions, direction } = segmentation);\n                voxelManager = segmentation.voxelManager;\n                index = transformWorldToIndex(segmentation.imageData, worldPos);\n            }\n            else {\n                const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                if (!currentSegmentationImageId) {\n                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');\n                }\n                const { imageData } = viewport.getImageData();\n                dimensions = imageData.getDimensions();\n                direction = imageData.getDirection();\n                const image = cache.getImage(currentSegmentationImageId);\n                voxelManager = image.voxelManager;\n                index = transformWorldToIndex(imageData, worldPos);\n            }\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);\n                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { flooded: boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ) {\n                    minJ = j;\n                }\n                if (j > maxJ) {\n                    maxJ = j;\n                }\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return voxelManager.toIndex([x, y, z]);\n            };\n            const getLabelValue = (x, y, z) => {\n                return voxelManager.getAtIJK(x, y, z);\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                    spacingInNormal,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        projectionPointsImageIds: [referencedImageId],\n                        statistics: [],\n                    },\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let startCoord = startCoordinate;\n                let endCoord = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);\n                    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal);\n                    data.handles.points.forEach((point) => {\n                        point[indexOfDirection] = startCoord;\n                    });\n                    data.startCoordinate = startCoord;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);\n                    data.endCoordinate = endCoord;\n                    data.endCoordinate = endCoord;\n                }\n                const roundedStartCoord = csUtils.roundToPrecision(startCoord);\n                const roundedEndCoord = csUtils.roundToPrecision(endCoord);\n                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCoord = csUtils.roundToPrecision(coord);\n                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {\n                    continue;\n                }\n                if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, enabledElement);\n                }\n                let firstOrLastSlice = false;\n                if (roundedCoord === roundedStartCoord ||\n                    roundedCoord === roundedEndCoord) {\n                    firstOrLastSlice = true;\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    firstOrLastSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineDashToUse = lineDash;\n                if (!firstOrLastSlice) {\n                    lineDashToUse = 2;\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth,\n                });\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    if (!data.handles.textBox.hasMoved) {\n                        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        if (projectionAxisIndex == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n        }\n        else if (projectionAxisIndex == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n        }\n        else if (projectionAxisIndex == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n        }\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        vec3.normalize(direction, direction);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(points.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[3];\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);\n        const area = Math.abs(worldWidth * worldHeight) /\n            (measureInfo.scale * measureInfo.scale);\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const projectionPoint = projectionPoints[i][0];\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                this.isHandleOutsideImage = false;\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, viewPlaneNormal) {\n        const startPos = worldPos;\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nclass RectangleROIThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const targetId = this.getTargetId(viewport);\n            let referencedImageId, volumeId;\n            if (viewport instanceof StackViewport) {\n                referencedImageId = targetId.split('imageId:')[1];\n            }\n            else {\n                volumeId = csUtils.getVolumeId(targetId);\n                const imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: null,\n                            worldBoundingBox: null,\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    segmentationId: null,\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                triggerAnnotationModified(annotation, element);\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n}\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass RectangleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport BidirectionalTool from '../annotation/BidirectionalTool';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nclass SegmentBidirectionalTool extends BidirectionalTool {\n    static { this.toolName = 'SegmentBidirectional'; }\n    constructor(toolProps = {}) {\n        super(toolProps);\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportId = viewport.id;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { segmentIndex, segmentationId } = annotation.metadata;\n                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const colorArray = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                options.color = color;\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const existingAnnotations = getAllAnnotations();\n        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');\n        const existingAnnotation = toolAnnotations.find((annotation) => {\n            const { metadata } = annotation;\n            if (metadata.segmentIndex === options?.segmentIndex &&\n                metadata.segmentationId === options?.segmentationId) {\n                return true;\n            }\n            return false;\n        });\n        if (existingAnnotation) {\n            removeAnnotation(existingAnnotation.annotationUID);\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                segmentIndex: options?.segmentIndex,\n                segmentationId: options?.segmentationId,\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n}\nexport default SegmentBidirectionalTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { getSegmentIndexAtWorldPoint } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { drawLinkedTextBox as drawLinkedTextBoxSvg } from '../../drawingSvg';\nclass SegmentLabelTool extends BaseTool {\n    constructor(toolProps = {\n        data: {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        },\n    }, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setHoveredSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.data = toolProps.data ?? {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        };\n        this.hoverTimer = null;\n    }\n    _setHoveredSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId } = activeSegmentation;\n        const hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n            viewport,\n        });\n        const segment = activeSegmentation.segments[hoveredSegmentIndex];\n        const label = segment?.label;\n        const canvasCoordinates = viewport.worldToCanvas(worldPoint);\n        this._editData = {\n            hoveredSegmentIndex,\n            hoveredSegmentLabel: label,\n            canvasCoordinates,\n            worldPoint,\n        };\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._editData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, worldPoint, } = this._editData;\n        if (!hoveredSegmentIndex) {\n            return;\n        }\n        const textBoxPosition = viewport.worldToCanvas(worldPoint);\n        const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ? hoveredSegmentLabel : '(unnamed segment)'], textBoxPosition, [canvasCoordinates], {}, {});\n        const left = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const { width, height } = boundingBox;\n        this.data.handles.textBox.worldBoundingBox = {\n            topLeft: viewport.canvasToWorld([left, top]),\n            topRight: viewport.canvasToWorld([left + width, top]),\n            bottomLeft: viewport.canvasToWorld([left, top + height]),\n            bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n    }\n}\nSegmentLabelTool.toolName = 'SegmentLabelTool';\nexport default SegmentLabelTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport { getHoveredContourSegmentationAnnotation, getSegmentIndexAtLabelmapBorder, getSegmentIndexAtWorldPoint, } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nclass SegmentSelectTool extends BaseTool {\n    static { this.SelectMode = {\n        Inside: 'Inside',\n        Border: 'Border',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            mode: SegmentSelectTool.SelectMode.Border,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode !== ToolModes.Active) {\n                return;\n            }\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setActiveSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.hoverTimer = null;\n    }\n    _setActiveSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId, representationData } = activeSegmentation;\n        let hoveredSegmentIndex;\n        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n            hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n                viewport,\n            });\n        }\n        else {\n            if (representationData.Labelmap) {\n                hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {\n                    viewport,\n                    searchRadius: this.configuration.searchRadius,\n                });\n            }\n            else if (representationData.Contour) {\n                hoveredSegmentIndex =\n                    getHoveredContourSegmentationAnnotation(segmentationId);\n            }\n            else if (representationData.Surface) {\n            }\n        }\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n}\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass SphereScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n                ERASE_INSIDE: eraseInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                toolGroupId: this.toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            const { representationData } = getSegmentation(segmentationId);\n            const editData = this.getEditData({\n                viewport,\n                representationData,\n                segmentsLocked,\n                segmentationId,\n            });\n            this.editData = {\n                ...this.editData,\n                ...editData,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import { cache, utilities as csUtils } from '@cornerstonejs/core';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { getSegmentation } from '../../../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateImageVolume from '../../../../utilities/segmentation/getOrCreateImageVolume';\nexport default {\n    [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: (data) => {\n        const { operationData, viewport } = data;\n        let referencedImageIds;\n        if (viewport) {\n            referencedImageIds = viewport.getImageIds();\n            const isValidVolumeForSphere = csUtils.isValidVolume(referencedImageIds);\n            if (!isValidVolumeForSphere) {\n                throw new Error('Volume is not reconstructable for sphere manipulation');\n            }\n        }\n        else {\n            const segmentation = getSegmentation(operationData.segmentationId);\n            const imageIds = segmentation.representationData\n                .Labelmap.imageIds;\n            referencedImageIds = imageIds.map((imageId) => {\n                const image = cache.getImage(imageId);\n                return image.referencedImageId;\n            });\n        }\n        const imageVolume = getOrCreateImageVolume(referencedImageIds);\n        if (!imageVolume) {\n            throw new Error('Failed to create or get image volume');\n        }\n        operationData.imageVoxelManager = imageVolume.voxelManager;\n        operationData.imageData = imageVolume.imageData;\n    },\n};\n","import { utilities, cache } from '@cornerstonejs/core';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getOrCreateSegmentationVolume from '../../../../utilities/segmentation/getOrCreateSegmentationVolume';\nexport default {\n    [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: (data) => {\n        const { operationData, viewport } = data;\n        const { segmentationId, imageIds: segImageIds } = operationData;\n        const referencedImageIds = viewport\n            ? viewport.getImageIds()\n            : segImageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n        const isValidVolumeForSphere = utilities.isValidVolume(referencedImageIds);\n        if (!isValidVolumeForSphere) {\n            throw new Error('Volume is not reconstructable for sphere manipulation');\n        }\n        const segVolume = getOrCreateSegmentationVolume(segmentationId);\n        if (!segVolume) {\n            return;\n        }\n        operationData.segmentationVoxelManager = segVolume.voxelManager;\n        operationData.segmentationImageData = segVolume.imageData;\n        return;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getCanvasEllipseCorners, precalculatePointInEllipse, } from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst { transformWorldToIndex, isEqual } = csUtils;\nconst initializeCircle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const [topLeftCanvas, bottomRightCanvas] = getCanvasEllipseCorners(canvasCoordinates);\n        const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n        const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n        const circleCornersIJK = points.map((world) => {\n            return transformWorldToIndex(segmentationImageData, world);\n        });\n        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n        operationData.isInObject = createPointInEllipse({\n            topLeftWorld,\n            bottomRightWorld,\n            center,\n        });\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInEllipse(worldInfo) {\n    const { topLeftWorld, bottomRightWorld, center } = worldInfo;\n    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n    const radius = Math.max(xRadius, yRadius, zRadius);\n    if (isEqual(xRadius, radius) &&\n        isEqual(yRadius, radius) &&\n        isEqual(zRadius, radius)) {\n        const sphereObj = {\n            center,\n            radius,\n            radius2: radius * radius,\n        };\n        return (pointLPS) => pointInSphere(sphereObj, pointLPS);\n    }\n    const ellipseObj = {\n        center: center,\n        xRadius,\n        yRadius,\n        zRadius,\n    };\n    const { precalculated } = precalculatePointInEllipse(ellipseObj, {});\n    return precalculated;\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n    throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse as createEllipseInPoint, };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK, getBoundingBoxAroundShapeWorld, } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isAxisAlignedRectangle } from '../../../utilities/rectangleROITool/isAxisAlignedRectangle';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nconst { transformWorldToIndex } = csUtils;\nconst initializeRectangle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);\n        operationData.isInObject = pointInShapeFn;\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInRectangle(viewport, points, segmentationImageData) {\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(segmentationImageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());\n    const isStackViewport = viewport instanceof StackViewport;\n    const isAligned = isStackViewport || isAxisAlignedRectangle(rectangleCornersIJK);\n    const direction = segmentationImageData.getDirection();\n    const spacing = segmentationImageData.getSpacing();\n    const { viewPlaneNormal } = viewport.getCamera();\n    const EPS = csUtils.getSpacingInNormalDirection({\n        direction,\n        spacing,\n    }, viewPlaneNormal);\n    const pointsBoundsLPS = getBoundingBoxAroundShapeWorld(points);\n    let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;\n    xMin -= EPS;\n    xMax += EPS;\n    yMin -= EPS;\n    yMax += EPS;\n    zMin -= EPS;\n    zMax += EPS;\n    const pointInShapeFn = isAligned\n        ? () => true\n        : (pointLPS) => {\n            const [x, y, z] = pointLPS;\n            const xInside = x >= xMin && x <= xMax;\n            const yInside = y >= yMin && y <= yMax;\n            const zInside = z >= zMin && z <= zMax;\n            return xInside && yInside && zInside;\n        };\n    return { boundsIJK, pointInShapeFn };\n}\nconst RECTANGLE_STRATEGY = new BrushStrategy('Rectangle', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy('RectangleThreshold', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;\nconst thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;\nexport { RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, fillInsideRectangle, thresholdInsideRectangle, };\n","export var ContourWindingDirection;\n(function (ContourWindingDirection) {\n    ContourWindingDirection[ContourWindingDirection[\"CounterClockwise\"] = -1] = \"CounterClockwise\";\n    ContourWindingDirection[ContourWindingDirection[\"Unknown\"] = 0] = \"Unknown\";\n    ContourWindingDirection[ContourWindingDirection[\"Clockwise\"] = 1] = \"Clockwise\";\n})(ContourWindingDirection || (ContourWindingDirection = {}));\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { ChangeTypes } from '../enums';\nexport default class AnnotationMultiSlice {\n    static setStartRange(viewport, annotation, startRange = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, startRange);\n    }\n    static setEndRange(viewport, annotation, endRange = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, undefined, endRange);\n    }\n    static setRange(viewport, annotation, startRange, endRange) {\n        const { metadata } = annotation;\n        if (startRange === undefined) {\n            startRange = metadata.sliceIndex < endRange ? metadata.sliceIndex : 0;\n            if (endRange === undefined) {\n                endRange = viewport.getNumberOfSlices() - 1;\n            }\n        }\n        const rangeEndSliceIndex = viewport.getSliceIndexForImage(metadata.multiSliceReference);\n        if (endRange === undefined) {\n            endRange =\n                rangeEndSliceIndex >= startRange\n                    ? rangeEndSliceIndex\n                    : viewport.getNumberOfSlices() - 1;\n        }\n        endRange = Math.max(startRange, endRange);\n        metadata.sliceIndex = Math.min(startRange, endRange);\n        metadata.referencedImageId = viewport.getCurrentImageId(metadata.sliceIndex);\n        metadata.referencedImageURI = undefined;\n        if (endRange === metadata.sliceIndex) {\n            metadata.multiSliceReference = undefined;\n        }\n        else if (endRange !== metadata.multiSliceReference?.sliceIndex) {\n            metadata.multiSliceReference = {\n                referencedImageId: viewport.getCurrentImageId(endRange),\n                sliceIndex: endRange,\n            };\n        }\n        const eventDetail = {\n            viewportId: viewport.id,\n            renderingEngineId: viewport.renderingEngineId,\n            changeType: ChangeTypes.MetadataReferenceModified,\n            annotation,\n        };\n        triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n        this.setViewportFrameRange(viewport, metadata);\n    }\n    static setSingle(viewport, annotation, current = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, current, current);\n    }\n    static getFrameRange(annotation) {\n        const { metadata } = annotation;\n        const { sliceIndex, multiSliceReference } = metadata;\n        const rangeEndSliceIndex = multiSliceReference?.sliceIndex;\n        return rangeEndSliceIndex\n            ? [sliceIndex + 1, rangeEndSliceIndex + 1]\n            : sliceIndex + 1;\n    }\n    static getFrameRangeStr(annotation) {\n        const range = this.getFrameRange(annotation);\n        return Array.isArray(range) ? `${range[0]}-${range[1]}` : String(range);\n    }\n    static setViewportFrameRange(viewport, specifier) {\n        if (viewport.setFrameRange && specifier.multiSliceReference?.sliceIndex) {\n            viewport.setFrameRange(specifier.sliceIndex + 1, specifier.multiSliceReference.sliceIndex + 1);\n        }\n    }\n}\n","import { utilities, BaseVolumeViewport, StackViewport, cache, metaData, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nfunction annotationHydration(viewport, toolName, worldPoints, options) {\n    const viewReference = viewport.getViewReference();\n    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n    const annotation = {\n        annotationUID: options?.annotationUID || utilities.uuidv4(),\n        data: {\n            handles: {\n                points: worldPoints,\n            },\n        },\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            toolName,\n            viewPlaneNormal,\n            FrameOfReferenceUID,\n            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),\n            ...options,\n        },\n    };\n    addAnnotation(annotation, viewport.element);\n    return annotation;\n}\nfunction getReferencedImageId(viewport, worldPos, viewPlaneNormal) {\n    let referencedImageId;\n    if (viewport instanceof StackViewport) {\n        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);\n    }\n    else if (viewport instanceof BaseVolumeViewport) {\n        const targetId = getTargetId(viewport);\n        const volumeId = utilities.getVolumeId(targetId);\n        const imageVolume = cache.getVolume(volumeId);\n        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n    }\n    else {\n        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');\n    }\n    return referencedImageId;\n}\nfunction getTargetId(viewport) {\n    const targetId = viewport.getViewReferenceId?.();\n    if (targetId) {\n        return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n        return `volumeId:${getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n}\nfunction getTargetVolumeId(viewport) {\n    const actorEntries = viewport.getActors();\n    if (!actorEntries) {\n        return;\n    }\n    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n}\nfunction getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {\n    const imageIds = viewport.getImageIds();\n    if (!imageIds || !imageIds.length) {\n        return;\n    }\n    const distanceImagePairs = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);\n        return { imageId, distance };\n    });\n    distanceImagePairs.sort((a, b) => a.distance - b.distance);\n    return distanceImagePairs[0].imageId;\n}\nfunction calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {\n    const dir = vec3.create();\n    vec3.sub(dir, worldPos, ImagePositionPatient);\n    const dot = vec3.dot(dir, viewPlaneNormal);\n    return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {\n    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n    if (sliceNormalIndex === -1) {\n        throw new Error('3D bounding boxes not supported in an oblique plane');\n    }\n    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n    return boundsIJK;\n}\nexport default extend2DBoundingBoxInViewAxis;\n","import { CONSTANTS } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nfunction calculateBoundingBox(points, dimensions, isWorld = false) {\n    let xMin = Infinity;\n    let xMax = isWorld ? -Infinity : 0;\n    let yMin = Infinity;\n    let yMax = isWorld ? -Infinity : 0;\n    let zMin = Infinity;\n    let zMax = isWorld ? -Infinity : 0;\n    const is3D = points[0]?.length === 3;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        xMin = Math.min(p[0], xMin);\n        xMax = Math.max(p[0], xMax);\n        yMin = Math.min(p[1], yMin);\n        yMax = Math.max(p[1], yMax);\n        if (is3D) {\n            zMin = Math.min(p[2] ?? zMin, zMin);\n            zMax = Math.max(p[2] ?? zMax, zMax);\n        }\n    }\n    if (dimensions) {\n        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);\n        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);\n        if (is3D && dimensions.length === 3) {\n            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);\n        }\n    }\n    else if (!isWorld) {\n        xMin = Math.max(0, xMin);\n        xMax = Math.min(Infinity, xMax);\n        yMin = Math.max(0, yMin);\n        yMax = Math.min(Infinity, yMax);\n        if (is3D) {\n            zMin = Math.max(0, zMin);\n            zMax = Math.min(Infinity, zMax);\n        }\n    }\n    return is3D\n        ? [\n            [xMin, xMax],\n            [yMin, yMax],\n            [zMin, zMax],\n        ]\n        : [[xMin, xMax], [yMin, yMax], null];\n}\nexport function getBoundingBoxAroundShapeIJK(points, dimensions) {\n    return calculateBoundingBox(points, dimensions, false);\n}\nexport function getBoundingBoxAroundShapeWorld(points, clipBounds) {\n    return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\nexport default function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {\n    if (typeof calibrationOrScale === 'number') {\n        calibrationOrScale = {\n            type: Enums.CalibrationTypes.USER,\n            scale: calibrationOrScale,\n        };\n    }\n    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n    const viewports = renderingEngine.getStackViewports();\n    viewports.forEach((viewport) => {\n        const imageIds = viewport.getImageIds();\n        if (imageIds.includes(imageId)) {\n            viewport.calibrateSpacing(imageId);\n        }\n    });\n}\n","var Events;\n(function (Events) {\n    Events[\"CLIP_STOPPED\"] = \"CORNERSTONE_CINE_TOOL_STOPPED\";\n    Events[\"CLIP_STARTED\"] = \"CORNERSTONE_CINE_TOOL_STARTED\";\n})(Events || (Events = {}));\nexport default Events;\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, getEnabledElement, StackViewport, VideoViewport, VolumeViewport, cache, BaseVolumeViewport, Enums, } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\nfunction playClip(element, playClipOptions) {\n    let playClipTimeouts;\n    let playClipIsTimeVarying;\n    if (element === undefined) {\n        throw new Error('playClip: element must not be undefined');\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('playClip: element must be a valid Cornerstone enabled element');\n    }\n    if (!playClipOptions) {\n        playClipOptions = {};\n    }\n    playClipOptions.dynamicCineEnabled =\n        playClipOptions.dynamicCineEnabled ?? true;\n    const { viewport } = enabledElement;\n    const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n    let playClipData = getToolState(element);\n    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;\n    if (isDynamicCinePlaying) {\n        _stopDynamicVolumeCine(element);\n    }\n    if (!playClipData) {\n        playClipData = {\n            intervalId: undefined,\n            framesPerSecond: 30,\n            lastFrameTimeStamp: undefined,\n            ignoreFrameTimeVector: false,\n            usingFrameTimeVector: false,\n            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n            reverse: playClipOptions.reverse ?? false,\n            loop: playClipOptions.loop ?? true,\n            bounce: playClipOptions.bounce ?? false,\n        };\n        addToolState(element, playClipData);\n    }\n    else {\n        _stopClip(element, {\n            stopDynamicCine: !isDynamicCinePlaying,\n            viewportId: viewport.id,\n        });\n    }\n    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n    if (playClipOptions.framesPerSecond < 0 ||\n        playClipOptions.framesPerSecond > 0) {\n        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n        playClipData.reverse = playClipData.framesPerSecond < 0;\n        playClipData.ignoreFrameTimeVector = true;\n    }\n    if (playClipData.ignoreFrameTimeVector !== true &&\n        playClipData.frameTimeVector &&\n        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n        playClipContext.frameTimeVectorEnabled) {\n        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);\n        playClipTimeouts = timeouts;\n        playClipIsTimeVarying = isTimeVarying;\n    }\n    if (playClipOptions.bounce !== undefined) {\n        playClipData.bounce = playClipOptions.bounce;\n    }\n    const playClipAction = () => {\n        const { numScrollSteps, currentStepIndex } = playClipContext;\n        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n        const outOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;\n        if (outOfRange) {\n            if (playClipData.bounce) {\n                playClipData.reverse = !playClipData.reverse;\n                newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n                newStepIndex = Math.max(0, Math.min(numScrollSteps - 1, newStepIndex));\n            }\n            else if (!playClipData.loop) {\n                _stopClip(element, {\n                    stopDynamicCine: !isDynamicCinePlaying,\n                    viewportId: viewport.id,\n                });\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n                return;\n            }\n            else {\n                newStepIndex = playClipData.reverse ? numScrollSteps - 1 : 0;\n            }\n        }\n        const delta = newStepIndex - currentStepIndex;\n        if (delta) {\n            try {\n                playClipContext.scroll(delta);\n            }\n            catch (e) {\n                console.warn('Play clip not scrolling', e);\n                _stopClipWithData(playClipData);\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n            }\n        }\n    };\n    if (isDynamicCinePlaying) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume) {\n            dynamicVolumesPlayingMap.set(volume.volumeId, element);\n        }\n    }\n    if (playClipContext.play) {\n        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);\n    }\n    else if (playClipTimeouts &&\n        playClipTimeouts.length > 0 &&\n        playClipIsTimeVarying) {\n        playClipData.usingFrameTimeVector = true;\n        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {\n            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);\n            playClipAction();\n        }, 0);\n    }\n    else {\n        playClipData.usingFrameTimeVector = false;\n        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));\n    }\n    const eventDetail = {\n        element,\n    };\n    triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\nfunction stopClip(element, options = {}) {\n    _stopClip(element, {\n        stopDynamicCine: true,\n        ...options,\n    });\n}\nfunction _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {\n    const { stopDynamicCine, viewportId } = options;\n    const enabledElement = getEnabledElement(element);\n    let toolState;\n    const viewport = enabledElement?.viewport;\n    if (!enabledElement) {\n        if (viewportId) {\n            toolState = getToolStateByViewportId(viewportId);\n        }\n        else {\n            return;\n        }\n    }\n    else {\n        const { viewport } = enabledElement;\n        toolState = getToolState(viewport.element);\n    }\n    if (toolState) {\n        _stopClipWithData(toolState);\n    }\n    if (viewport instanceof VideoViewport) {\n        viewport.pause();\n    }\n    else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n        _stopDynamicVolumeCine(element);\n    }\n}\nfunction _stopDynamicVolumeCine(element) {\n    const { viewport } = getEnabledElement(element);\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume?.isDynamicVolume()) {\n            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n            dynamicVolumesPlayingMap.delete(volume.volumeId);\n            if (dynamicCineElement && dynamicCineElement !== element) {\n                stopClip(dynamicCineElement);\n            }\n        }\n    }\n}\nfunction _getPlayClipTimeouts(vector, speed) {\n    let i;\n    let sample;\n    let delay;\n    let sum = 0;\n    const limit = vector.length;\n    const timeouts = [];\n    let isTimeVarying = false;\n    if (typeof speed !== 'number' || speed <= 0) {\n        speed = 1;\n    }\n    for (i = 1; i < limit; i++) {\n        delay = (Number(vector[i]) / speed) | 0;\n        timeouts.push(delay);\n        if (i === 1) {\n            sample = delay;\n        }\n        else if (delay !== sample) {\n            isTimeVarying = true;\n        }\n        sum += delay;\n    }\n    if (timeouts.length > 0) {\n        if (isTimeVarying) {\n            delay = (sum / timeouts.length) | 0;\n        }\n        else {\n            delay = timeouts[0];\n        }\n        timeouts.push(delay);\n    }\n    return { timeouts, isTimeVarying };\n}\nfunction _stopClipWithData(playClipData) {\n    const id = playClipData.intervalId;\n    if (typeof id !== 'undefined') {\n        playClipData.intervalId = undefined;\n        if (playClipData.usingFrameTimeVector) {\n            clearTimeout(id);\n        }\n        else {\n            clearInterval(id);\n        }\n    }\n}\nfunction _getVolumeFromViewport(viewport) {\n    if (!(viewport instanceof VolumeViewport)) {\n        return undefined;\n    }\n    const volumeIds = viewport.getAllVolumeIds();\n    if (!volumeIds?.length) {\n        return undefined;\n    }\n    const dynamicVolumeId = volumeIds.find((volumeId) => cache.getVolume(volumeId)?.isDynamicVolume());\n    const volumeId = dynamicVolumeId ?? volumeIds[0];\n    return cache.getVolume(volumeId);\n}\nfunction _createStackViewportCinePlayContext(viewport, waitForRendered) {\n    const imageIds = viewport.getImageIds();\n    return {\n        get numScrollSteps() {\n            return imageIds.length;\n        },\n        get currentStepIndex() {\n            return viewport.getTargetImageIdIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n    };\n}\nfunction _createVideoViewportCinePlayContext(viewport, waitForRendered) {\n    return {\n        get numScrollSteps() {\n            return viewport.getNumberOfSlices();\n        },\n        get currentStepIndex() {\n            return viewport.getSliceIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n        play(fps) {\n            if (fps) {\n                viewport.setPlaybackRate(fps / 24);\n            }\n            viewport.play();\n            return viewport.getFrameRate();\n        },\n    };\n}\nfunction _createVolumeViewportCinePlayContext(viewport, volume) {\n    const { volumeId } = volume;\n    const cachedScrollInfo = {\n        viewPlaneNormal: vec3.create(),\n        scrollInfo: null,\n    };\n    const getScrollInfo = () => {\n        const camera = viewport.getCamera();\n        const updateCache = !cachedScrollInfo.scrollInfo ||\n            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n        if (updateCache) {\n            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n            cachedScrollInfo.scrollInfo = scrollInfo;\n        }\n        return cachedScrollInfo.scrollInfo;\n    };\n    return {\n        get numScrollSteps() {\n            return getScrollInfo().numScrollSteps;\n        },\n        get currentStepIndex() {\n            return getScrollInfo().currentStepIndex;\n        },\n        get frameTimeVectorEnabled() {\n            const camera = viewport.getCamera();\n            const volumeViewPlaneNormal = volume.direction\n                .slice(6, 9)\n                .map((x) => -x);\n            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n            return glMatrix.equals(dot, 1);\n        },\n        scroll(delta) {\n            getScrollInfo().currentStepIndex += delta;\n            csUtils.scroll(viewport, { delta });\n        },\n    };\n}\nfunction _createDynamicVolumeViewportCinePlayContext(volume) {\n    return {\n        get numScrollSteps() {\n            return volume.numDimensionGroups;\n        },\n        get currentStepIndex() {\n            return volume.dimensionGroupNumber - 1;\n        },\n        get frameTimeVectorEnabled() {\n            return false;\n        },\n        scroll(delta) {\n            volume.scroll(delta);\n        },\n    };\n}\nfunction _createCinePlayContext(viewport, playClipOptions) {\n    if (viewport instanceof StackViewport) {\n        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n            return _createDynamicVolumeViewportCinePlayContext(volume);\n        }\n        return _createVolumeViewportCinePlayContext(viewport, volume);\n    }\n    if (viewport instanceof VideoViewport) {\n        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    throw new Error('Unknown viewport type');\n}\nexport { playClip, stopClip };\n","import { getEnabledElement } from '@cornerstonejs/core';\nconst state = {};\nfunction addToolState(element, data) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    state[viewportId] = data;\n}\nfunction getToolState(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    return state[viewportId];\n}\nfunction getToolStateByViewportId(viewportId) {\n    return state[viewportId];\n}\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function addContourSegmentationAnnotation(annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    if (!annotation.data.segmentation) {\n        throw new Error('addContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation.representationData.Contour) {\n        segmentation.representationData.Contour = { annotationUIDsMap: new Map() };\n    }\n    let { annotationUIDsMap } = segmentation.representationData.Contour;\n    if (!annotationUIDsMap) {\n        annotationUIDsMap = new Map();\n    }\n    let annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        annotationsUIDsSet = new Set();\n        annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n    }\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));\n}\n","export default function areSameSegment(firstAnnotation, secondAnnotation) {\n    const { segmentation: firstSegmentation } = firstAnnotation.data;\n    const { segmentation: secondSegmentation } = secondAnnotation.data;\n    return (firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n        firstSegmentation.segmentIndex === secondSegmentation.segmentIndex);\n}\n","import { getAnnotation } from '../../stateManagement/annotation/annotationState';\nimport getViewportsForAnnotation from '../getViewportsForAnnotation';\nimport { convertContourPolylineToCanvasSpace, checkIntersection, createPolylineHole, combinePolylines, } from './sharedOperations';\nexport async function contourSegmentationOperation(sourceAnnotationOrUID, targetAnnotationOrUID, viewport, contourHoleProcessingEnabled = true) {\n    const sourceAnnotation = typeof sourceAnnotationOrUID === 'string'\n        ? getAnnotation(sourceAnnotationOrUID)\n        : sourceAnnotationOrUID;\n    const targetAnnotation = typeof targetAnnotationOrUID === 'string'\n        ? getAnnotation(targetAnnotationOrUID)\n        : targetAnnotationOrUID;\n    if (!sourceAnnotation || !targetAnnotation) {\n        throw new Error('Both source and target annotations must be valid');\n    }\n    if (!viewport) {\n        viewport = getViewportFromAnnotation(sourceAnnotation);\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n    const intersectionInfo = checkIntersection(sourcePolyline, targetPolyline);\n    if (!intersectionInfo.hasIntersection) {\n        console.warn('No intersection found between the two annotations');\n        return;\n    }\n    if (intersectionInfo.isContourHole) {\n        if (!contourHoleProcessingEnabled) {\n            console.warn('Hole processing is disabled');\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction getViewportFromAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    if (!viewports.length) {\n        throw new Error('No viewport found for the annotation');\n    }\n    return viewports[0];\n}\n","import * as math from '../math';\nfunction findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations) {\n    const intersectingContours = [];\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n        const targetAnnotation = contourSegmentationAnnotations[i];\n        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n        const targetAABB = math.polyline.getAABB(targetPolyline);\n        const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n        if (!aabbIntersect) {\n            continue;\n        }\n        const lineSegmentsIntersect = math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n        const isContourHole = !lineSegmentsIntersect &&\n            math.polyline.containsPoints(targetPolyline, sourcePolyline);\n        if (lineSegmentsIntersect || isContourHole) {\n            intersectingContours.push({\n                targetAnnotation,\n                targetPolyline,\n                isContourHole,\n            });\n        }\n    }\n    return intersectingContours;\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport { findAllIntersectingContours };\n","import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation, removeAnnotation } from '../../stateManagement';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default function convertContourSegmentationAnnotation(annotation) {\n    const { polyline } = annotation.data?.contour || {};\n    if (!polyline || polyline.length < 3) {\n        console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n        return;\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n    const startPointWorld = polyline[0];\n    const endPointWorld = polyline[polyline.length - 1];\n    const newAnnotation = {\n        metadata: {\n            ...annotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: annotation.metadata.originalToolName || annotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: annotation.data.handles.textBox\n                    ? { ...annotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                ...annotation.data.contour,\n            },\n            spline: annotation.data.spline,\n            segmentation: {\n                ...annotation.data.segmentation,\n            },\n        },\n        annotationUID: utilities.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: annotation.interpolationUID,\n        interpolationCompleted: annotation.interpolationCompleted,\n    };\n    addAnnotation(newAnnotation, annotation.metadata.FrameOfReferenceUID);\n    addContourSegmentationAnnotation(newAnnotation);\n    return newAnnotation;\n}\n","export default function isContourSegmentationAnnotation(annotation) {\n    return !!annotation.data?.segmentation;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation } from '../../stateManagement';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function addPolylinesToSegmentation(viewport, segmentationId, polylines, segmentIndex) {\n    const annotationUIDsMap = new Map();\n    polylines.forEach((polyline) => {\n        if (polyline.length < 3) {\n            return;\n        }\n        const contourSegmentationAnnotation = {\n            annotationUID: utilities.uuidv4(),\n            data: {\n                contour: {\n                    closed: true,\n                    polyline,\n                },\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n                handles: {},\n            },\n            handles: {},\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\n                ...viewport.getViewReference(),\n            },\n        };\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\n        const currentSet = annotationUIDsMap?.get(segmentIndex) || new Set();\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\n        annotationUIDsMap.set(segmentIndex, currentSet);\n    });\n    return annotationUIDsMap;\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { convertContourPolylineToCanvasSpace, convertContourPolylineToWorld, } from './sharedOperations';\nimport { subtractPolylineSets, unifyPolylineSets } from './unifyPolylineSets';\nimport addPolylinesToSegmentation from './addPolylinesToSegmentation';\nfunction getPolylines(contourRepresentationData, segmentIndex) {\n    const polylines = [];\n    const { annotationUIDsMap } = contourRepresentationData;\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    for (const annotationUID of annotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        const { polyline } = annotation.data\n            .contour;\n        polylines.push(polyline);\n    }\n    return polylines;\n}\nfunction extractPolylines(viewport, segmentation, segmentIndex1, segmentIndex2) {\n    if (!segmentation) {\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    if (!annotationUIDsMap.get(segmentIndex1)) {\n        return;\n    }\n    if (!annotationUIDsMap.get(segmentIndex2)) {\n        return;\n    }\n    const polyLines1 = getPolylines(contourRepresentationData, segmentIndex1);\n    const polyLines2 = getPolylines(contourRepresentationData, segmentIndex2);\n    const polyLinesCanvas1 = polyLines1.map((polyline) => convertContourPolylineToCanvasSpace(polyline, viewport));\n    const polyLinesCanvas2 = polyLines2.map((polyline) => convertContourPolylineToCanvasSpace(polyline, viewport));\n    return { polyLinesCanvas1, polyLinesCanvas2 };\n}\nexport function addition(viewport, segmentation, segmentIndex1, segmentIndex2, { name, segmentIndex, color }) {\n    const { polyLinesCanvas1, polyLinesCanvas2 } = extractPolylines(viewport, segmentation, segmentIndex1, segmentIndex2) ||\n        {};\n    if (!polyLinesCanvas1 || polyLinesCanvas2) {\n        return;\n    }\n    const polylinesMerged = unifyPolylineSets(polyLinesCanvas1, polyLinesCanvas2);\n    const polyLinesWorld = polylinesMerged.map((polyline) => convertContourPolylineToWorld(polyline, viewport));\n    const annotationUIDsMapNew = addPolylinesToSegmentation(viewport, segmentation.segmentationId, polyLinesWorld, segmentIndex);\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    annotationUIDsMap.set(segmentIndex, annotationUIDsMapNew.get(segmentIndex));\n}\nexport function subtraction(viewport, segmentation, segmentIndex1, segmentIndex2, { name, segmentIndex, color }) {\n    const { polyLinesCanvas1, polyLinesCanvas2 } = extractPolylines(viewport, segmentation, segmentIndex1, segmentIndex2) ||\n        {};\n    if (!polyLinesCanvas1 || polyLinesCanvas2) {\n        return;\n    }\n    const polylinesMerged = subtractPolylineSets(polyLinesCanvas1, polyLinesCanvas2);\n    const polyLinesWorld = polylinesMerged.map((polyline) => convertContourPolylineToWorld(polyline, viewport));\n    const annotationUIDsMapNew = addPolylinesToSegmentation(viewport, segmentation.segmentationId, polyLinesWorld, segmentIndex);\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    annotationUIDsMap.set(segmentIndex, annotationUIDsMapNew.get(segmentIndex));\n}\n","import { utilities as csUtils, getEnabledElement } from '@cornerstonejs/core';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport updateContourPolyline from '../contours/updateContourPolyline';\nimport { addAnnotation, removeAnnotation, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../viewportFilters';\nimport { hasToolByName, hasTool } from '../../store/addTool';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nfunction processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours) {\n    const holeOperations = intersectingContours.filter((item) => item.isContourHole);\n    const mergeOperations = intersectingContours.filter((item) => !item.isContourHole);\n    if (holeOperations.length > 0) {\n        const primaryHoleTarget = holeOperations[0];\n        createPolylineHole(viewport, primaryHoleTarget.targetAnnotation, sourceAnnotation);\n        updateViewportsForAnnotations(viewport, [\n            sourceAnnotation,\n            primaryHoleTarget.targetAnnotation,\n        ]);\n        return;\n    }\n    if (mergeOperations.length === 0) {\n        return;\n    }\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone. Cannot process multiple intersections.`);\n        return;\n    }\n    processSequentialIntersections(viewport, sourceAnnotation, sourcePolyline, mergeOperations);\n}\nfunction processSequentialIntersections(viewport, sourceAnnotation, sourcePolyline, mergeOperations) {\n    const { element } = viewport;\n    const allAnnotationsToRemove = [sourceAnnotation];\n    const allResultPolylines = [];\n    const allHoles = [];\n    mergeOperations.forEach(({ targetAnnotation }) => {\n        const holes = getContourHolesData(viewport, targetAnnotation);\n        allHoles.push(...holes);\n        allAnnotationsToRemove.push(targetAnnotation);\n    });\n    const sourceStartPoint = sourcePolyline[0];\n    const shouldMerge = mergeOperations.some(({ targetPolyline }) => math.polyline.containsPoint(targetPolyline, sourceStartPoint));\n    if (shouldMerge) {\n        let resultPolyline = sourcePolyline;\n        mergeOperations.forEach(({ targetPolyline }) => {\n            resultPolyline = math.polyline.mergePolylines(resultPolyline, targetPolyline);\n        });\n        allResultPolylines.push(resultPolyline);\n    }\n    else {\n        mergeOperations.forEach(({ targetPolyline }) => {\n            const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n            allResultPolylines.push(...subtractedPolylines);\n        });\n    }\n    allAnnotationsToRemove.forEach((annotation) => {\n        removeAnnotation(annotation.annotationUID);\n        removeContourSegmentationAnnotation(annotation);\n    });\n    allHoles.forEach((holeData) => clearParentAnnotation(holeData.annotation));\n    const baseAnnotation = mergeOperations[0].targetAnnotation;\n    const newAnnotations = [];\n    allResultPolylines.forEach((polyline) => {\n        if (!polyline || polyline.length < 3) {\n            console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n            return;\n        }\n        const newAnnotation = createNewAnnotationFromPolyline(viewport, baseAnnotation, polyline);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        newAnnotations.push(newAnnotation);\n    });\n    reassignHolesToNewAnnotations(viewport, allHoles, newAnnotations);\n    updateViewportsForAnnotations(viewport, allAnnotationsToRemove);\n}\nfunction createNewAnnotationFromPolyline(viewport, baseAnnotation, polyline) {\n    const startPointWorld = viewport.canvasToWorld(polyline[0]);\n    const endPointWorld = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation = {\n        metadata: {\n            ...baseAnnotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: baseAnnotation.metadata.originalToolName ||\n                baseAnnotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: baseAnnotation.data.handles.textBox\n                    ? { ...baseAnnotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                polyline: [],\n                closed: true,\n            },\n            spline: baseAnnotation.data.spline,\n            segmentation: {\n                ...baseAnnotation.data.segmentation,\n            },\n        },\n        annotationUID: csUtils.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: baseAnnotation.interpolationUID,\n        interpolationCompleted: baseAnnotation.interpolationCompleted,\n    };\n    updateContourPolyline(newAnnotation, {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    return newAnnotation;\n}\nfunction reassignHolesToNewAnnotations(viewport, holes, newAnnotations) {\n    holes.forEach((holeData) => {\n        const parentAnnotation = newAnnotations.find((annotation) => {\n            const parentPolyline = convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport);\n            return math.polyline.containsPoints(parentPolyline, holeData.polyline);\n        });\n        if (parentAnnotation) {\n            addChildAnnotation(parentAnnotation, holeData.annotation);\n        }\n    });\n}\nfunction getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const contourHoleAnnotation = holeAnnotation;\n        const polyline = convertContourPolylineToCanvasSpace(contourHoleAnnotation.data.contour.polyline, viewport);\n        return { annotation: contourHoleAnnotation, polyline };\n    });\n}\nfunction createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolylineCanvas = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolylineCanvas,\n        closed: holeContour.closed,\n        targetWindingDirection: targetAnnotation.data.contour.windingDirection ===\n            ContourWindingDirection.Clockwise\n            ? ContourWindingDirection.CounterClockwise\n            : ContourWindingDirection.Clockwise,\n    }, viewport);\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nfunction updateViewportsForAnnotations(viewport, annotations) {\n    const { element } = viewport;\n    const updatedToolNames = new Set([DEFAULT_CONTOUR_SEG_TOOL_NAME]);\n    annotations.forEach((annotation) => {\n        updatedToolNames.add(annotation.metadata.toolName);\n    });\n    for (const toolName of updatedToolNames.values()) {\n        if (hasToolByName(toolName)) {\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        }\n    }\n}\nexport { processMultipleIntersections };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function removeContourSegmentationAnnotation(annotation) {\n    if (!annotation.data.segmentation) {\n        throw new Error('removeContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};\n    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        return;\n    }\n    annotationsUIDsSet.delete(annotation.annotationUID);\n    if (!annotationsUIDsSet.size) {\n        annotationUIDsMap.delete(segmentIndex);\n    }\n}\n","import { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport updateContourPolyline from '../contours/updateContourPolyline';\nimport { addAnnotation, removeAnnotation, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../viewportFilters';\nimport { hasToolByName } from '../../store/addTool';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport function convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function convertContourPolylineToWorld(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.canvasToWorld(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function checkIntersection(sourcePolyline, targetPolyline) {\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    const targetAABB = math.polyline.getAABB(targetPolyline);\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n    if (!aabbIntersect) {\n        return { hasIntersection: false, isContourHole: false };\n    }\n    const lineSegmentsIntersect = math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n    const isContourHole = !lineSegmentsIntersect &&\n        math.polyline.containsPoints(targetPolyline, sourcePolyline);\n    const hasIntersection = lineSegmentsIntersect || isContourHole;\n    return { hasIntersection, isContourHole };\n}\nexport function getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const contourHoleAnnotation = holeAnnotation;\n        const polyline = convertContourPolylineToCanvasSpace(contourHoleAnnotation.data.contour.polyline, viewport);\n        return { annotation: contourHoleAnnotation, polyline };\n    });\n}\nexport function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolylineCanvas = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolylineCanvas,\n        closed: holeContour.closed,\n        targetWindingDirection: targetAnnotation.data.contour.windingDirection ===\n            ContourWindingDirection.Clockwise\n            ? ContourWindingDirection.CounterClockwise\n            : ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { element } = viewport;\n    updateViewportsForAnnotations(viewport, [targetAnnotation, holeAnnotation]);\n}\nexport function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone. Cannot combine polylines.`);\n        return;\n    }\n    const sourceStartPoint = sourcePolyline[0];\n    const mergePolylines = math.polyline.containsPoint(targetPolyline, sourceStartPoint);\n    const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n    const unassignedContourHolesSet = new Set(contourHolesData);\n    const reassignedContourHolesMap = new Map();\n    const assignHoleToPolyline = (parentPolyline, holeData) => {\n        let holes = reassignedContourHolesMap.get(parentPolyline);\n        if (!holes) {\n            holes = [];\n            reassignedContourHolesMap.set(parentPolyline, holes);\n        }\n        holes.push(holeData);\n        unassignedContourHolesSet.delete(holeData);\n    };\n    const newPolylines = [];\n    if (mergePolylines) {\n        const mergedPolyline = math.polyline.mergePolylines(targetPolyline, sourcePolyline);\n        newPolylines.push(mergedPolyline);\n        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));\n    }\n    else {\n        const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n        subtractedPolylines.forEach((newPolyline) => {\n            newPolylines.push(newPolyline);\n            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n                const containsHole = math.polyline.containsPoints(newPolyline, holeData.polyline);\n                if (containsHole) {\n                    assignHoleToPolyline(newPolyline, holeData);\n                }\n            });\n        });\n    }\n    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => clearParentAnnotation(contourHoleData.annotation)));\n    const { element } = viewport;\n    const { metadata, data } = targetAnnotation;\n    const { handles, segmentation } = data;\n    const { textBox } = handles;\n    removeAnnotation(sourceAnnotation.annotationUID);\n    removeAnnotation(targetAnnotation.annotationUID);\n    removeContourSegmentationAnnotation(sourceAnnotation);\n    removeContourSegmentationAnnotation(targetAnnotation);\n    const newAnnotations = [];\n    for (let i = 0; i < newPolylines.length; i++) {\n        const polyline = newPolylines[i];\n        if (!polyline || polyline.length < 3) {\n            console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n            continue;\n        }\n        const newAnnotation = createNewAnnotationFromPolyline(viewport, targetAnnotation, polyline);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        newAnnotations.push(newAnnotation);\n        reassignedContourHolesMap\n            .get(polyline)\n            ?.forEach((holeData) => addChildAnnotation(newAnnotation, holeData.annotation));\n    }\n    updateViewportsForAnnotations(viewport, [targetAnnotation, sourceAnnotation]);\n}\nexport function createNewAnnotationFromPolyline(viewport, templateAnnotation, polyline) {\n    const startPointWorld = viewport.canvasToWorld(polyline[0]);\n    const endPointWorld = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation = {\n        metadata: {\n            ...templateAnnotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: templateAnnotation.metadata.originalToolName ||\n                templateAnnotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: templateAnnotation.data.handles.textBox\n                    ? { ...templateAnnotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                polyline: [],\n                closed: true,\n            },\n            spline: templateAnnotation.data.spline,\n            segmentation: {\n                ...templateAnnotation.data.segmentation,\n            },\n        },\n        annotationUID: csUtils.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: templateAnnotation.interpolationUID,\n        interpolationCompleted: templateAnnotation.interpolationCompleted,\n    };\n    updateContourPolyline(newAnnotation, {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    return newAnnotation;\n}\nexport function updateViewportsForAnnotations(viewport, annotations) {\n    const { element } = viewport;\n    const updatedToolNames = new Set([DEFAULT_CONTOUR_SEG_TOOL_NAME]);\n    annotations.forEach((annotation) => {\n        updatedToolNames.add(annotation.metadata.toolName);\n    });\n    for (const toolName of updatedToolNames.values()) {\n        if (hasToolByName(toolName)) {\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        }\n    }\n}\n","import * as math from '../math';\nimport { checkIntersection } from './sharedOperations';\nexport function unifyPolylineSets(polylinesSetA, polylinesSetB) {\n    const result = [];\n    const processedFromA = new Set();\n    const processedFromB = new Set();\n    for (let i = 0; i < polylinesSetA.length; i++) {\n        if (processedFromA.has(i)) {\n            continue;\n        }\n        const polylineA = polylinesSetA[i];\n        let merged = false;\n        for (let j = 0; j < polylinesSetB.length; j++) {\n            if (processedFromB.has(j)) {\n                continue;\n            }\n            const polylineB = polylinesSetB[j];\n            const intersection = checkIntersection(polylineA, polylineB);\n            if (intersection.hasIntersection && !intersection.isContourHole) {\n                const mergedPolyline = math.polyline.mergePolylines(polylineA, polylineB);\n                result.push(mergedPolyline);\n                processedFromA.add(i);\n                processedFromB.add(j);\n                merged = true;\n                break;\n            }\n        }\n        if (!merged) {\n            result.push([...polylineA]);\n            processedFromA.add(i);\n        }\n    }\n    for (let j = 0; j < polylinesSetB.length; j++) {\n        if (!processedFromB.has(j)) {\n            result.push([...polylinesSetB[j]]);\n        }\n    }\n    return result;\n}\nexport function unifyMultiplePolylineSets(polylineSets) {\n    if (polylineSets.length === 0) {\n        return [];\n    }\n    if (polylineSets.length === 1) {\n        return polylineSets[0].map((polyline) => [...polyline]);\n    }\n    let result = polylineSets[0].map((polyline) => [...polyline]);\n    for (let i = 1; i < polylineSets.length; i++) {\n        result = unifyPolylineSets(result, polylineSets[i]);\n    }\n    return result;\n}\nexport function unifyAnnotationPolylines(annotationsSetA, annotationsSetB, viewport) {\n    const polylinesSetA = annotationsSetA.map((annotation) => convertPolylineToCanvasSpace(annotation.data.contour.polyline, viewport));\n    const polylinesSetB = annotationsSetB.map((annotation) => convertPolylineToCanvasSpace(annotation.data.contour.polyline, viewport));\n    return unifyPolylineSets(polylinesSetA, polylinesSetB);\n}\nfunction convertPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function subtractPolylineSets(polylinesSetA, polylinesSetB) {\n    const result = [];\n    const processedFromA = new Set();\n    for (let i = 0; i < polylinesSetA.length; i++) {\n        if (processedFromA.has(i)) {\n            continue;\n        }\n        let currentPolylines = [polylinesSetA[i]];\n        let wasSubtracted = false;\n        for (let j = 0; j < polylinesSetB.length; j++) {\n            const polylineB = polylinesSetB[j];\n            const newPolylines = [];\n            for (const currentPolyline of currentPolylines) {\n                const intersection = checkIntersection(currentPolyline, polylineB);\n                if (intersection.hasIntersection && !intersection.isContourHole) {\n                    const subtractedPolylines = math.polyline.subtractPolylines(currentPolyline, polylineB);\n                    newPolylines.push(...subtractedPolylines);\n                    wasSubtracted = true;\n                }\n                else {\n                    newPolylines.push(currentPolyline);\n                }\n            }\n            currentPolylines = newPolylines;\n        }\n        result.push(...currentPolylines);\n        processedFromA.add(i);\n    }\n    return result;\n}\nexport function subtractMultiplePolylineSets(basePolylineSet, subtractorSets) {\n    if (subtractorSets.length === 0) {\n        return basePolylineSet.map((polyline) => [...polyline]);\n    }\n    let result = basePolylineSet.map((polyline) => [...polyline]);\n    for (let i = 0; i < subtractorSets.length; i++) {\n        result = subtractPolylineSets(result, subtractorSets[i]);\n    }\n    return result;\n}\nexport function subtractAnnotationPolylines(baseAnnotations, subtractorAnnotations, viewport) {\n    const basePolylines = baseAnnotations.map((annotation) => convertPolylineToCanvasSpace(annotation.data.contour.polyline, viewport));\n    const subtractorPolylines = subtractorAnnotations.map((annotation) => convertPolylineToCanvasSpace(annotation.data.contour.polyline, viewport));\n    return subtractPolylineSets(basePolylines, subtractorPolylines);\n}\n","function calculatePerimeter(polyline, closed) {\n    let perimeter = 0;\n    for (let i = 0; i < polyline.length - 1; i++) {\n        const point1 = polyline[i];\n        const point2 = polyline[i + 1];\n        perimeter += Math.sqrt(Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2));\n    }\n    if (closed) {\n        const firstPoint = polyline[0];\n        const lastPoint = polyline[polyline.length - 1];\n        perimeter += Math.sqrt(Math.pow(lastPoint[0] - firstPoint[0], 2) +\n            Math.pow(lastPoint[1] - firstPoint[1], 2));\n    }\n    return perimeter;\n}\nexport default calculatePerimeter;\n","function findNextLink(line, lines, contourPoints) {\n    let index = -1;\n    lines.forEach((cell, i) => {\n        if (index >= 0) {\n            return;\n        }\n        if (cell.a == line.b) {\n            index = i;\n        }\n    });\n    if (index >= 0) {\n        const nextLine = lines[index];\n        lines.splice(index, 1);\n        contourPoints.push(nextLine.b);\n        if (contourPoints[0] == nextLine.b) {\n            return {\n                remainingLines: lines,\n                contourPoints,\n                type: 'CLOSED_PLANAR',\n            };\n        }\n        return findNextLink(nextLine, lines, contourPoints);\n    }\n    return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'OPEN_PLANAR',\n    };\n}\nexport function findContours(lines) {\n    if (lines.length == 0) {\n        return [];\n    }\n    const contourPoints = [];\n    const firstCell = lines.shift();\n    contourPoints.push(firstCell.a);\n    contourPoints.push(firstCell.b);\n    const result = findNextLink(firstCell, lines, contourPoints);\n    if (result.remainingLines.length == 0) {\n        return [\n            {\n                type: result.type,\n                contourPoints: result.contourPoints,\n            },\n        ];\n    }\n    else {\n        const extraContours = findContours(result.remainingLines);\n        extraContours.push({\n            type: result.type,\n            contourPoints: result.contourPoints,\n        });\n        return extraContours;\n    }\n}\nexport function findContoursFromReducedSet(lines) {\n    return findContours(lines);\n}\nexport default {\n    findContours,\n    findContoursFromReducedSet,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst { isEqual } = csUtils;\nexport default function findHandlePolylineIndex(annotation, handleIndex) {\n    const { polyline } = annotation.data.contour;\n    const { points } = annotation.data.handles;\n    const { length } = points;\n    if (handleIndex === length) {\n        return polyline.length;\n    }\n    if (handleIndex < 0) {\n        handleIndex = (handleIndex + length) % length;\n    }\n    if (handleIndex === 0) {\n        return 0;\n    }\n    const handle = points[handleIndex];\n    const index = polyline.findIndex((point) => isEqual(handle, point));\n    if (index !== -1) {\n        return index;\n    }\n    let closestDistance = Infinity;\n    return polyline.reduce((closestIndex, point, testIndex) => {\n        const distance = vec3.squaredDistance(point, handle);\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            return testIndex;\n        }\n        return closestIndex;\n    }, -1);\n}\n","import isClosed from '../math/polyline/isClosed';\nimport { getSignedArea } from '../math/polyline';\nexport default function findIslands(polylines, threshold) {\n    if (!polylines || polylines.length === 0) {\n        return [];\n    }\n    if (threshold <= 0) {\n        return [];\n    }\n    const islandIndexes = [];\n    for (let i = 0; i < polylines.length; i++) {\n        const polyline = polylines[i];\n        if (!polyline || polyline.length < 3) {\n            continue;\n        }\n        const isClosedPolyline = isClosed(polyline);\n        if (isClosedPolyline) {\n            const area = Math.abs(getSignedArea(polyline)) / 100;\n            if (area < threshold) {\n                islandIndexes.push(i);\n            }\n        }\n    }\n    return islandIndexes;\n}\n","import getContourHolesDataWorld from './getContourHolesDataWorld';\nexport default function getContourHolesDataCanvas(annotation, viewport) {\n    const worldHoleContours = getContourHolesDataWorld(annotation);\n    const canvasHoleContours = [];\n    worldHoleContours.forEach((worldHoleContour) => {\n        const numPoints = worldHoleContour.length;\n        const canvasHoleContour = new Array(numPoints);\n        for (let i = 0; i < numPoints; i++) {\n            canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n        }\n        canvasHoleContours.push(canvasHoleContour);\n    });\n    return canvasHoleContours;\n}\n","import { getAnnotation } from '../../stateManagement/annotation/annotationState';\nexport default function getContourHolesDataWorld(annotation) {\n    const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n    return childAnnotationUIDs.map((uid) => getAnnotation(uid).data.contour.polyline);\n}\n","export function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n    const points = polyData.getPoints();\n    const lines = polyData.getLines();\n    const pointsArray = new Array(points.getNumberOfPoints())\n        .fill(0)\n        .map((_, i) => points.getPoint(i).slice());\n    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n        const cell = lines.getCell(i * 3).slice();\n        return { a: cell[0], b: cell[1] };\n    });\n    if (bypass) {\n        return { points: pointsArray, lines: linesArray };\n    }\n    const newPoints = [];\n    for (const [i, pt] of pointsArray.entries()) {\n        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);\n        if (index >= 0) {\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = index;\n                }\n                if (line.b === i) {\n                    line.b = index;\n                }\n                return line;\n            });\n        }\n        else {\n            const newIndex = newPoints.length;\n            newPoints.push(pt);\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = newIndex;\n                }\n                if (line.b === i) {\n                    line.b = newIndex;\n                }\n                return line;\n            });\n        }\n    }\n    const newLines = linesArray.filter((line) => line.a !== line.b);\n    return { points: newPoints, lines: newLines };\n}\nexport default { getDeduplicatedVTKPolyDataPoints };\n","import { glMatrix, vec3 } from 'gl-matrix';\nexport default function areCoplanarContours(firstAnnotation, secondAnnotation) {\n    const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n    const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n    const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n    const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n    if (!parallelPlanes) {\n        return false;\n    }\n    const { polyline: firstPolyline } = firstAnnotation.data.contour;\n    const { polyline: secondPolyline } = secondAnnotation.data.contour;\n    const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n    const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n    return glMatrix.equals(firstDistance, secondDistance);\n}\n","const getIsPointInsidePolygon = (point, vertices) => {\n    const x = point[0];\n    const y = point[1];\n    let inside = false;\n    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n        const xi = vertices[i][0], yi = vertices[i][1];\n        const xj = vertices[j][0], yj = vertices[j][1];\n        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n    return inside;\n};\nfunction checkEnclosed(outerContour, innerContour, points) {\n    const vertices = [];\n    outerContour.contourPoints.forEach((point) => {\n        vertices.push([points[point][0], points[point][1]]);\n    });\n    let pointsNotEnclosed = 0;\n    innerContour.contourPoints.forEach((point) => {\n        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);\n        if (!result) {\n            pointsNotEnclosed++;\n        }\n    });\n    return pointsNotEnclosed === 0;\n}\nexport function processContourHoles(contours, points, useXOR = true) {\n    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');\n    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');\n    const contourWithHoles = [];\n    let contourWithoutHoles = [];\n    closedContours.forEach((contour, index) => {\n        const holes = [];\n        closedContours.forEach((hContour, hIndex) => {\n            if (index != hIndex) {\n                if (checkEnclosed(contour, hContour, points)) {\n                    holes.push(hIndex);\n                }\n            }\n        });\n        if (holes.length > 0) {\n            contourWithHoles.push({\n                contour,\n                holes,\n            });\n        }\n        else {\n            contourWithoutHoles.push(index);\n        }\n    });\n    if (useXOR) {\n        contourWithHoles.forEach((contourHoleSet) => {\n            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n            retContours.push(contourHoleSet.contour);\n            contourHoleSet.holes.forEach((holeIndex) => {\n                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n                retContours.push(closedContours[holeIndex]);\n                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n                    return contourIndex !== holeIndex;\n                });\n            });\n        });\n        contourWithoutHoles.forEach((contourIndex) => {\n            retContours.push(closedContours[contourIndex]);\n        });\n    }\n    else {\n    }\n    return retContours;\n}\nexport default { processContourHoles };\n","import getSignedArea from '../math/polyline/getSignedArea';\nimport containsPoints from '../math/polyline/containsPoints';\nimport isClosed from '../math/polyline/isClosed';\nfunction isPolygonInsidePolygon(inner, outer) {\n    return containsPoints(outer, inner);\n}\nexport default function findContourHoles(polylines) {\n    const results = [];\n    const closedPolylines = [];\n    polylines.forEach((polyline, index) => {\n        if (isClosed(polyline)) {\n            closedPolylines.push({ polyline, originalIndex: index });\n        }\n    });\n    for (let i = 0; i < closedPolylines.length; i++) {\n        const outerContour = closedPolylines[i];\n        const outerArea = Math.abs(getSignedArea(outerContour.polyline));\n        const holeIndexes = [];\n        for (let j = 0; j < closedPolylines.length; j++) {\n            if (i === j) {\n                continue;\n            }\n            const potentialHole = closedPolylines[j];\n            const holeArea = Math.abs(getSignedArea(potentialHole.polyline));\n            if (holeArea < outerArea &&\n                isPolygonInsidePolygon(potentialHole.polyline, outerContour.polyline)) {\n                holeIndexes.push(potentialHole.originalIndex);\n            }\n        }\n        if (holeIndexes.length > 0) {\n            results.push({\n                contourIndex: outerContour.originalIndex,\n                holeIndexes: holeIndexes.sort((a, b) => a - b),\n            });\n        }\n    }\n    return results.sort((a, b) => a.contourIndex - b.contourIndex);\n}\nexport { findContourHoles };\n","import { cache as cornerstoneCache, getWebWorkerManager, cache, utilities, } from '@cornerstonejs/core';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport { triggerWorkerProgress } from '../segmentation/utilsForWorker';\nimport getOrCreateSegmentationVolume from '../segmentation/getOrCreateSegmentationVolume';\nconst { Labelmap } = SegmentationRepresentations;\nasync function generateContourSetsFromLabelmap({ segmentations }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 0);\n    const { representationData, segments = [0, 1], segmentationId, } = segmentations;\n    let { volumeId: segVolumeId } = representationData[Labelmap];\n    if (!segVolumeId) {\n        const segVolume = getOrCreateSegmentationVolume(segmentationId);\n        if (segVolume) {\n            segVolumeId = segVolume.volumeId;\n        }\n    }\n    const vol = cornerstoneCache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    const voxelManager = vol.voxelManager;\n    const segScalarData = voxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segScalarData,\n        dimensions: vol.dimensions,\n        spacing: vol.imageData.getSpacing(),\n        origin: vol.imageData.getOrigin(),\n        direction: vol.imageData.getDirection(),\n    };\n    const indices = Array.isArray(segments)\n        ? segments\n            .filter((segment) => segment !== null)\n            .map((segment) => segment.segmentIndex || segment)\n        : Object.values(segments)\n            .filter((segment) => segment !== null)\n            .map((segment) => segment.segmentIndex || segment);\n    const contourSets = await getWebWorkerManager().executeTask('compute', 'generateContourSetsFromLabelmapVolume', {\n        segmentation: segmentationInfo,\n        indices,\n        mode: 'individual',\n    });\n    const refImages = vol.imageIds.map((imageId) => {\n        const refImageId = cache.getImage(imageId)?.referencedImageId;\n        return refImageId ? cache.getImage(refImageId) : undefined;\n    });\n    const refImageDataMetadata = refImages.map((image) => {\n        return utilities.getImageDataMetadata(image);\n    });\n    const processedContourSets = contourSets\n        .map((contourSet) => {\n        const segment = segments[contourSet.segment.segmentIndex] || {};\n        if (!contourSet.sliceContours.length) {\n            return null;\n        }\n        const p1 = contourSet.sliceContours[0].polyData.points[0];\n        let refImageId;\n        if (p1) {\n            const refImageIndex = refImageDataMetadata.findIndex((imageDataMetadata) => {\n                const { scanAxisNormal, origin } = imageDataMetadata;\n                const plane = utilities.planar.planeEquation(scanAxisNormal, origin);\n                return utilities.planar.isPointOnPlane(p1, plane);\n            });\n            if (refImageIndex !== -1) {\n                refImageId = refImages[refImageIndex].imageId;\n            }\n        }\n        return {\n            label: segment.label,\n            color: segment.color,\n            metadata: {\n                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,\n                referencedImageId: refImageId,\n            },\n            sliceContours: contourSet.sliceContours.map((contourData) => ({\n                contours: contourData.contours,\n                polyData: contourData.polyData,\n                FrameNumber: contourData.sliceIndex + 1,\n                sliceIndex: contourData.sliceIndex,\n                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,\n                referencedImageId: refImageId,\n            })),\n        };\n    })\n        .filter((contourSet) => contourSet !== null);\n    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 100);\n    return processedContourSets;\n}\nexport { generateContourSetsFromLabelmap };\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\nfunction validateAnnotation(annotation) {\n    if (!annotation?.data) {\n        throw new Error('Tool data is empty');\n    }\n    if (!annotation.metadata || annotation.metadata.referencedImageId) {\n        throw new Error('Tool data is not associated with any imageId');\n    }\n}\nclass AnnotationToPointData {\n    static { this.TOOL_NAMES = {}; }\n    constructor() {\n    }\n    static convert(annotation, index, metadataProvider) {\n        validateAnnotation(annotation);\n        const { toolName } = annotation.metadata;\n        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n        if (!toolClass) {\n            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);\n        }\n        const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);\n        const color = [\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n        ];\n        return {\n            ReferencedROINumber: index + 1,\n            ROIDisplayColor: color,\n            ContourSequence,\n        };\n    }\n    static register(toolClass) {\n        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n    }\n}\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\nexport default AnnotationToPointData;\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nexport default function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {\n    InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport * as math from '../math';\nimport { getParentAnnotation, invalidateAnnotation, } from '../../stateManagement/annotation/annotationState';\nexport default function updateContourPolyline(annotation, polylineData, transforms, options) {\n    const { canvasToWorld, worldToCanvas } = transforms;\n    const { data } = annotation;\n    const { targetWindingDirection } = polylineData;\n    let { points: polyline } = polylineData;\n    let windingDirection = math.polyline.getWindingDirection(polyline);\n    if (options?.decimate?.enabled) {\n        polyline = math.polyline.decimate(polylineData.points, options?.decimate?.epsilon);\n    }\n    let { closed } = polylineData;\n    const numPoints = polyline.length;\n    const polylineWorldPoints = new Array(numPoints);\n    const currentPolylineWindingDirection = math.polyline.getWindingDirection(polyline);\n    const parentAnnotation = getParentAnnotation(annotation);\n    if (closed === undefined) {\n        let currentClosedState = false;\n        if (polyline.length > 3) {\n            const lastToFirstDist = math.point.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);\n            currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n        }\n        closed = currentClosedState;\n    }\n    if (options?.updateWindingDirection !== false) {\n        let updatedWindingDirection = parentAnnotation\n            ? parentAnnotation.data.contour.windingDirection * -1\n            : targetWindingDirection;\n        if (updatedWindingDirection === undefined) {\n            updatedWindingDirection = windingDirection;\n        }\n        if (updatedWindingDirection !== windingDirection) {\n            polyline.reverse();\n        }\n        const handlePoints = (data.handles?.points ?? []).map(worldToCanvas);\n        if (handlePoints.length > 2) {\n            const currentHandlesWindingDirection = math.polyline.getWindingDirection(handlePoints);\n            if (currentHandlesWindingDirection !== updatedWindingDirection) {\n                data.handles.points.reverse();\n            }\n        }\n        windingDirection = updatedWindingDirection;\n    }\n    for (let i = 0; i < numPoints; i++) {\n        polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n    }\n    data.contour.polyline = polylineWorldPoints;\n    data.contour.closed = closed;\n    data.contour.windingDirection = windingDirection;\n    invalidateAnnotation(annotation);\n}\n","import { Enums } from '@cornerstonejs/core';\nfunction sumOverDimensionGroups(voxelManager, dimensionGroups) {\n    const arrayLength = voxelManager.getScalarDataLength();\n    const resultArray = new Float32Array(arrayLength);\n    for (const dimensionGroupNumber of dimensionGroups) {\n        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);\n        for (let i = 0; i < arrayLength; i++) {\n            resultArray[i] += scalarData[i];\n        }\n    }\n    return resultArray;\n}\nfunction averageOverDimensionGroups(voxelManager, dimensionGroups) {\n    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n    const numDimensionGroups = dimensionGroups.length;\n    for (let i = 0; i < sumArray.length; i++) {\n        sumArray[i] /= numDimensionGroups;\n    }\n    return sumArray;\n}\nconst operationFunctions = {\n    [Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {\n        if (dimensionGroups.length !== 2) {\n            throw new Error('Please provide only 2 dimension groups for subtraction.');\n        }\n        const arrayLength = voxelManager.getScalarDataLength();\n        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);\n        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);\n        for (let i = 0; i < arrayLength; i++) {\n            const difference = scalarData1[i] - scalarData2[i];\n            callback(i, difference);\n        }\n    },\n};\nfunction generateImageFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers } = options;\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const arrayLength = voxelManager.getScalarDataLength();\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    const resultArray = new Float32Array(arrayLength);\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        resultArray[index] = value;\n    });\n    return resultArray;\n}\nfunction updateVolumeFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;\n    if (!targetVolume) {\n        throw new Error('A target volume must be provided');\n    }\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const targetVoxelManager = targetVolume.voxelManager;\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        targetVoxelManager.setAtIndex(index, value);\n    });\n    targetVoxelManager.resetModifiedSlices();\n    for (let k = 0; k < targetVolume.dimensions[2]; k++) {\n        targetVoxelManager.modifiedSlices.add(k);\n    }\n}\nexport { generateImageFromTimeData, updateVolumeFromTimeData };\n","import { utilities, cache } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nfunction getDataInTime(dynamicVolume, options) {\n    let dataInTime;\n    const dimensionGroups = options.dimensionGroupNumbers ||\n        options.frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (options.frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    if (!options.maskVolumeId && !options.worldCoordinate) {\n        throw new Error('You should provide either maskVolumeId or imageCoordinate');\n    }\n    if (options.maskVolumeId && options.worldCoordinate) {\n        throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n    }\n    if (options.maskVolumeId) {\n        const segmentationVolume = cache.getVolume(options.maskVolumeId);\n        if (!segmentationVolume) {\n            throw new Error('Segmentation volume not found');\n        }\n        const [dataInTime, ijkCoords] = _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume);\n        return [dataInTime, ijkCoords];\n    }\n    if (options.worldCoordinate) {\n        const dataInTime = _getDimensionGroupDataCoordinate(dimensionGroups, options.worldCoordinate, dynamicVolume);\n        return dataInTime;\n    }\n    return dataInTime;\n}\nfunction _getDimensionGroupDataCoordinate(dimensionGroups, coordinate, volume) {\n    const { dimensions, imageData } = volume;\n    const index = imageData.worldToIndex(coordinate);\n    index[0] = Math.floor(index[0]);\n    index[1] = Math.floor(index[1]);\n    index[2] = Math.floor(index[2]);\n    if (!utilities.indexWithinDimensions(index, dimensions)) {\n        throw new Error('outside bounds');\n    }\n    const yMultiple = dimensions[0];\n    const zMultiple = dimensions[0] * dimensions[1];\n    const value = [];\n    dimensionGroups.forEach((dimensionGroupNumber) => {\n        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n        value.push(volume.voxelManager.getAtIndexAndDimensionGroup(scalarIndex, dimensionGroupNumber));\n    });\n    return value;\n}\nfunction _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume) {\n    const { imageData: maskImageData } = segmentationVolume;\n    const segVoxelManager = segmentationVolume.voxelManager;\n    const scalarDataLength = segVoxelManager.getScalarDataLength();\n    const nonZeroVoxelIndices = [];\n    nonZeroVoxelIndices.length = scalarDataLength;\n    let actualLen = 0;\n    for (let i = 0, len = scalarDataLength; i < len; i++) {\n        if (segVoxelManager.getAtIndex(i) !== 0) {\n            nonZeroVoxelIndices[actualLen++] = i;\n        }\n    }\n    nonZeroVoxelIndices.length = actualLen;\n    const nonZeroVoxelValuesInTime = [];\n    const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength &&\n        JSON.stringify(dynamicVolume.spacing) ===\n            JSON.stringify(segmentationVolume.spacing);\n    const ijkCoords = [];\n    if (isSameVolume) {\n        for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n            const valuesInTime = [];\n            const index = nonZeroVoxelIndices[i];\n            for (let j = 0; j < dimensionGroups.length; j++) {\n                valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[j]));\n            }\n            nonZeroVoxelValuesInTime.push(valuesInTime);\n            ijkCoords.push(segVoxelManager.toIJK(index));\n        }\n        return [nonZeroVoxelValuesInTime, ijkCoords];\n    }\n    const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK, }) => {\n        if (segValue === 0) {\n            return;\n        }\n        const overlapIJKMinMax = getVoxelOverlap(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);\n        let count = 0;\n        const perDimensionGroupSum = new Map();\n        dimensionGroups.forEach((dimensionGroupNumber) => perDimensionGroupSum.set(dimensionGroupNumber, 0));\n        const averageCallback = ({ index }) => {\n            for (let i = 0; i < dimensionGroups.length; i++) {\n                const value = dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[i]);\n                const dimensionGroupNumber = dimensionGroups[i];\n                perDimensionGroupSum.set(dimensionGroupNumber, perDimensionGroupSum.get(dimensionGroupNumber) + value);\n            }\n            count++;\n        };\n        dynamicVolume.voxelManager.forEach(averageCallback, {\n            imageData: dynamicVolume.imageData,\n            boundsIJK: overlapIJKMinMax,\n        });\n        const averageValues = [];\n        perDimensionGroupSum.forEach((sum) => {\n            averageValues.push(sum / count);\n        });\n        ijkCoords.push(segPointIJK);\n        nonZeroVoxelValuesInTime.push(averageValues);\n    };\n    segmentationVolume.voxelManager.forEach(callback, {\n        imageData: maskImageData,\n    });\n    return [nonZeroVoxelValuesInTime, ijkCoords];\n}\nexport default getDataInTime;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\nfunction getAnnotationNearPoint(element, canvasPoint, proximity = 5) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('getAnnotationNearPoint: enabledElement not found');\n    }\n    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);\n}\nfunction getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const { _toolInstances: tools } = toolGroup;\n    for (const name in tools) {\n        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);\n        if (found) {\n            return found;\n        }\n    }\n    return null;\n}\nfunction findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {\n    const { viewport } = enabledElement;\n    const annotations = getAnnotations(tool.constructor.toolName, viewport?.element);\n    const currentId = viewport?.getCurrentImageId?.();\n    if (annotations?.length) {\n        const { element } = enabledElement.viewport;\n        for (const annotation of annotations) {\n            const referencedImageId = annotation.metadata?.referencedImageId;\n            if ((currentId && referencedImageId && currentId !== referencedImageId) ||\n                !tool.isPointNearTool) {\n                continue;\n            }\n            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||\n                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {\n                return annotation;\n            }\n        }\n    }\n    return null;\n}\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import { Enums, utilities } from '@cornerstonejs/core';\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\nconst VOXEL_UNITS = 'voxels';\nconst SUPPORTED_REGION_DATA_TYPES = [\n    1,\n    2,\n    3,\n    4,\n];\nconst SUPPORTED_LENGTH_VARIANT = [\n    '3,3',\n    '4,7',\n];\nconst SUPPORTED_PROBE_VARIANT = [\n    '4,3',\n    '4,7',\n];\nconst UNIT_MAPPING = {\n    0: 'px',\n    1: 'percent',\n    2: 'dB',\n    3: 'cm',\n    4: 'seconds',\n    5: 'hertz',\n    6: 'dB/seconds',\n    7: 'cm/sec',\n    8: 'cm\\xb2',\n    9: 'cm\\xb2/s',\n    0xc: 'degrees',\n};\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n    const { calibration, hasPixelSpacing } = image;\n    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n    const volumeUnit = hasPixelSpacing ? 'mm\\xb3' : VOXEL_UNITS;\n    let areaUnit = unit + SQUARE;\n    let scale = 1;\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { unit, areaUnit, scale, volumeUnit };\n    }\n    if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n        return {\n            unit: PIXEL_UNITS,\n            areaUnit: PIXEL_UNITS + SQUARE,\n            scale,\n            volumeUnit: VOXEL_UNITS,\n        };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        let imageIndex1, imageIndex2;\n        if (Array.isArray(handles) && handles.length === 2) {\n            [imageIndex1, imageIndex2] = handles;\n        }\n        else if (typeof handles === 'function') {\n            const points = handles();\n            imageIndex1 = points[0];\n            imageIndex2 = points[1];\n        }\n        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&\n            imageIndex1[0] <= region.regionLocationMaxX1 &&\n            imageIndex1[1] >= region.regionLocationMinY0 &&\n            imageIndex1[1] <= region.regionLocationMaxY1 &&\n            imageIndex2[0] >= region.regionLocationMinX0 &&\n            imageIndex2[0] <= region.regionLocationMaxX1 &&\n            imageIndex2[1] >= region.regionLocationMinY0 &&\n            imageIndex2[1] <= region.regionLocationMaxY1);\n        if (!regions?.length) {\n            return { unit, areaUnit, scale, volumeUnit };\n        }\n        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!regions.length) {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n        const region = regions[0];\n        const physicalDeltaX = Math.abs(region.physicalDeltaX);\n        const physicalDeltaY = Math.abs(region.physicalDeltaY);\n        const isSamePhysicalDelta = utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);\n        if (isSamePhysicalDelta) {\n            scale = 1 / physicalDeltaX;\n            calibrationType = 'US Region';\n            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n            areaUnit = unit + SQUARE;\n        }\n        else {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n    }\n    else if (calibration.scale) {\n        scale = calibration.scale;\n    }\n    const types = [\n        CalibrationTypes.ERMF,\n        CalibrationTypes.USER,\n        CalibrationTypes.ERROR,\n        CalibrationTypes.PROJECTION,\n        CalibrationTypes.CALIBRATED,\n        CalibrationTypes.UNKNOWN,\n    ];\n    if (types.includes(calibration?.type)) {\n        calibrationType = calibration.type;\n    }\n    return {\n        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),\n        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),\n        scale,\n        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),\n    };\n};\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n    const [imageIndex] = handles;\n    const { calibration } = image;\n    let units = ['raw'];\n    let values = [null];\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { units, values };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!supportedRegionsMetadata?.length) {\n            return { units, values };\n        }\n        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&\n            imageIndex[0] <= region.regionLocationMaxX1 &&\n            imageIndex[1] >= region.regionLocationMinY0 &&\n            imageIndex[1] <= region.regionLocationMaxY1);\n        if (!region) {\n            return { units, values };\n        }\n        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n        const { physicalDeltaX, physicalDeltaY } = region;\n        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n            physicalDeltaY;\n        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n            physicalDeltaX;\n        calibrationType = 'US Region';\n        values = [xValue, yValue];\n        units = [\n            UNIT_MAPPING[region.physicalUnitsXDirection],\n            UNIT_MAPPING[region.physicalUnitsYDirection],\n        ];\n    }\n    return {\n        units,\n        values,\n        calibrationType,\n    };\n};\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\nexport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, getCalibratedProbeUnitsAndValue, };\n","import { metaData } from '@cornerstonejs/core';\nfunction getPixelValueUnitsImageId(imageId, options) {\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n    return getPixelValueUnits(generalSeriesModule.modality, imageId, options);\n}\nfunction getPixelValueUnits(modality, imageId, options) {\n    if (modality === 'CT') {\n        return 'HU';\n    }\n    else if (modality === 'PT') {\n        return _handlePTModality(imageId, options);\n    }\n    else {\n        return '';\n    }\n}\nfunction _handlePTModality(imageId, options) {\n    if (!options.isPreScaled) {\n        return 'raw';\n    }\n    if (options.isSuvScaled) {\n        return 'SUV';\n    }\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n    if (generalSeriesModule?.modality === 'PT') {\n        const petSeriesModule = metaData.get('petSeriesModule', imageId);\n        return petSeriesModule?.units || 'unitless';\n    }\n    return 'unknown';\n}\nexport { getPixelValueUnits, getPixelValueUnitsImageId };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nfunction _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n        topLeftWorld: topLeftWorld,\n        bottomRightWorld: bottomRightWorld,\n    };\n}\nfunction getSphereBoundsInfo(circlePoints, imageData) {\n    const direction = imageData.getDirection();\n    const rowCosine = vec3.fromValues(direction[0], direction[1], direction[2]);\n    const columnCosine = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const scanAxis = vec3.fromValues(direction[6], direction[7], direction[8]);\n    const viewPlaneNormal = vec3.negate(vec3.create(), scanAxis);\n    const directionVectors = {\n        row: rowCosine,\n        column: columnCosine,\n        normal: viewPlaneNormal,\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {\n    if (!viewport) {\n        throw new Error('viewport is required in order to calculate the sphere bounds');\n    }\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const directionVectors = {\n        row: viewRight,\n        normal: viewPlaneNormal,\n        column: vec3.negate(vec3.create(), viewUp),\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {\n    const dimensions = imageData.getDimensions();\n    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);\n    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);\n    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));\n    const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);\n    return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\nexport { getSphereBoundsInfo, getSphereBoundsInfoFromViewport };\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nexport default function getViewportsForAnnotation(annotation) {\n    const { metadata } = annotation;\n    return getEnabledElements()\n        .filter((enabledElement) => {\n        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n            const viewport = enabledElement.viewport;\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));\n        }\n        return;\n    })\n        .map((enabledElement) => enabledElement.viewport);\n}\n","import { utilities, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, } from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport { pointToString } from './pointToString';\nimport AnnotationMultiSlice from './AnnotationMultiSlice';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport { annotationHydration, getClosestImageIdForStackViewport, } from './annotationHydration';\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\nimport { pointInSurroundingSphereCallback } from './pointInSurroundingSphereCallback';\nconst roundNumber = utilities.roundNumber;\nimport normalizeViewportPlane from './normalizeViewportPlane';\nimport IslandRemoval from './segmentation/islandRemoval';\nimport { getPixelValueUnits, getPixelValueUnitsImageId, } from './getPixelValueUnits';\nimport * as geometricSurfaceUtils from './geometricSurfaceUtils';\nimport setAnnotationLabel from './setAnnotationLabel';\nimport { moveAnnotationToViewPlane } from './moveAnnotationToViewPlane';\nimport getOrCreateImageVolume from './segmentation/getOrCreateImageVolume';\nimport * as usFanExtraction from '../tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction';\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, getPixelValueUnits, getPixelValueUnitsImageId, segmentation, contours, triggerAnnotationRenderForViewportIds, triggerAnnotationRenderForToolGroupIds, triggerAnnotationRender, getSphereBoundsInfo, getAnnotationNearPoint, getViewportForAnnotation, getAnnotationNearPointOnEnabledElement, viewport, cine, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, stackContextPrefetch, roundNumber, pointToString, polyDataUtils, voi, AnnotationMultiSlice, contourSegmentation, annotationHydration, getClosestImageIdForStackViewport, pointInSurroundingSphereCallback, normalizeViewportPlane, IslandRemoval, geometricSurfaceUtils, usFanExtraction, setAnnotationLabel, moveAnnotationToViewPlane, getOrCreateImageVolume, };\n","import containsPoint from './containsPoint';\nexport default function containsPoints(polyline, points) {\n    for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n        if (!containsPoint(polyline, points[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n","import * as mathLine from '../line';\nconst DEFAULT_EPSILON = 0.1;\nexport default function decimate(polyline, epsilon = DEFAULT_EPSILON) {\n    const numPoints = polyline.length;\n    if (numPoints < 3) {\n        return polyline;\n    }\n    const epsilonSquared = epsilon * epsilon;\n    const partitionQueue = [[0, numPoints - 1]];\n    const polylinePointFlags = new Array(numPoints).fill(false);\n    let numDecimatedPoints = 2;\n    polylinePointFlags[0] = true;\n    polylinePointFlags[numPoints - 1] = true;\n    while (partitionQueue.length) {\n        const [startIndex, endIndex] = partitionQueue.pop();\n        if (endIndex - startIndex === 1) {\n            continue;\n        }\n        const startPoint = polyline[startIndex];\n        const endPoint = polyline[endIndex];\n        let maxDistSquared = -Infinity;\n        let maxDistIndex = -1;\n        for (let i = startIndex + 1; i < endIndex; i++) {\n            const currentPoint = polyline[i];\n            const distSquared = mathLine.distanceToPointSquared(startPoint, endPoint, currentPoint);\n            if (distSquared > maxDistSquared) {\n                maxDistSquared = distSquared;\n                maxDistIndex = i;\n            }\n        }\n        if (maxDistSquared < epsilonSquared) {\n            continue;\n        }\n        polylinePointFlags[maxDistIndex] = true;\n        numDecimatedPoints++;\n        partitionQueue.push([maxDistIndex, endIndex]);\n        partitionQueue.push([startIndex, maxDistIndex]);\n    }\n    const decimatedPolyline = new Array(numDecimatedPoints);\n    for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n        if (polylinePointFlags[srcIndex]) {\n            decimatedPolyline[dstIndex++] = polyline[srcIndex];\n        }\n    }\n    return decimatedPolyline;\n}\n","export default function getSignedArea(polyline) {\n    if (polyline.length < 3) {\n        return 0;\n    }\n    const refPoint = polyline[0];\n    let area = 0;\n    for (let i = 0, len = polyline.length; i < len; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === len - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const aX = p1[0] - refPoint[0];\n        const aY = p1[1] - refPoint[1];\n        const bX = p2[0] - refPoint[0];\n        const bY = p2[1] - refPoint[1];\n        area += aX * bY - aY * bX;\n    }\n    area *= 0.5;\n    return area;\n}\n","import { glMatrix } from 'gl-matrix';\nimport { distanceToPointSquared } from '../point';\nexport default function isClosed(polyline) {\n    if (polyline.length < 3) {\n        return false;\n    }\n    const numPolylinePoints = polyline.length;\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[numPolylinePoints - 1];\n    const distFirstToLastPoints = distanceToPointSquared(firstPoint, lastPoint);\n    return glMatrix.equals(0, distFirstToLastPoints);\n}\n","export default function findClosestPoint(sourcePoints, targetPoint) {\n    let minPoint = [0, 0];\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    sourcePoints.forEach(function (sourcePoint) {\n        const distance = _distanceBetween(targetPoint, sourcePoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minPoint = [...sourcePoint];\n        }\n    });\n    return minPoint;\n}\nfunction _distanceBetween(p1, p2) {\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport * as vec3 from 'gl-matrix/vec3';\nexport function moveAnnotationToViewPlane(annotation, viewport) {\n    const { data } = annotation;\n    const { points } = data.handles;\n    const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n    const projectedDistance = vec3.dot(vec3.sub(vec3.create(), points[0], focalPoint), viewPlaneNormal);\n    points.forEach((point) => {\n        vec3.add(point, point, vec3.scale(vec3.create(), [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance));\n    });\n    if (viewport instanceof StackViewport) {\n        annotation.metadata.referencedImageId = viewport.getCurrentImageId();\n    }\n    return annotation;\n}\n","import { BaseVolumeViewport, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst acquisitionMapping = {\n    toIJK: (ijkPrime) => ijkPrime,\n    fromIJK: (ijk) => ijk,\n    type: 'acquistion',\n};\nconst jkMapping = {\n    toIJK: ([j, k, i]) => [i, j, k],\n    fromIJK: ([i, j, k]) => [j, k, i],\n    type: 'jk',\n};\nconst ikMapping = {\n    toIJK: ([i, k, j]) => [i, j, k],\n    fromIJK: ([i, j, k]) => [i, k, j],\n    type: 'ik',\n};\nexport default function normalizeViewportPlane(viewport, boundsIJK) {\n    if (!(viewport instanceof BaseVolumeViewport)) {\n        return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };\n    }\n    const { viewPlaneNormal } = viewport.getCamera();\n    const mapping = (isEqual(Math.abs(viewPlaneNormal[0]), 1) && jkMapping) ||\n        (isEqual(Math.abs(viewPlaneNormal[1]), 1) && ikMapping) ||\n        (isEqual(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping);\n    if (!mapping) {\n        return {\n            toIJK: null,\n            boundsIJKPrime: null,\n            fromIJK: null,\n            error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`,\n        };\n    }\n    return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };\n}\n","export default function getOrientationStringLPS(vector) {\n    let orientation = '';\n    const orientationX = vector[0] < 0 ? 'R' : 'L';\n    const orientationY = vector[1] < 0 ? 'A' : 'P';\n    const orientationZ = vector[2] < 0 ? 'F' : 'H';\n    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n    const MIN = 0.0001;\n    for (let i = 0; i < 3; i++) {\n        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n            orientation += orientationX;\n            abs[0] = 0;\n        }\n        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n            orientation += orientationY;\n            abs[1] = 0;\n        }\n        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n            orientation += orientationZ;\n            abs[2] = 0;\n        }\n        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n            orientation += orientationX + orientationY;\n            abs[0] = 0;\n            abs[1] = 0;\n        }\n        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n            orientation += orientationX + orientationZ;\n            abs[0] = 0;\n            abs[2] = 0;\n        }\n        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n            orientation += orientationY + orientationZ;\n            abs[1] = 0;\n            abs[2] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return orientation;\n}\n","export default function invertOrientationStringLPS(orientationString) {\n    let inverted = orientationString.replace('H', 'f');\n    inverted = inverted.replace('F', 'h');\n    inverted = inverted.replace('R', 'l');\n    inverted = inverted.replace('L', 'r');\n    inverted = inverted.replace('A', 'p');\n    inverted = inverted.replace('P', 'a');\n    inverted = inverted.toUpperCase();\n    return inverted;\n}\n","import smoothAnnotation from './smoothAnnotation';\nexport default {\n    smoothAnnotation,\n};\nexport { smoothAnnotation };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport { getBoundingBoxAroundShape } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nexport function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {\n    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);\n    const sphereObj = {\n        center: centerWorld,\n        radius: radiusWorld,\n    };\n    const dimensions = imageData.getDimensions();\n    const voxelManager = csUtils.VoxelManager.createScalarVolumeVoxelManager({\n        dimensions: dimensions,\n        scalarData: imageData.getPointData().getScalars().getData(),\n    });\n    voxelManager.forEach(callback, {\n        boundsIJK,\n        isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),\n        imageData,\n    });\n}\nfunction _getBounds(circlePoints, imageData, viewport) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    let boundsIJK;\n    if (!viewport) {\n        const centerIJK = transformWorldToIndex(imageData, centerWorld);\n        const spacings = imageData.getSpacing();\n        const minSpacing = Math.min(...spacings);\n        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n        boundsIJK = [\n            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n        ];\n        return {\n            boundsIJK,\n            centerWorld: centerWorld,\n            radiusWorld,\n        };\n    }\n    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n    };\n}\nfunction _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {\n    const [bottom, top] = circlePoints;\n    const dimensions = imageData.getDimensions();\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n    const sphereCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        (transformWorldToIndex(imageData, bottomRightWorld)),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n    return boundsIJK;\n}\n","export function pointToString(point, decimals = 5) {\n    return (parseFloat(point[0]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[1]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[2]).toFixed(decimals) +\n        ',');\n}\n","import { vec3 } from 'gl-matrix';\nexport function getPoint(points, idx) {\n    const idx3 = idx * 3;\n    if (idx3 < points.length) {\n        return vec3.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);\n    }\n}\nexport function getPolyDataPointIndexes(polyData) {\n    const linesData = polyData.getLines().getData();\n    let idx = 0;\n    const lineSegments = new Map();\n    while (idx < linesData.length) {\n        const segmentSize = linesData[idx++];\n        const segment = [];\n        for (let i = 0; i < segmentSize; i++) {\n            segment.push(linesData[idx + i]);\n        }\n        lineSegments.set(segment[0], segment);\n        idx += segmentSize;\n    }\n    const contours = [];\n    const findStartingPoint = (map) => {\n        for (const [key, value] of map.entries()) {\n            if (value !== undefined) {\n                return key;\n            }\n        }\n        return -1;\n    };\n    let startPoint = findStartingPoint(lineSegments);\n    while (startPoint !== -1) {\n        const contour = [startPoint];\n        while (lineSegments.has(startPoint)) {\n            const nextPoint = lineSegments.get(startPoint)[1];\n            if (lineSegments.has(nextPoint)) {\n                contour.push(nextPoint);\n            }\n            lineSegments.delete(startPoint);\n            startPoint = nextPoint;\n        }\n        contours.push(contour);\n        startPoint = findStartingPoint(lineSegments);\n    }\n    return contours.length ? contours : undefined;\n}\nexport function getPolyDataPoints(polyData) {\n    const contoursIndexes = getPolyDataPointIndexes(polyData);\n    if (!contoursIndexes) {\n        return;\n    }\n    const rawPointsData = polyData.getPoints().getData();\n    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\nfunction getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {\n    const AllBoundsIJK = [];\n    annotations.forEach((annotation) => {\n        const { data } = annotation;\n        const { points } = data.handles;\n        const { imageData, dimensions } = referenceVolume;\n        let pointsToUse = points;\n        if (data.cachedStats?.projectionPoints) {\n            const { projectionPoints } = data.cachedStats;\n            pointsToUse = [].concat(...projectionPoints);\n        }\n        const rectangleCornersIJK = pointsToUse.map((world) => csUtils.transformWorldToIndex(imageData, world));\n        let boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, dimensions);\n        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n            boundsIJK = extend2DBoundingBoxInViewAxis(boundsIJK, options.numSlicesToProject);\n        }\n        AllBoundsIJK.push(boundsIJK);\n    });\n    if (AllBoundsIJK.length === 1) {\n        return AllBoundsIJK[0];\n    }\n    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {\n        return {\n            iMin: Math.min(accumulator.iMin, currentValue.iMin),\n            jMin: Math.min(accumulator.jMin, currentValue.jMin),\n            kMin: Math.min(accumulator.kMin, currentValue.kMin),\n            iMax: Math.max(accumulator.iMax, currentValue.iMax),\n            jMax: Math.max(accumulator.jMax, currentValue.jMax),\n            kMax: Math.max(accumulator.kMax, currentValue.kMax),\n        };\n    }, {\n        iMin: Infinity,\n        jMin: Infinity,\n        kMin: Infinity,\n        iMax: -Infinity,\n        jMax: -Infinity,\n        kMax: -Infinity,\n    });\n    return boundsIJK;\n}\nexport default getBoundsIJKFromRectangleAnnotations;\n","import { getWebWorkerManager } from '@cornerstonejs/core';\nimport { getConfig } from '../config';\nlet registered = false;\nexport function registerComputeWorker() {\n    if (registered) {\n        return;\n    }\n    registered = true;\n    const workerFn = () => {\n        return new Worker(new URL('../workers/computeWorker.js', import.meta.url), {\n            name: 'compute',\n            type: 'module',\n        });\n    };\n    const workerManager = getWebWorkerManager();\n    const config = getConfig();\n    const computeWorkerConfig = config.computeWorker;\n    const options = {\n        maxWorkerInstances: 1,\n        autoTerminateOnIdle: computeWorkerConfig?.autoTerminateOnIdle ?? {\n            enabled: true,\n            idleTimeThreshold: 2000,\n        },\n    };\n    workerManager.registerWorker('compute', workerFn, options);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\nconst { uuidv4 } = csUtils;\nconst ChangeTypesForInterpolation = [\n    ChangeTypes.HandlesUpdated,\n    ChangeTypes.InterpolationUpdated,\n];\nexport default class InterpolationManager {\n    static { this.toolNames = []; }\n    static addTool(toolName) {\n        if (!this.toolNames.includes(toolName)) {\n            this.toolNames.push(toolName);\n        }\n    }\n    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {\n        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n        for (const toolName of toolNames || InterpolationManager.toolNames) {\n            const annotations = annotationState.getAnnotations(toolName, annotationGroupSelector);\n            if (!annotations?.length) {\n                continue;\n            }\n            for (const annotation of annotations) {\n                const { interpolationUID, data, autoGenerated, metadata } = annotation;\n                if (interpolationUID) {\n                    annotation.interpolationCompleted = true;\n                }\n                if (!autoGenerated) {\n                    continue;\n                }\n                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n                    continue;\n                }\n                if (sliceIndex !== undefined &&\n                    metadata &&\n                    sliceIndex !== metadata.sliceIndex) {\n                    continue;\n                }\n                if (segmentationId &&\n                    segmentationId !== data.segmentation.segmentationId) {\n                    continue;\n                }\n                addContourSegmentationAnnotation(annotation);\n                annotation.autoGenerated = false;\n            }\n        }\n    }\n    static { this.handleAnnotationCompleted = (evt) => {\n        const annotation = evt.detail.annotation;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName, originalToolName } = annotation.metadata;\n        if (!this.toolNames.includes(toolName) &&\n            !this.toolNames.includes(originalToolName)) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn('Unable to find viewport for', annotation);\n            return;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n        };\n        const hasInterpolationUID = !!annotation.interpolationUID;\n        annotation.autoGenerated = false;\n        if (hasInterpolationUID) {\n            deleteRelatedAnnotations(viewportData);\n            interpolate(viewportData);\n            return;\n        }\n        const filterData = [\n            {\n                key: 'segmentIndex',\n                value: annotation.data.segmentation.segmentIndex,\n                parentKey: (annotation) => annotation.data.segmentation,\n            },\n            {\n                key: 'viewPlaneNormal',\n                value: annotation.metadata.viewPlaneNormal,\n                parentKey: (annotation) => annotation.metadata,\n            },\n            {\n                key: 'viewUp',\n                value: annotation.metadata.viewUp,\n                parentKey: (annotation) => annotation.metadata,\n            },\n        ];\n        let interpolationAnnotations = getInterpolationDataCollection(viewportData, filterData);\n        const { sliceIndex } = annotation.metadata;\n        const skipUIDs = new Set();\n        interpolationAnnotations.forEach((interpolationAnnotation) => {\n            if (interpolationAnnotation.interpolationCompleted ||\n                interpolationAnnotation.metadata.sliceIndex === sliceIndex) {\n                const { interpolationUID } = interpolationAnnotation;\n                skipUIDs.add(interpolationUID);\n            }\n        });\n        interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));\n        annotation.interpolationUID =\n            interpolationAnnotations[0]?.interpolationUID || uuidv4();\n        viewportData.interpolationUID = annotation.interpolationUID;\n        interpolate(viewportData);\n    }; }\n    static { this.handleAnnotationUpdate = (evt) => {\n        const annotation = evt.detail.annotation;\n        const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName, originalToolName } = annotation.metadata;\n        if ((!this.toolNames.includes(toolName) &&\n            !this.toolNames.includes(originalToolName)) ||\n            !ChangeTypesForInterpolation.includes(changeType)) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn('Unable to find matching viewport for annotation interpolation', annotation);\n            return;\n        }\n        if (annotation.autoGenerated) {\n            addContourSegmentationAnnotation(annotation);\n            annotation.autoGenerated = false;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n            isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n        };\n        interpolate(viewportData);\n    }; }\n    static { this.handleAnnotationDelete = (evt) => {\n        const annotation = evt.detail.annotation;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName } = annotation.metadata;\n        if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn(\"No viewport, can't delete interpolated results\", annotation);\n            return;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n        };\n        annotation.autoGenerated = false;\n        deleteRelatedAnnotations(viewportData);\n    }; }\n}\nfunction getSliceData(viewport) {\n    const sliceData = {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getCurrentImageIdIndex(),\n    };\n    return sliceData;\n}\n","import { InstanceVolumetricCalculator } from './VolumetricCalculator';\nexport default class SegmentStatsCalculator {\n    static { this.calculators = new Map(); }\n    static { this.indices = []; }\n    static { this.mode = 'collective'; }\n    static statsInit(options) {\n        const { storePointData, indices, mode } = options;\n        this.mode = mode;\n        this.indices = indices;\n        this.calculators.clear();\n        if (this.mode === 'individual') {\n            indices.forEach((index) => {\n                this.calculators.set(index, new InstanceVolumetricCalculator({ storePointData }));\n            });\n        }\n        else {\n            this.calculators.set(indices, new InstanceVolumetricCalculator({ storePointData }));\n        }\n    }\n    static statsCallback(data) {\n        const { segmentIndex, ...statsData } = data;\n        if (!segmentIndex) {\n            throw new Error('Segment index is required for stats calculation');\n        }\n        const calculator = this.mode === 'individual'\n            ? this.calculators.get(segmentIndex)\n            : this.calculators.get(this.indices);\n        if (!calculator) {\n            throw new Error(`No calculator found for segment ${segmentIndex}`);\n        }\n        calculator.statsCallback(statsData);\n    }\n    static getStatistics(options) {\n        if (this.mode === 'individual') {\n            const result = {};\n            this.calculators.forEach((calculator, segmentIndex) => {\n                result[segmentIndex] = calculator.getStatistics(options);\n            });\n            return result;\n        }\n        const calculator = this.calculators.get(this.indices);\n        return calculator.getStatistics(options);\n    }\n}\n","import { BasicStatsCalculator, InstanceBasicStatsCalculator, } from '../math/basic/BasicStatsCalculator';\nimport { getCalibratedLengthUnitsAndScale } from '../getCalibratedUnits';\nconst TEST_MAX_LOCATIONS = 10;\nfunction createVolumetricState() {\n    return {\n        maxIJKs: [],\n    };\n}\nfunction volumetricStatsCallback(state, data) {\n    const { value } = data;\n    const { maxIJKs } = state;\n    const length = maxIJKs.length;\n    if (typeof value !== 'number' ||\n        (length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value)) {\n        return;\n    }\n    const dataCopy = {\n        value: data.value,\n        pointLPS: data.pointLPS\n            ? [data.pointLPS[0], data.pointLPS[1], data.pointLPS[2]]\n            : undefined,\n        pointIJK: data.pointIJK\n            ? [data.pointIJK[0], data.pointIJK[1], data.pointIJK[2]]\n            : undefined,\n    };\n    if (!length || value >= maxIJKs[length - 1].value) {\n        maxIJKs.push(dataCopy);\n    }\n    else {\n        for (let i = 0; i < length; i++) {\n            if (value <= maxIJKs[i].value) {\n                maxIJKs.splice(i, 0, dataCopy);\n                break;\n            }\n        }\n    }\n    if (length >= TEST_MAX_LOCATIONS) {\n        maxIJKs.splice(0, 1);\n    }\n}\nfunction volumetricGetStatistics(state, stats, options) {\n    const { spacing, calibration } = options;\n    const { volumeUnit } = getCalibratedLengthUnitsAndScale({\n        calibration,\n        hasPixelSpacing: true,\n    }, []);\n    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] : 1;\n    stats.volume = {\n        value: Array.isArray(stats.count.value)\n            ? stats.count.value.map((v) => v * volumeScale)\n            : stats.count.value * volumeScale,\n        unit: volumeUnit,\n        name: 'volume',\n        label: 'Volume',\n    };\n    stats.maxIJKs = state.maxIJKs.filter((entry) => entry.pointIJK !== undefined);\n    stats.array.push(stats.volume);\n    state.maxIJKs = [];\n    return stats;\n}\nexport class VolumetricCalculator extends BasicStatsCalculator {\n    static { this.volumetricState = createVolumetricState(); }\n    static statsInit(options) {\n        super.statsInit(options);\n        this.volumetricState = createVolumetricState();\n    }\n    static statsCallback(data) {\n        super.statsCallback(data);\n        volumetricStatsCallback(this.volumetricState, data);\n    }\n    static getStatistics(options) {\n        const optionsWithUnit = {\n            ...options,\n            unit: options?.unit || 'none',\n            calibration: options?.calibration,\n            hasPixelSpacing: options?.hasPixelSpacing,\n        };\n        const stats = super.getStatistics(optionsWithUnit);\n        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);\n    }\n}\nexport class InstanceVolumetricCalculator extends InstanceBasicStatsCalculator {\n    constructor(options) {\n        super(options);\n        this.volumetricState = createVolumetricState();\n    }\n    statsInit(options) {\n        super.statsInit(options);\n        this.volumetricState = createVolumetricState();\n    }\n    statsCallback(data) {\n        super.statsCallback(data);\n        volumetricStatsCallback(this.volumetricState, data);\n    }\n    getStatistics(options) {\n        const optionsWithUnit = {\n            ...options,\n            unit: options?.unit || 'none',\n            calibration: options?.calibration,\n            hasPixelSpacing: options?.hasPixelSpacing,\n        };\n        const stats = super.getStatistics(optionsWithUnit);\n        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);\n    }\n}\nexport default VolumetricCalculator;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.configuration.brushSize = brushSize;\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const { renderingEngineId } = viewportsInfoArray[0];\n    const viewportIds = toolGroup.getViewportIds();\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\nexport function getBrushSizeForToolGroup(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.brushSize;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function setBrushThresholdForToolGroup(toolGroupId, threshold) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        const activeStrategy = tool.configuration.activeStrategy;\n        if (!activeStrategy.toLowerCase().includes('threshold')) {\n            return;\n        }\n        tool.configuration = {\n            ...tool.configuration,\n            threshold: {\n                ...tool.configuration.threshold,\n                ...threshold,\n            },\n        };\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    if (!viewportsInfo.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\nexport function getBrushThresholdForToolGroup(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.threshold.range;\n}\n","import { utilities, getWebWorkerManager } from '@cornerstonejs/core';\nimport { triggerWorkerProgress } from './utilsForWorker';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport createMergedLabelmapForIndex from './createMergedLabelmapForIndex';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nimport { getReferenceVolumeForSegmentation } from './getReferenceVolumeForSegmentation';\nasync function computeMetabolicStats({ segmentationIds, segmentIndex, }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const segmentation = getSegmentation(segmentationIds[0]);\n    const { imageIds: segImageIds } = segmentation.representationData\n        .Labelmap;\n    const isValidVolume = utilities.isValidVolume(segImageIds);\n    if (!isValidVolume) {\n        throw new Error('Invalid volume - TMTV cannot be calculated');\n    }\n    const stats = await calculateForVolume({\n        segmentationIds,\n        segmentIndex,\n    });\n    return stats;\n}\nasync function calculateForVolume({ segmentationIds, segmentIndex }) {\n    const labelmapVolumes = segmentationIds.map((id) => {\n        return getOrCreateSegmentationVolume(id);\n    });\n    const mergedLabelmap = createMergedLabelmapForIndex(labelmapVolumes, segmentIndex);\n    if (!mergedLabelmap) {\n        throw new Error('Invalid volume - TMTV cannot be calculated');\n    }\n    const { imageData, dimensions, direction, origin, voxelManager } = mergedLabelmap;\n    const spacing = imageData.getSpacing();\n    const segmentationScalarData = voxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions,\n        spacing,\n        origin,\n        direction,\n    };\n    const referenceVolume = getReferenceVolumeForSegmentation(segmentationIds[0]);\n    const imageInfo = {\n        dimensions: referenceVolume.dimensions,\n        spacing: referenceVolume.spacing,\n        origin: referenceVolume.origin,\n        direction: referenceVolume.direction,\n        scalarData: referenceVolume.voxelManager.getCompleteScalarDataArray(),\n    };\n    if (imageInfo.scalarData.length === 0 ||\n        segmentationInfo.scalarData.length === 0) {\n        return {\n            [segmentIndex]: {\n                name: 'TMTV',\n                value: 0,\n            },\n        };\n    }\n    const stats = await getWebWorkerManager().executeTask('compute', 'computeMetabolicStats', {\n        segmentationInfo,\n        imageInfo,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    return stats;\n}\nexport { computeMetabolicStats };\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateImageVolume from './getOrCreateImageVolume';\nexport function getReferenceVolumeForSegmentation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return null;\n    }\n    let referenceImageIds;\n    const labelmap = segmentation.representationData.Labelmap;\n    if ('imageIds' in labelmap) {\n        const { imageIds } = labelmap;\n        const firstImage = cache.getImage(imageIds[0]);\n        const volumeInfo = cache.getVolumeContainingImageId(firstImage.referencedImageId);\n        if (volumeInfo?.volume) {\n            return volumeInfo.volume;\n        }\n        referenceImageIds = imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n    }\n    else if ('volumeId' in labelmap) {\n        const { volumeId, referencedVolumeId } = labelmap;\n        if (referencedVolumeId) {\n            const refVolume = cache.getVolume(referencedVolumeId);\n            if (refVolume) {\n                return refVolume;\n            }\n        }\n        const segVolume = cache.getVolume(volumeId);\n        if (segVolume) {\n            referenceImageIds = segVolume.imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n        }\n    }\n    return getOrCreateImageVolume(referenceImageIds);\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport findLargestBidirectional from './findLargestBidirectional';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nexport default async function contourAndFindLargestBidirectional(segmentation) {\n    const contours = await generateContourSetsFromLabelmap({\n        segmentations: segmentation,\n    });\n    if (!contours?.length || !contours[0].sliceContours.length) {\n        return;\n    }\n    const { segments = [\n        null,\n        { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ], } = segmentation;\n    const vol = getOrCreateSegmentationVolume(segmentation.segmentationId);\n    if (!vol) {\n        return;\n    }\n    const segmentIndex = segments.findIndex((it) => !!it);\n    if (segmentIndex === -1) {\n        return;\n    }\n    segments[segmentIndex].segmentIndex = segmentIndex;\n    return findLargestBidirectional(contours[0], vol.volumeId, segments[segmentIndex]);\n}\n","export default function createBidirectionalToolData(bidirectionalData, viewport) {\n    const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n    const [major0, major1] = majorAxis;\n    const [minor0, minor1] = minorAxis;\n    const points = [major0, major1, minor0, minor1];\n    const bidirectionalToolData = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n            toolName: 'Bidirectional',\n            ...viewport.getViewReference({ sliceIndex }),\n        },\n        data: {\n            handles: {\n                points,\n                textBox: {\n                    hasMoved: false,\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n                activeHandleIndex: null,\n            },\n            label,\n            cachedStats: {},\n        },\n        isLocked: false,\n        isVisible: true,\n    };\n    return bidirectionalToolData;\n}\n","import { utilities, eventTarget } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport Events from '../../enums/Events';\nconst { VoxelManager, RLEVoxelMap } = utilities;\nexport function createLabelmapMemo(segmentationId, segmentationVoxelManager) {\n    return createRleMemo(segmentationId, segmentationVoxelManager);\n}\nexport function restoreMemo(isUndo) {\n    const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;\n    const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;\n    useVoxelManager.forEach(({ value, pointIJK }) => {\n        segmentationVoxelManager.setAtIJKPoint(pointIJK, value);\n    });\n    const slices = useVoxelManager.getArrayOfModifiedSlices();\n    triggerSegmentationDataModified(this.segmentationId, slices);\n}\nexport function createRleMemo(segmentationId, segmentationVoxelManager) {\n    const voxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n    const state = {\n        segmentationId,\n        restoreMemo,\n        commitMemo,\n        segmentationVoxelManager,\n        voxelManager,\n        id: utilities.uuidv4(),\n        operationType: 'labelmap',\n    };\n    return state;\n}\nfunction commitMemo() {\n    if (this.redoVoxelManager) {\n        return true;\n    }\n    if (!this.voxelManager.modifiedSlices.size) {\n        return false;\n    }\n    const { segmentationVoxelManager } = this;\n    const undoVoxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n    RLEVoxelMap.copyMap(undoVoxelManager.map, this.voxelManager.map);\n    for (const key of this.voxelManager.modifiedSlices.keys()) {\n        undoVoxelManager.modifiedSlices.add(key);\n    }\n    this.undoVoxelManager = undoVoxelManager;\n    const redoVoxelManager = VoxelManager.createRLEVolumeVoxelManager({\n        dimensions: this.segmentationVoxelManager.dimensions,\n    });\n    this.redoVoxelManager = redoVoxelManager;\n    undoVoxelManager.forEach(({ index, pointIJK, value }) => {\n        const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);\n        if (currentValue === value) {\n            return;\n        }\n        redoVoxelManager.setAtIndex(index, currentValue);\n    });\n    return true;\n}\n","import { getEnabledElementByIds, volumeLoader, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nexport default async function createLabelmapVolumeForViewport(input) {\n    const { viewportId, renderingEngineId, options } = input;\n    let { segmentationId } = input;\n    const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n    if (!enabledElement) {\n        throw new Error('element disabled');\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof VolumeViewport)) {\n        throw new Error('Segmentation only supports VolumeViewport');\n    }\n    const { uid } = viewport.getDefaultActor();\n    if (segmentationId === undefined) {\n        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? csUtils.uuidv4().slice(0, 8)}`;\n    }\n    if (options) {\n        const properties = structuredClone(options);\n        await volumeLoader.createLocalVolume(segmentationId, properties);\n    }\n    else {\n        const volumeId = viewport.getVolumeId();\n        volumeLoader.createAndCacheDerivedLabelmapVolume(volumeId, {\n            volumeId: segmentationId,\n        });\n    }\n    return segmentationId;\n}\n","import { volumeLoader, utilities as csUtils, cache } from '@cornerstonejs/core';\nfunction createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {\n    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n        if (!csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n            !csUtils.isEqual(direction, labelmaps[0].direction) ||\n            !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n            !csUtils.isEqual(origin, labelmaps[0].origin)) {\n            throw new Error('labelmaps must have the same size and shape');\n        }\n    });\n    const labelmap = labelmaps[0];\n    const arrayType = labelmap.voxelManager.getConstructor();\n    const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());\n    labelmaps.forEach((labelmap) => {\n        const voxelManager = labelmap.voxelManager;\n        const scalarDataLength = voxelManager.getScalarDataLength();\n        for (let i = 0; i < scalarDataLength; i++) {\n            if (voxelManager.getAtIndex(i) === segmentIndex) {\n                outputData[i] = segmentIndex;\n            }\n        }\n    });\n    const options = {\n        scalarData: outputData,\n        metadata: labelmap.metadata,\n        spacing: labelmap.spacing,\n        origin: labelmap.origin,\n        direction: labelmap.direction,\n        dimensions: labelmap.dimensions,\n    };\n    const cachedVolume = cache.getVolume(volumeId);\n    let mergedVolume;\n    if (cachedVolume) {\n        mergedVolume = cachedVolume;\n        mergedVolume.voxelManager.setCompleteScalarDataArray(outputData);\n    }\n    else {\n        mergedVolume = volumeLoader.createLocalVolume(volumeId, options);\n    }\n    return mergedVolume;\n}\nexport default createMergedLabelmapForIndex;\n","import { vec3 } from 'gl-matrix';\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nconst EPSILON = 1e-2;\nexport default function findLargestBidirectional(contours, segVolumeId, segment) {\n    const { sliceContours } = contours;\n    const { segmentIndex, containedSegmentIndices } = segment;\n    let maxBidirectional;\n    const isInSegment = createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices);\n    for (const sliceContour of sliceContours) {\n        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);\n        if (!bidirectional) {\n            continue;\n        }\n        maxBidirectional = bidirectional;\n    }\n    if (maxBidirectional) {\n        Object.assign(maxBidirectional, segment);\n    }\n    return maxBidirectional;\n}\nexport function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {\n    const { points } = sliceContour.polyData;\n    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n    let maxMajor = currentMaxMajor * currentMaxMajor;\n    let maxMinor = currentMaxMinor * currentMaxMinor;\n    let maxMajorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 < maxMajor) {\n                continue;\n            }\n            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMajor = distance2 - EPSILON;\n            maxMajorPoints = [index1, index2];\n            maxMinor = 0;\n        }\n    }\n    if (!maxMajorPoints) {\n        return;\n    }\n    maxMajor = Math.sqrt(maxMajor + EPSILON);\n    const handle0 = points[maxMajorPoints[0]];\n    const handle1 = points[maxMajorPoints[1]];\n    const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n    vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n    let maxMinorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 <= maxMinor) {\n                continue;\n            }\n            const delta = vec3.sub(vec3.create(), point1, point2);\n            const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n            if (dot > EPSILON) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMinor = distance2;\n            maxMinorPoints = [index1, index2];\n        }\n    }\n    if (!maxMinorPoints) {\n        return;\n    }\n    maxMinor = Math.sqrt(maxMinor);\n    const handle2 = points[maxMinorPoints[0]];\n    const handle3 = points[maxMinorPoints[1]];\n    const bidirectional = {\n        majorAxis: [handle0, handle1],\n        minorAxis: [handle2, handle3],\n        maxMajor,\n        maxMinor,\n        ...sliceContour,\n    };\n    return bidirectional;\n}\n","function floodFill(getter, seed, options = {}) {\n    const onFlood = options.onFlood;\n    const onBoundary = options.onBoundary;\n    const equals = options.equals;\n    const filter = options.filter;\n    const diagonals = options.diagonals || false;\n    const startNode = get(seed);\n    const permutations = prunedPermutations();\n    const stack = [];\n    const flooded = [];\n    const visits = new Set();\n    const bounds = options.bounds;\n    stack.push({ currentArgs: seed });\n    while (stack.length > 0) {\n        flood(stack.pop());\n    }\n    return {\n        flooded,\n    };\n    function flood(job) {\n        const getArgs = job.currentArgs;\n        const prevArgs = job.previousArgs;\n        if (visited(getArgs)) {\n            return;\n        }\n        markAsVisited(getArgs);\n        if (member(getArgs)) {\n            markAsFlooded(getArgs);\n            pushAdjacent(getArgs);\n        }\n        else {\n            markAsBoundary(prevArgs);\n        }\n    }\n    function visited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        return visits.has(iKey);\n    }\n    function markAsVisited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        visits.add(iKey);\n    }\n    function member(getArgs) {\n        const node = get(getArgs);\n        return equals ? equals(node, startNode) : node === startNode;\n    }\n    function markAsFlooded(getArgs) {\n        flooded.push(getArgs);\n        if (onFlood) {\n            onFlood(...getArgs);\n        }\n    }\n    function markAsBoundary(prevArgs) {\n        const [x, y, z = 0] = prevArgs;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        bounds?.set(iKey, prevArgs);\n        if (onBoundary) {\n            onBoundary(...prevArgs);\n        }\n    }\n    function pushAdjacent(getArgs) {\n        for (let i = 0; i < permutations.length; i += 1) {\n            const perm = permutations[i];\n            const nextArgs = getArgs.slice(0);\n            for (let j = 0; j < getArgs.length; j += 1) {\n                nextArgs[j] += perm[j];\n            }\n            if (filter?.(nextArgs) === false) {\n                continue;\n            }\n            if (visited(nextArgs)) {\n                continue;\n            }\n            stack.push({\n                currentArgs: nextArgs,\n                previousArgs: getArgs,\n            });\n        }\n    }\n    function get(getArgs) {\n        return getter(...getArgs);\n    }\n    function prunedPermutations() {\n        const permutations = permute(seed.length);\n        return permutations.filter(function (perm) {\n            const count = countNonZeroes(perm);\n            return count !== 0 && (count === 1 || diagonals);\n        });\n    }\n    function permute(length) {\n        const perms = [];\n        const permutation = function (string) {\n            return string.split('').map(function (c) {\n                return parseInt(c, 10) - 1;\n            });\n        };\n        for (let i = 0; i < Math.pow(3, length); i += 1) {\n            const string = lpad(i.toString(3), '0', length);\n            perms.push(permutation(string));\n        }\n        return perms;\n    }\n}\nfunction countNonZeroes(array) {\n    let count = 0;\n    for (let i = 0; i < array.length; i += 1) {\n        if (array[i] !== 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction lpad(string, character, length) {\n    const array = new Array(length + 1);\n    const pad = array.join(character);\n    return (pad + string).slice(-length);\n}\nexport default floodFill;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nexport function getBrushToolInstances(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    if (toolName && toolInstances[toolName]) {\n        return [toolInstances[toolName]];\n    }\n    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool);\n    return brushBasedToolInstances;\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => getAnnotation(annotationUID).highlighted);\n        if (highlightedAnnotationUID) {\n            return segmentIndex;\n        }\n    }\n    return undefined;\n}\n","import { cache, volumeLoader, utilities as csUtils, } from '@cornerstonejs/core';\nfunction getOrCreateImageVolume(referencedImageIds) {\n    if (!referencedImageIds || referencedImageIds.length <= 1) {\n        return;\n    }\n    const isValidVolume = csUtils.isValidVolume(referencedImageIds);\n    if (!isValidVolume) {\n        return;\n    }\n    const volumeId = cache.generateVolumeId(referencedImageIds);\n    let imageVolume = cache.getVolume(volumeId);\n    if (imageVolume) {\n        return imageVolume;\n    }\n    imageVolume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds);\n    return imageVolume;\n}\nexport default getOrCreateImageVolume;\n","import { cache, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getOrCreateSegmentationVolume(segmentationId) {\n    const { representationData } = getSegmentation(segmentationId);\n    let { volumeId } = representationData.Labelmap;\n    let segVolume;\n    if (volumeId) {\n        segVolume = cache.getVolume(volumeId);\n        if (segVolume) {\n            return segVolume;\n        }\n    }\n    const { imageIds: labelmapImageIds } = representationData.Labelmap;\n    volumeId = cache.generateVolumeId(labelmapImageIds);\n    if (!labelmapImageIds || labelmapImageIds.length === 1) {\n        return;\n    }\n    const isValidVolume = utilities.isValidVolume(labelmapImageIds);\n    if (!isValidVolume) {\n        return;\n    }\n    segVolume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);\n    return segVolume;\n}\nexport default getOrCreateSegmentationVolume;\n","import { cache } from '@cornerstonejs/core';\nexport function getReferenceVolumeForSegmentationVolume(segmentationVolumeId) {\n    const segmentationVolume = cache.getVolume(segmentationVolumeId);\n    if (!segmentationVolume) {\n        return null;\n    }\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    let imageVolume;\n    if (referencedVolumeId) {\n        imageVolume = cache.getVolume(referencedVolumeId);\n    }\n    else {\n        const imageIds = segmentationVolume.imageIds;\n        const image = cache.getImage(imageIds[0]);\n        const referencedImageId = image.referencedImageId;\n        const volumeInfo = cache.getVolumeContainingImageId(referencedImageId);\n        imageVolume = volumeInfo?.volume;\n    }\n    return imageVolume;\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { getSegmentation, getCurrentLabelmapImageIdForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers';\nexport function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {\n    const segmentation = getSegmentation(segmentationId);\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const voxelManager = segmentationVolume.voxelManager;\n        const imageData = segmentationVolume.imageData;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n        const canvasPoint = viewport.worldToCanvas(worldPoint);\n        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);\n        return onEdge ? segmentIndex : undefined;\n    }\n    const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);\n    return onEdge ? segmentIndex : undefined;\n}\nfunction isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {\n    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);\n    for (const deltaI of neighborRange) {\n        for (const deltaJ of neighborRange) {\n            for (const deltaK of neighborRange) {\n                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n                    continue;\n                }\n                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {\n        const neighborIJK = [\n            indexIJK[0] + deltaI,\n            indexIJK[1] + deltaJ,\n            indexIJK[2] + deltaK,\n        ];\n        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\nfunction isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ) => {\n        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n        const worldPoint = viewport.canvasToWorld(neighborCanvas);\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getSegmentation, getCurrentLabelmapImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nexport function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const representationData = segmentation.representationData;\n    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];\n    if (!desiredRepresentation) {\n        throw new Error(`Segmentation ${segmentationId} does not have any representations`);\n    }\n    switch (desiredRepresentation) {\n        case SegmentationRepresentations.Labelmap:\n            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);\n        case SegmentationRepresentations.Contour:\n            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);\n        default:\n            return;\n    }\n}\nexport function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n        return segmentIndex;\n    }\n    const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentation.segmentationId);\n    if (segmentationImageIds.length > 1) {\n        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');\n        return;\n    }\n    const segmentationImageId = segmentationImageIds[0];\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentation.segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    return segmentIndex;\n}\nexport function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {\n    const contourData = segmentation.representationData.Contour;\n    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n    const { viewPlaneNormal } = viewport.getCamera();\n    for (const segmentIndex of segmentIndices) {\n        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n        if (!annotationsSet) {\n            continue;\n        }\n        for (const annotationUID of annotationsSet) {\n            const annotation = getAnnotation(annotationUID);\n            if (!annotation) {\n                continue;\n            }\n            const { polyline } = annotation.data.contour;\n            if (!utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {\n                continue;\n            }\n            if (isPointInsidePolyline3D(worldPoint, polyline)) {\n                return Number(segmentIndex);\n            }\n        }\n    }\n}\n","import { getWebWorkerManager } from '@cornerstonejs/core';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport { triggerWorkerProgress, getSegmentationDataForWorker, prepareVolumeStrategyDataForWorker, prepareStackDataForWorker, } from './utilsForWorker';\nexport async function getSegmentLargestBidirectional({ segmentationId, segmentIndices, mode = 'individual', }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 0);\n    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);\n    if (!segData) {\n        return;\n    }\n    const { operationData, segImageIds, reconstructableVolume, indices } = segData;\n    const bidirectionalData = reconstructableVolume\n        ? await calculateVolumeBidirectional({\n            operationData,\n            indices,\n            mode,\n        })\n        : await calculateStackBidirectional({\n            segImageIds,\n            indices,\n            mode,\n        });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 100);\n    return bidirectionalData;\n}\nasync function calculateVolumeBidirectional({ operationData, indices, mode }) {\n    const strategyData = prepareVolumeStrategyDataForWorker(operationData);\n    const { segmentationVoxelManager, segmentationImageData } = strategyData;\n    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions: segmentationImageData.getDimensions(),\n        spacing: segmentationImageData.getSpacing(),\n        origin: segmentationImageData.getOrigin(),\n        direction: segmentationImageData.getDirection(),\n    };\n    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {\n        segmentationInfo,\n        indices,\n        mode,\n    });\n    return bidirectionalData;\n}\nasync function calculateStackBidirectional({ segImageIds, indices, mode }) {\n    const { segmentationInfo } = prepareStackDataForWorker(segImageIds);\n    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {\n        segmentationInfo,\n        indices,\n        mode,\n        isStack: true,\n    });\n    return bidirectionalData;\n}\n","import { utilities, getWebWorkerManager } from '@cornerstonejs/core';\nimport { triggerWorkerProgress, getSegmentationDataForWorker, prepareVolumeStrategyDataForWorker, prepareStackDataForWorker, getImageReferenceInfo, } from './utilsForWorker';\nimport { getPixelValueUnitsImageId } from '../getPixelValueUnits';\nimport VolumetricCalculator from './VolumetricCalculator';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nconst radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);\nasync function getStatistics({ segmentationId, segmentIndices, mode = 'collective', }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);\n    if (!segData) {\n        return;\n    }\n    const { operationData, segVolumeId, segImageIds, reconstructableVolume, indices, } = segData;\n    const { refImageId, modalityUnitOptions } = getImageReferenceInfo(segVolumeId, segImageIds);\n    const unit = getPixelValueUnitsImageId(refImageId, modalityUnitOptions);\n    const stats = reconstructableVolume\n        ? await calculateVolumeStatistics({\n            operationData,\n            indices,\n            unit,\n            mode,\n        })\n        : await calculateStackStatistics({\n            segImageIds,\n            indices,\n            unit,\n            mode,\n        });\n    return stats;\n}\nasync function calculateVolumeStatistics({ operationData, indices, unit, mode, }) {\n    const strategyData = prepareVolumeStrategyDataForWorker(operationData);\n    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, imageData, } = strategyData;\n    if (!segmentationVoxelManager || !segmentationImageData) {\n        return;\n    }\n    const spacing = segmentationImageData.getSpacing();\n    const { boundsIJK: boundsOrig } = segmentationVoxelManager;\n    if (!boundsOrig) {\n        return VolumetricCalculator.getStatistics({ spacing });\n    }\n    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions: segmentationImageData.getDimensions(),\n        spacing: segmentationImageData.getSpacing(),\n        origin: segmentationImageData.getOrigin(),\n        direction: segmentationImageData.getDirection(),\n    };\n    const imageInfo = {\n        scalarData: imageVoxelManager.getCompleteScalarDataArray(),\n        dimensions: imageData.getDimensions(),\n        spacing: imageData.getSpacing(),\n        origin: imageData.getOrigin(),\n        direction: imageData.getDirection(),\n    };\n    if (!imageInfo.scalarData?.length) {\n        return;\n    }\n    const stats = await getWebWorkerManager().executeTask('compute', 'calculateSegmentsStatisticsVolume', {\n        segmentationInfo,\n        imageInfo,\n        indices,\n        unit,\n        mode,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    if (mode === 'collective') {\n        return processSegmentationStatistics({\n            stats,\n            unit,\n            spacing,\n            segmentationImageData,\n            imageVoxelManager,\n        });\n    }\n    else {\n        const finalStats = {};\n        Object.entries(stats).forEach(([segmentIndex, stat]) => {\n            finalStats[segmentIndex] = processSegmentationStatistics({\n                stats: stat,\n                unit,\n                spacing,\n                segmentationImageData,\n                imageVoxelManager,\n            });\n        });\n        return finalStats;\n    }\n}\nconst updateStatsArray = (stats, newStat) => {\n    if (!stats.array) {\n        return;\n    }\n    const existingIndex = stats.array.findIndex((stat) => stat.name === newStat.name);\n    if (existingIndex !== -1) {\n        stats.array[existingIndex] = newStat;\n    }\n    else {\n        stats.array.push(newStat);\n    }\n};\nconst processSegmentationStatistics = ({ stats, unit, spacing, segmentationImageData, imageVoxelManager, }) => {\n    stats.mean.unit = unit;\n    stats.max.unit = unit;\n    stats.min.unit = unit;\n    if (unit !== 'SUV') {\n        return stats;\n    }\n    const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));\n    for (const testMax of stats.maxIJKs) {\n        const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);\n        if (!testStats) {\n            continue;\n        }\n        const { mean } = testStats;\n        if (!stats.peakValue || stats.peakValue.value <= mean.value) {\n            stats.peakValue = {\n                name: 'peakValue',\n                label: 'Peak Value',\n                value: mean.value,\n                unit,\n            };\n            stats.peakPoint = {\n                name: 'peakLPS',\n                label: 'Peak SUV Point',\n                value: testMax.pointLPS ? [...testMax.pointLPS] : null,\n                unit: null,\n            };\n            updateStatsArray(stats, stats.peakValue);\n            updateStatsArray(stats, stats.peakPoint);\n        }\n    }\n    if (stats.volume && stats.mean) {\n        const mtv = stats.volume.value;\n        const suvMean = stats.mean.value;\n        stats.lesionGlycolysis = {\n            name: 'lesionGlycolysis',\n            label: 'Lesion Glycolysis',\n            value: mtv * suvMean,\n            unit: `${stats.volume.unit}${unit}`,\n        };\n        updateStatsArray(stats, stats.lesionGlycolysis);\n    }\n    return stats;\n};\nasync function calculateStackStatistics({ segImageIds, indices, unit, mode }) {\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const { segmentationInfo, imageInfo } = prepareStackDataForWorker(segImageIds);\n    const stats = await getWebWorkerManager().executeTask('compute', 'calculateSegmentsStatisticsStack', {\n        segmentationInfo,\n        imageInfo,\n        indices,\n        mode,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    const spacing = segmentationInfo[0].spacing;\n    const segmentationImageData = segmentationInfo[0];\n    const imageVoxelManager = imageInfo[0].voxelManager;\n    if (mode === 'collective') {\n        return processSegmentationStatistics({\n            stats,\n            unit,\n            spacing,\n            segmentationImageData,\n            imageVoxelManager,\n        });\n    }\n    else {\n        const finalStats = {};\n        Object.entries(stats).forEach(([segmentIndex, stat]) => {\n            finalStats[segmentIndex] = processSegmentationStatistics({\n                stats: stat,\n                unit,\n                spacing,\n                segmentationImageData,\n                imageVoxelManager,\n            });\n        });\n        return finalStats;\n    }\n}\nfunction getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {\n    const { pointIJK: centerIJK, pointLPS: centerLPS } = testMax;\n    if (!centerIJK) {\n        return;\n    }\n    const boundsIJK = centerIJK.map((ijk, idx) => [\n        ijk - radiusIJK[idx],\n        ijk + radiusIJK[idx],\n    ]);\n    const testFunction = (_pointLPS, pointIJK) => {\n        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];\n        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];\n        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];\n        const radius = i * i + j * j + k * k;\n        return radius <= 1;\n    };\n    const statsFunction = ({ pointIJK, pointLPS }) => {\n        const value = imageVoxels.getAtIJKPoint(pointIJK);\n        if (value === undefined) {\n            return;\n        }\n        VolumetricCalculator.statsCallback({ value, pointLPS, pointIJK });\n    };\n    VolumetricCalculator.statsInit({ storePointData: false });\n    utilities.pointInShapeCallback(segData, {\n        pointInShapeFn: testFunction,\n        callback: statsFunction,\n        boundsIJK,\n    });\n    return VolumetricCalculator.getStatistics({ spacing });\n}\nexport default getStatistics;\n","import { cache } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getCachedSegmentIndices, setCachedSegmentIndices } from './utilities';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getUniqueSegmentIndices(segmentationId) {\n    const cachedResult = getCachedSegmentIndices(segmentationId);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);\n    }\n    let indices;\n    if (segmentation.representationData.Labelmap) {\n        indices = handleLabelmapSegmentation(segmentation, segmentationId);\n    }\n    else if (segmentation.representationData.Contour) {\n        indices = handleContourSegmentation(segmentation);\n    }\n    else if (segmentation.representationData.Surface) {\n        indices = handleSurfaceSegmentation(segmentation);\n    }\n    else {\n        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);\n    }\n    setCachedSegmentIndices(segmentationId, indices);\n    return indices;\n}\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n    const labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    const keySet = new Set();\n    if (labelmapData.imageIds) {\n        addImageSegmentIndices(keySet, labelmapData.imageIds);\n    }\n    else {\n        addVolumeSegmentIndices(keySet, segmentationId);\n    }\n    return Array.from(keySet)\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n    const volume = cache.getVolume(segmentationId);\n    volume.voxelManager.forEach(({ value }) => {\n        if (value !== 0) {\n            keySet.add(value);\n        }\n    });\n}\nfunction addImageSegmentIndices(keySet, imageIds) {\n    imageIds.forEach((segmentationImageId) => {\n        const image = cache.getImage(segmentationImageId);\n        const scalarData = image.voxelManager.getScalarData();\n        scalarData.forEach((segmentIndex) => {\n            if (segmentIndex !== 0) {\n                keySet.add(segmentIndex);\n            }\n        });\n    });\n}\nfunction handleContourSegmentation(segmentation) {\n    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};\n    if (!geometryIds) {\n        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);\n    }\n    const indices = new Set([...annotationUIDsMap.keys()]);\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        indices.add(geometry.data.segmentIndex);\n    });\n    return Array.from(indices).sort((a, b) => a - b);\n}\nfunction handleSurfaceSegmentation(segmentation) {\n    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];\n    return Array.from(geometryIds.keys())\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nexport { getUniqueSegmentIndices };\n","const shader = `\nconst MAX_STRENGTH = 65535f;\n\n// Workgroup size - X*Y*Z must be multiple of 32 for better performance\noverride workGroupSizeX = 1u;\noverride workGroupSizeY = 1u;\noverride workGroupSizeZ = 1u;\n\n// Compare the current voxel to neighbors using a 9x9x9 window\noverride windowSize = 9i;\n\nstruct Params {\n  size: vec3u,\n  iteration: u32,\n}\n\n// New structure to track bounds of modified voxels\nstruct Bounds {\n  minX: atomic<i32>,\n  minY: atomic<i32>,\n  minZ: atomic<i32>,\n  maxX: atomic<i32>,\n  maxY: atomic<i32>,\n  maxZ: atomic<i32>,\n}\n\n@group(0) @binding(0) var<uniform> params: Params;\n@group(0) @binding(1) var<storage> volumePixelData: array<f32>;\n@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;\n@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;\n@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;\n@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;\n@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;\n@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;\n\nfn getPixelIndex(ijkPos: vec3u) -> u32 {\n  let numPixelsPerSlice = params.size.x * params.size.y;\n  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;\n}\n\nfn updateBounds(position: vec3i) {\n  // Atomically update min bounds (use min operation)\n  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);\n  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);\n  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);\n\n  // Atomically update max bounds (use max operation)\n  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);\n  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);\n  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);\n}\n\n@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\nfn main(\n  @builtin(global_invocation_id) globalId: vec3u,\n) {\n  // Make sure it will not get out of bounds for volume with sizes that\n  // are not multiple of workGroupSize\n  if (\n    globalId.x >= params.size.x ||\n    globalId.y >= params.size.y ||\n    globalId.z >= params.size.z\n  ) {\n    return;\n  }\n\n  // Initialize bounds for the first iteration\n  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {\n    // Initialize to opposite extremes to ensure any update will improve the bounds\n    atomicStore(&modifiedBounds.minX, i32(params.size.x));\n    atomicStore(&modifiedBounds.minY, i32(params.size.y));\n    atomicStore(&modifiedBounds.minZ, i32(params.size.z));\n    atomicStore(&modifiedBounds.maxX, -1);\n    atomicStore(&modifiedBounds.maxY, -1);\n    atomicStore(&modifiedBounds.maxZ, -1);\n  }\n\n  let currentCoord = vec3i(globalId);\n  let currentPixelIndex = getPixelIndex(globalId);\n\n  let numPixels = arrayLength(&volumePixelData);\n  let currentPixelValue = volumePixelData[currentPixelIndex];\n\n  if (params.iteration == 0) {\n    // All non-zero initial labels are given maximum strength\n    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);\n\n    // Update bounds for non-zero initial labels\n    if (labelmap[currentPixelIndex] != 0) {\n      updateBounds(currentCoord);\n    }\n    return;\n  }\n\n  // It should at least copy the values from previous state\n  var newLabel = prevLabelmap[currentPixelIndex];\n  var newStrength = prevStrengthData[currentPixelIndex];\n\n  let window = i32(ceil(f32(windowSize - 1) * .5));\n  let minWindow = -1i * window;\n  let maxWindow = 1i * window;\n\n  for (var k = minWindow; k <= maxWindow; k++) {\n    for (var j = minWindow; j <= maxWindow; j++) {\n      for (var i = minWindow; i <= maxWindow; i++) {\n        // Skip current voxel\n        if (i == 0 && j == 0 && k == 0) {\n          continue;\n        }\n\n        let neighborCoord = currentCoord + vec3i(i, j, k);\n\n        //  Boundary conditions. Do not grow outside of the volume\n        if (\n          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||\n          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||\n          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)\n        ) {\n          continue;\n        }\n\n        let neighborIndex = getPixelIndex(vec3u(neighborCoord));\n        let neighborPixelValue = volumePixelData[neighborIndex];\n        let prevNeighborStrength = prevStrengthData[neighborIndex];\n        let strengthCost = abs(neighborPixelValue - currentPixelValue);\n        let takeoverStrength = prevNeighborStrength - strengthCost;\n\n        if (takeoverStrength > newStrength) {\n          newLabel = prevLabelmap[neighborIndex];\n          newStrength = takeoverStrength;\n        }\n      }\n    }\n  }\n\n  if (labelmap[currentPixelIndex] != newLabel) {\n    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);\n\n    // Update bounds for modified voxels\n    updateBounds(currentCoord);\n  }\n\n  labelmap[currentPixelIndex] = newLabel;\n  strengthData[currentPixelIndex] = newStrength;\n}\n`;\nexport default shader;\n","import { cache } from '@cornerstonejs/core';\nimport shaderCode from './growCutShader';\nconst GB = 1024 * 1024 * 1024;\nconst WEBGPU_MEMORY_LIMIT = 1.99 * GB;\nconst DEFAULT_GROWCUT_OPTIONS = {\n    windowSize: 3,\n    maxProcessingTime: 30000,\n    inspection: {\n        numCyclesInterval: 5,\n        numCyclesBelowThreshold: 3,\n        threshold: 1e-4,\n    },\n};\nasync function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {\n    const workGroupSize = [8, 8, 4];\n    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);\n    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);\n    const volume = cache.getVolume(referenceVolumeId);\n    const labelmap = cache.getVolume(labelmapVolumeId);\n    const [columns, rows, numSlices] = volume.dimensions;\n    if (labelmap.dimensions[0] !== columns ||\n        labelmap.dimensions[1] !== rows ||\n        labelmap.dimensions[2] !== numSlices) {\n        throw new Error('Volume and labelmap must have the same size');\n    }\n    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);\n    numIterations = Math.min(numIterations, 500);\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();\n    if (!(volumePixelData instanceof Float32Array)) {\n        volumePixelData = new Float32Array(volumePixelData);\n    }\n    const requiredLimits = {\n        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,\n        maxBufferSize: WEBGPU_MEMORY_LIMIT,\n    };\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = await adapter.requestDevice({ requiredLimits });\n    const BUFFER_SIZE = volumePixelData.byteLength;\n    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;\n    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;\n    const shaderModule = device.createShaderModule({\n        code: shaderCode,\n    });\n    const numIterationIndex = 3;\n    const paramsArrayValues = new Uint32Array([\n        columns,\n        rows,\n        numSlices,\n        0,\n    ]);\n    const gpuParamsBuffer = device.createBuffer({\n        size: paramsArrayValues.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const gpuVolumePixelDataBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);\n    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    }));\n    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));\n    const gpuStrengthBuffers = [0, 1].map(() => {\n        const strengthBuffer = device.createBuffer({\n            size: BUFFER_SIZE,\n            usage: GPUBufferUsage.STORAGE |\n                GPUBufferUsage.COPY_SRC |\n                GPUBufferUsage.COPY_DST,\n        });\n        return strengthBuffer;\n    });\n    const gpuCounterBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const gpuBoundsBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const initialBounds = new Int32Array([\n        columns,\n        rows,\n        numSlices,\n        -1,\n        -1,\n        -1,\n    ]);\n    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'uniform',\n                },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n        ],\n    });\n    const bindGroups = [0, 1].map((i) => {\n        const outputLabelmapBuffer = gpuLabelmapBuffers[i];\n        const outputStrengthBuffer = gpuStrengthBuffers[i];\n        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];\n        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];\n        return device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: gpuParamsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: gpuVolumePixelDataBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: outputLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: outputStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 4,\n                    resource: {\n                        buffer: previouLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 5,\n                    resource: {\n                        buffer: previousStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 6,\n                    resource: {\n                        buffer: gpuCounterBuffer,\n                    },\n                },\n                {\n                    binding: 7,\n                    resource: {\n                        buffer: gpuBoundsBuffer,\n                    },\n                },\n            ],\n        });\n    });\n    const pipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n        }),\n        compute: {\n            module: shaderModule,\n            entryPoint: 'main',\n            constants: {\n                workGroupSizeX: workGroupSize[0],\n                workGroupSizeY: workGroupSize[1],\n                workGroupSizeZ: workGroupSize[2],\n                windowSize,\n            },\n        },\n    });\n    const numWorkGroups = [\n        Math.ceil(columns / workGroupSize[0]),\n        Math.ceil(rows / workGroupSize[1]),\n        Math.ceil(numSlices / workGroupSize[2]),\n    ];\n    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const limitProcessingTime = maxProcessingTime\n        ? performance.now() + maxProcessingTime\n        : 0;\n    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n    let belowThresholdCounter = 0;\n    for (let i = 0; i < numIterations; i++) {\n        paramsArrayValues[numIterationIndex] = i;\n        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);\n        const commandEncoder = device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroups[i % 2]);\n        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);\n        passEncoder.end();\n        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);\n        device.queue.submit([commandEncoder.finish()]);\n        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);\n        if (inspect) {\n            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));\n            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;\n            gpuUpdatedVoxelsCounterStagingBuffer.unmap();\n            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {\n                currentInspectionNumCyclesInterval = 1;\n                belowThresholdCounter++;\n                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {\n                    break;\n                }\n            }\n            else {\n                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n            }\n        }\n        if (limitProcessingTime && performance.now() > limitProcessingTime) {\n            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);\n            break;\n        }\n    }\n    const commandEncoder = device.createCommandEncoder();\n    const outputLabelmapBufferIndex = (numIterations + 1) % 2;\n    const labelmapStagingBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const boundsStagingBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);\n    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);\n    device.queue.submit([commandEncoder.finish()]);\n    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);\n    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);\n    const labelmapResult = new Uint32Array(labelmapResultBuffer);\n    labelmapData.set(labelmapResult);\n    labelmapStagingBuffer.unmap();\n    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);\n    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);\n    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));\n    boundsStagingBuffer.unmap();\n    const minX = boundsResult[0];\n    const minY = boundsResult[1];\n    const minZ = boundsResult[2];\n    const maxX = boundsResult[3];\n    const maxY = boundsResult[4];\n    const maxZ = boundsResult[5];\n    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);\n    labelmap.voxelManager.clearBounds();\n    labelmap.voxelManager.setBounds([\n        [minX, maxX],\n        [minY, maxY],\n        [minZ, maxZ],\n    ]);\n}\nexport { runGrowCut as default, runGrowCut as run };\n","import { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nfunction _setNegativeSeedValues(subVolume, labelmap, options) {\n    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const visited = new Array(width * height).fill(false);\n    const sliceOffset = middleSliceIndex * width * height;\n    const bfs = (startX, startY) => {\n        const queue = [[startX, startY]];\n        while (queue.length) {\n            const [x, y] = queue.shift();\n            const slicePixelIndex = y * width + x;\n            if (x < 0 ||\n                x >= width ||\n                y < 0 ||\n                y >= height ||\n                visited[slicePixelIndex]) {\n                continue;\n            }\n            visited[slicePixelIndex] = true;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);\n            queue.push([x - 1, y]);\n            queue.push([x + 1, y]);\n            queue.push([x, y - 1]);\n            queue.push([x, y + 1]);\n        }\n    };\n    const scanLine = (startX, limitX, incX, y) => {\n        for (let x = startX; x !== limitX; x += incX) {\n            const slicePixelIndex = y * width + x;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                break;\n            }\n            if (!visited[slicePixelIndex]) {\n                bfs(x, y);\n            }\n        }\n    };\n    for (let y = 0; y < height; y++) {\n        scanLine(0, width - 1, 1, y);\n        scanLine(width - 1, 0, -1, y);\n    }\n}\nfunction _setPositiveSeedValues(subVolume, labelmap, options) {\n    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);\n    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);\n    const pixelsPerSlice = width * height;\n    for (let z = startSliceIndex; z < stopSliceIndex; z++) {\n        const zOffset = z * pixelsPerSlice;\n        for (let y = 0; y < height; y++) {\n            const yOffset = y * width;\n            for (let x = 0; x < width; x++) {\n                const index = zOffset + yOffset + x;\n                const pixelValue = subVolPixelData[index];\n                const isPositiveValue = pixelValue >= positivePixelRange[0] &&\n                    pixelValue <= positivePixelRange[1];\n                if (isPositiveValue) {\n                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);\n                }\n            }\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, options);\n    _setNegativeSeedValues(subVolume, labelmap, options);\n    return labelmap;\n}\nasync function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {\n    const { boundingBox } = boundingBoxInfo;\n    const { ijkTopLeft, ijkBottomRight } = boundingBox;\n    const subVolumeBoundsIJK = {\n        minX: ijkTopLeft[0],\n        maxX: ijkBottomRight[0],\n        minY: ijkTopLeft[1],\n        maxY: ijkBottomRight[1],\n        minZ: ijkTopLeft[2],\n        maxZ: ijkBottomRight[2],\n    };\n    const subVolume = csUtils.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForBoundingBox as default, runGrowCutForBoundingBox };\n","import { quat, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { getSphereBoundsInfo } from '../../getSphereBoundsInfo';\nconst { transformWorldToIndex } = csUtils;\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst POSITIVE_SEED_VARIANCE = 0.1;\nconst NEGATIVE_SEED_VARIANCE = 0.8;\nfunction _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {\n    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;\n    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);\n    return {\n        ...sphereBoundsInfo,\n        topLeftIJK,\n        bottomRightIJK,\n    };\n}\nfunction _getSphereBoundsInfo(referencedVolume, sphereInfo) {\n    const direction = referencedVolume.imageData.getDirection();\n    const vecColumn = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;\n    const refVolImageData = referencedVolume.imageData;\n    const topCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);\n    const bottomCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);\n    const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);\n    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);\n}\nfunction _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {\n    const refVolImageData = referencedVolume.imageData;\n    const camera = viewport.getCamera();\n    const { ijkVecRowDir, ijkVecColDir } = csUtils.getVolumeDirectionVectors(refVolImageData, camera);\n    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !csUtils.isEqual(Math.abs(vec[0]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[1]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[2]), 1));\n    if (obliqueView) {\n        console.warn('Oblique view is not supported!');\n        return;\n    }\n    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);\n    const subVolumeBoundsIJK = {\n        minX: sphereBoundsIJK[0][0],\n        maxX: sphereBoundsIJK[0][1] + 1,\n        minY: sphereBoundsIJK[1][0],\n        maxY: sphereBoundsIJK[1][1] + 1,\n        minZ: sphereBoundsIJK[2][0],\n        maxZ: sphereBoundsIJK[2][1] + 1,\n    };\n    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n}\nfunction _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {\n    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    const worldStartPos = sphereInfo.center;\n    const [width, height, numSlices] = referencedVolume.dimensions;\n    const numPixelsPerSlice = width * height;\n    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);\n    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0]];\n    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;\n    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;\n    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);\n    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;\n    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0];\n    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);\n    const queue = [ijkStartPosition];\n    while (queue.length) {\n        const ijkVoxel = queue.shift();\n        const [x, y, z] = ijkVoxel;\n        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {\n            const neighborCoordDelta = neighborsCoordDelta[i];\n            const nx = x + neighborCoordDelta[0];\n            const ny = y + neighborCoordDelta[1];\n            const nz = z + neighborCoordDelta[2];\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;\n            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];\n            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);\n            if (neighborLabelmapValue === positiveSeedValue ||\n                neighborPixelValue < minPositivePixelValue ||\n                neighborPixelValue > maxPositivePixelValue) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);\n            queue.push([nx, ny, nz]);\n        }\n    }\n}\nfunction _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [columns, rows, numSlices] = labelmap.dimensions;\n    const numPixelsPerSlice = columns * rows;\n    const { worldVecRowDir, worldVecSliceDir } = csUtils.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());\n    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);\n    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +\n        ijkSphereCenter[1] * columns +\n        ijkSphereCenter[0]];\n    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;\n    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;\n    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);\n    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;\n    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;\n    const numCirclePoints = 360;\n    const rotationAngle = (2 * Math.PI) / numCirclePoints;\n    const worldQuat = quat.setAxisAngle(quat.create(), worldVecSliceDir, rotationAngle);\n    const vecRotation = vec3.clone(worldVecRowDir);\n    for (let i = 0; i < numCirclePoints; i++) {\n        const worldCircleBorderPoint = vec3.scaleAndAdd(vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);\n        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);\n        const [x, y, z] = ijkCircleBorderPoint;\n        vec3.transformQuat(vecRotation, vecRotation, worldQuat);\n        if (x < 0 ||\n            x >= columns ||\n            y < 0 ||\n            y >= rows ||\n            z < 0 ||\n            z >= numSlices) {\n            continue;\n        }\n        const offset = x + y * columns + z * numPixelsPerSlice;\n        const pixelValue = subVolPixelData[offset];\n        if (pixelValue < minNegativePixelValue ||\n            pixelValue > maxNegativePixelValue) {\n            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {\n    const labelmap = await volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);\n    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);\n    return labelmap;\n}\nasync function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);\n    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForSphere as default, runGrowCutForSphere };\n","import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { POSITIVE_SEED_LABEL, NEGATIVE_SEED_LABEL, DEFAULT_NEIGHBORHOOD_RADIUS, DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, DEFAULT_NEGATIVE_SEEDS_COUNT, MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER, } from './constants';\nconst { transformWorldToIndex } = csUtils;\nconst MAX_POSITIVE_SEEDS = 100000;\nfunction calculateGrowCutSeeds(referencedVolume, worldPosition, options) {\n    const { dimensions, imageData: refImageData } = referencedVolume;\n    const [width, height, numSlices] = dimensions;\n    const referenceVolumeVoxelManager = referencedVolume.voxelManager;\n    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();\n    const numPixelsPerSlice = width * height;\n    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? DEFAULT_NEIGHBORHOOD_RADIUS;\n    const positiveK = options?.positiveStdDevMultiplier ?? DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;\n    const negativeK = options?.negativeStdDevMultiplier ?? DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;\n    const negativeSeedMargin = options?.negativeSeedMargin ?? DEFAULT_NEGATIVE_SEED_MARGIN;\n    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? DEFAULT_NEGATIVE_SEEDS_COUNT;\n    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);\n    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);\n    if (ijkStart[0] < 0 ||\n        ijkStart[0] >= width ||\n        ijkStart[1] < 0 ||\n        ijkStart[1] >= height ||\n        ijkStart[2] < 0 ||\n        ijkStart[2] >= numSlices) {\n        console.warn('Click position is outside volume bounds.');\n        return null;\n    }\n    const initialStats = csUtils.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);\n    if (initialStats.count === 0) {\n        initialStats.mean = scalarData[startIndex];\n        initialStats.stdDev = 0;\n    }\n    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;\n    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    let minX = Infinity, minY = Infinity, minZ = Infinity;\n    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n    const positiveSeedIndices = new Set();\n    const queue = [];\n    const startValue = scalarData[startIndex];\n    if (startValue >= positiveIntensityMin &&\n        startValue <= positiveIntensityMax) {\n        positiveSeedIndices.add(startIndex);\n        queue.push(ijkStart);\n        minX = maxX = ijkStart[0];\n        minY = maxY = ijkStart[1];\n        minZ = maxZ = ijkStart[2];\n    }\n    else {\n        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let currentQueueIndex = 0;\n    while (currentQueueIndex < queue.length &&\n        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n        const [x, y, z] = queue[currentQueueIndex++];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        minZ = Math.min(z, minZ);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n        maxZ = Math.max(z, maxZ);\n        for (let i = 0; i < neighborsCoordDelta.length; i++) {\n            const [dx, dy, dz] = neighborsCoordDelta[i];\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;\n            if (positiveSeedIndices.has(neighborIndex)) {\n                continue;\n            }\n            const neighborValue = scalarData[neighborIndex];\n            if (neighborValue >= positiveIntensityMin &&\n                neighborValue <= positiveIntensityMax) {\n                positiveSeedIndices.add(neighborIndex);\n                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n                    queue.push([nx, ny, nz]);\n                }\n            }\n        }\n    }\n    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {\n        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);\n    }\n    if (positiveSeedIndices.size === 0) {\n        console.warn('No positive seeds found after BFS.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let positiveSum = 0;\n    let positiveSumSq = 0;\n    positiveSeedIndices.forEach((index) => {\n        const value = scalarData[index];\n        positiveSum += value;\n        positiveSumSq += value * value;\n    });\n    const positiveCount = positiveSeedIndices.size;\n    const positiveMean = positiveSum / positiveCount;\n    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;\n    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));\n    const negativeDiffThreshold = negativeK * positiveStdDev;\n    const minXm = Math.max(0, minX - negativeSeedMargin);\n    const minYm = Math.max(0, minY - negativeSeedMargin);\n    const minZm = Math.max(0, minZ - negativeSeedMargin);\n    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);\n    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);\n    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);\n    const negativeSeedIndices = new Set();\n    let attempts = 0;\n    let patchesAdded = 0;\n    const maxAttempts = negativeSeedsTargetPatches * MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;\n    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {\n        attempts++;\n        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);\n        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);\n        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);\n        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;\n        if (positiveSeedIndices.has(centerIndex) ||\n            negativeSeedIndices.has(centerIndex)) {\n            continue;\n        }\n        const centerValue = scalarData[centerIndex];\n        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {\n            let patchContributed = false;\n            for (let dy = -1; dy <= 1; dy++) {\n                const ny = ry + dy;\n                if (ny < 0 || ny >= height) {\n                    continue;\n                }\n                for (let dx = -1; dx <= 1; dx++) {\n                    const nx = rx + dx;\n                    if (nx < 0 || nx >= width) {\n                        continue;\n                    }\n                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;\n                    if (positiveSeedIndices.has(neighborIndex) ||\n                        negativeSeedIndices.has(neighborIndex)) {\n                        continue;\n                    }\n                    negativeSeedIndices.add(neighborIndex);\n                    patchContributed = true;\n                }\n            }\n            if (patchContributed) {\n                patchesAdded++;\n            }\n        }\n    }\n    if (negativeSeedIndices.size === 0) {\n        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');\n    }\n    console.debug('positiveSeedIndices', positiveSeedIndices.size);\n    console.debug('negativeSeedIndices', negativeSeedIndices.size);\n    return { positiveSeedIndices, negativeSeedIndices };\n}\nasync function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);\n    labelmap.voxelManager.forEach(({ index, value }) => {\n        if (value !== 0) {\n            labelmap.voxelManager.setAtIndex(index, 0);\n        }\n    });\n    const seeds = options.seeds ??\n        calculateGrowCutSeeds(referencedVolume, worldPosition, options);\n    const positiveSeedLabel = options?.positiveSeedValue ?? POSITIVE_SEED_LABEL;\n    const negativeSeedLabel = options?.negativeSeedValue ?? NEGATIVE_SEED_LABEL;\n    if (!seeds) {\n        return null;\n    }\n    const { positiveSeedIndices, negativeSeedIndices } = seeds;\n    if (positiveSeedIndices.size < 10 ||\n        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||\n        negativeSeedIndices.size < 10) {\n        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');\n        return labelmap;\n    }\n    positiveSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);\n    });\n    negativeSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);\n    });\n    await run(referencedVolumeId, labelmap.volumeId, options);\n    return labelmap;\n}\nexport { runOneClickGrowCut as default, runOneClickGrowCut, calculateGrowCutSeeds, };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function invalidateBrushCursor(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\n","import { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nexport default function isLineInSegment(point1, point2, isInSegment) {\n    const ijk1 = isInSegment.toIJK(point1);\n    const ijk2 = isInSegment.toIJK(point2);\n    const testPoint = vec3.create();\n    const { testIJK } = isInSegment;\n    const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n    const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n    if (testSize < 2) {\n        return true;\n    }\n    const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n    for (let i = 1; i < testSize; i++) {\n        vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n        if (!testIJK(testPoint)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {\n    const width = dimensions[0];\n    const pixelsPerSlice = width * dimensions[1];\n    return {\n        testCenter: (point1, point2) => {\n            const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n            const ijk = imageData.worldToIndex(point).map(Math.round);\n            const [i, j, k] = ijk;\n            const index = i + j * width + k * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n        toIJK: (point) => imageData.worldToIndex(point),\n        testIJK: (ijk) => {\n            const [i, j, k] = ijk;\n            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n    };\n}\nfunction createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {\n    const vol = cache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    return createIsInSegmentMetadata({\n        dimensions: vol.dimensions,\n        imageData: vol.imageData,\n        voxelManager: vol.voxelManager,\n        segmentIndex,\n        containedSegmentIndices,\n    });\n}\nexport { createIsInSegment, createIsInSegmentMetadata, isLineInSegment };\n","import { utilities } from '@cornerstonejs/core';\nimport normalizeViewportPlane from '../normalizeViewportPlane';\nconst { RLEVoxelMap, VoxelManager } = utilities;\nconst MAX_IMAGE_SIZE = 65535;\nexport var SegmentationEnum;\n(function (SegmentationEnum) {\n    SegmentationEnum[SegmentationEnum[\"SEGMENT\"] = -1] = \"SEGMENT\";\n    SegmentationEnum[SegmentationEnum[\"ISLAND\"] = -2] = \"ISLAND\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR\"] = -3] = \"INTERIOR\";\n    SegmentationEnum[SegmentationEnum[\"EXTERIOR\"] = -4] = \"EXTERIOR\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR_SMALL\"] = -5] = \"INTERIOR_SMALL\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR_TEST\"] = -6] = \"INTERIOR_TEST\";\n})(SegmentationEnum || (SegmentationEnum = {}));\nexport default class IslandRemoval {\n    constructor(options) {\n        this.fillInternalEdge = false;\n        this.maxInternalRemove = 128;\n        this.maxInternalRemove =\n            options?.maxInternalRemove ?? this.maxInternalRemove;\n        this.fillInternalEdge = options?.fillInternalEdge ?? this.fillInternalEdge;\n    }\n    initialize(viewport, segmentationVoxels, options) {\n        const hasSource = !!segmentationVoxels.sourceVoxelManager;\n        const segmentationVoxelManager = hasSource\n            ? segmentationVoxels.sourceVoxelManager\n            : segmentationVoxels;\n        const previewVoxelManager = hasSource\n            ? segmentationVoxels\n            : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n        const { segmentIndex = 1, previewSegmentIndex = 1 } = options;\n        const clickedPoints = options.points || segmentationVoxelManager.getPoints();\n        if (!clickedPoints?.length) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager\n            .getBoundsIJK()\n            .map((bound, i) => [\n            Math.min(bound[0], ...clickedPoints.map((point) => point[i])),\n            Math.max(bound[1], ...clickedPoints.map((point) => point[i])),\n        ]);\n        if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {\n            return;\n        }\n        const { toIJK, fromIJK, boundsIJKPrime, error } = normalizeViewportPlane(viewport, boundsIJK);\n        if (error) {\n            console.warn('Not performing island removal for planes not orthogonal to acquisition plane', error);\n            return;\n        }\n        const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);\n        const segmentSet = new RLEVoxelMap(width, height, depth);\n        const getter = (i, j, k) => {\n            const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));\n            const oldVal = segmentationVoxelManager.getAtIndex(index);\n            if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {\n                return SegmentationEnum.SEGMENT;\n            }\n        };\n        segmentSet.fillFrom(getter, boundsIJKPrime);\n        segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };\n        this.segmentSet = segmentSet;\n        this.previewVoxelManager = previewVoxelManager;\n        this.segmentIndex = segmentIndex;\n        this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;\n        this.selectedPoints = clickedPoints;\n        return true;\n    }\n    floodFillSegmentIsland() {\n        const { selectedPoints: clickedPoints, segmentSet } = this;\n        let floodedCount = 0;\n        const { fromIJK } = segmentSet.normalizer;\n        clickedPoints.forEach((clickedPoint) => {\n            const ijkPrime = fromIJK(clickedPoint);\n            const index = segmentSet.toIndex(ijkPrime);\n            const [iPrime, jPrime, kPrime] = ijkPrime;\n            if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {\n                floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);\n            }\n        });\n        return floodedCount;\n    }\n    removeExternalIslands() {\n        const { previewVoxelManager, segmentSet } = this;\n        const { toIJK } = segmentSet.normalizer;\n        const callback = (index, rle) => {\n            const [, jPrime, kPrime] = segmentSet.toIJK(index);\n            if (rle.value !== SegmentationEnum.ISLAND) {\n                for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {\n                    const clearPoint = toIJK([iPrime, jPrime, kPrime]);\n                    const v = previewVoxelManager.getAtIJKPoint(clearPoint);\n                    previewVoxelManager.setAtIJKPoint(clearPoint, v === undefined ? 0 : null);\n                }\n            }\n        };\n        segmentSet.forEach(callback, { rowModified: true });\n    }\n    removeInternalIslands() {\n        const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;\n        const { height, normalizer, width } = segmentSet;\n        const { toIJK } = normalizer;\n        segmentSet.forEachRow((baseIndex, row) => {\n            let lastRle;\n            for (const rle of [...row]) {\n                if (rle.value !== SegmentationEnum.ISLAND) {\n                    continue;\n                }\n                if (!lastRle) {\n                    if (this.fillInternalEdge && rle.start > 0) {\n                        for (let iPrime = 0; iPrime < rle.start; iPrime++) {\n                            segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                        }\n                    }\n                    lastRle = rle;\n                    continue;\n                }\n                for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {\n                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                }\n                lastRle = rle;\n            }\n            if (this.fillInternalEdge && lastRle?.end < width) {\n                for (let iPrime = lastRle.end; iPrime < width; iPrime++) {\n                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                }\n            }\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR) {\n                return;\n            }\n            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);\n            const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;\n            const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;\n            const isLast = jPrime === height - 1;\n            const isFirst = jPrime === 0;\n            const prevCovers = IslandRemoval.covers(rle, rowPrev) ||\n                (isFirst && this.fillInternalEdge);\n            const nextCovers = IslandRemoval.covers(rle, rowNext) || (isLast && this.fillInternalEdge);\n            if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {\n                segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });\n            }\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR) {\n                return;\n            }\n            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);\n            const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);\n            const isBig = size > this.maxInternalRemove;\n            const newType = isBig\n                ? SegmentationEnum.EXTERIOR\n                : SegmentationEnum.INTERIOR_SMALL;\n            segmentSet.floodFill(rle.start, jPrime, kPrime, newType);\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {\n                return;\n            }\n            for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {\n                const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));\n                previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);\n            }\n        });\n        return previewVoxelManager.getArrayOfModifiedSlices();\n    }\n    static covers(rle, row) {\n        if (!row) {\n            return false;\n        }\n        let { start } = rle;\n        const { end } = rle;\n        for (const rowRle of row) {\n            if (start >= rowRle.start && start < rowRle.end) {\n                start = rowRle.end;\n                if (start >= end) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n","import { state } from '../../stateManagement/annotation';\nimport RectangleROIStartEndThresholdTool from '../../tools/segmentation/RectangleROIStartEndThresholdTool';\nimport RectangleROIThresholdTool from '../../tools/segmentation/RectangleROIThresholdTool';\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nfunction rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {\n    const annotations = annotationUIDs.map((annotationUID) => {\n        return state.getAnnotation(annotationUID);\n    });\n    _validateAnnotations(annotations);\n    let boundsIJK;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() ||\n            i === 0) {\n            boundsIJK = getBoundsIJKFromRectangleAnnotations(annotations, thresholdVolumeInformation[i].volume, options);\n        }\n    }\n    const outputSegmentationVolume = thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK, segmentationId: options.segmentationId });\n    outputSegmentationVolume.modified();\n    return outputSegmentationVolume;\n}\nfunction _validateAnnotations(annotations) {\n    const validToolNames = [\n        RectangleROIThresholdTool.toolName,\n        RectangleROIStartEndThresholdTool.toolName,\n    ];\n    for (const annotation of annotations) {\n        const name = annotation.metadata.toolName;\n        if (!validToolNames.includes(name)) {\n            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');\n        }\n    }\n}\nexport default rectangleROIThresholdVolumeByRange;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { state as annotationState, config as annotationConfig, } from '../../stateManagement/annotation';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\nimport { getSegmentations } from '../../stateManagement/segmentation/getSegmentations';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nexport default async function segmentContourAction(element, configuration) {\n    console.warn('Deprecation Alert: There is a new getSegmentLargestBidirectional function that handles volume, stack and individual segment cases properly. This function is deprecated and will be removed in a future version.');\n    const { data: configurationData } = configuration;\n    const enabledElement = getEnabledElement(element);\n    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);\n    if (!segment) {\n        return;\n    }\n    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n    const segmentationsList = getSegmentations();\n    const { segmentIndex, segmentationId } = segment;\n    const bidirectionals = annotationState.getAnnotations(this.toolName || BidirectionalTool.toolName, FrameOfReferenceUID);\n    let hasExistingActiveSegment = false;\n    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {\n        const segment = existingBidirectionalItem.data.segment;\n        if (!segment) {\n            return false;\n        }\n        if (segment.segmentationId === segmentationId &&\n            segment.segmentIndex === segmentIndex) {\n            hasExistingActiveSegment = true;\n            existingBidirectionalItem.data.segment = segment;\n        }\n        return true;\n    });\n    if (!hasExistingActiveSegment) {\n        existingLargestBidirectionals.push({\n            data: { segment },\n        });\n    }\n    let newBidirectional;\n    existingLargestBidirectionals.forEach(async (existingLargestBidirectional) => {\n        const segments = [];\n        const updateSegment = existingLargestBidirectional.data\n            .segment;\n        const { segmentIndex, segmentationId } = updateSegment;\n        segments[segmentIndex] = updateSegment;\n        annotationState.removeAnnotation(existingLargestBidirectional.annotationUID);\n        const bidirectionalData = await contourAndFindLargestBidirectional({\n            ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId),\n            segments,\n        });\n        if (!bidirectionalData) {\n            return;\n        }\n        const bidirectionalToolData = createBidirectionalToolData(bidirectionalData, enabledElement.viewport);\n        bidirectionalToolData.annotationUID =\n            existingLargestBidirectional.annotationUID;\n        bidirectionalToolData.data.segment = updateSegment;\n        const annotationUID = annotationState.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);\n        if (updateSegment.segmentIndex === segment.segmentIndex &&\n            updateSegment.segmentationId === segment.segmentationId) {\n            newBidirectional = bidirectionalData;\n            const { style } = segment;\n            if (style) {\n                annotationConfig.style.setAnnotationStyles(annotationUID, style);\n            }\n        }\n    });\n    if (newBidirectional) {\n        const { sliceIndex } = newBidirectional;\n        const imageIds = enabledElement.viewport.getImageIds();\n        utilities.jumpToSlice(element, {\n            imageIndex: imageIds.length - 1 - sliceIndex,\n        });\n        enabledElement.viewport.render();\n    }\n    else {\n        console.warn('No bidirectional found');\n    }\n    return newBidirectional;\n}\nexport function defaultGetSegment(enabledElement, configuration) {\n    const segmentationsList = getSegmentations();\n    if (!segmentationsList.length) {\n        return;\n    }\n    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;\n    const segmentIndex = configuration.segmentIndex ?? getActiveSegmentIndex(segmentationId);\n    if (!segmentIndex) {\n        return;\n    }\n    const segmentData = configuration.segmentData?.get(segmentIndex);\n    return {\n        label: `Segment ${segmentIndex}`,\n        segmentIndex,\n        segmentationId,\n        ...segmentData,\n    };\n}\n","import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType, segmentationId) {\n    if (!segmentationId) {\n        throw new Error('Segmentation ID is required to be passed inside thresholdSegmentationByRange');\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    const { voxelManager } = volumeInfoList[baseVolumeIdx];\n    const refVoxelManager = voxelManager;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const segVoxelManager = segmentationVolume.voxelManager;\n    volumeInfoList.forEach((volumeInfo) => {\n        const { volumeSize } = volumeInfo;\n        if (volumeSize === scalarDataLength) {\n            _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);\n        }\n        else {\n            _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);\n        }\n    });\n    triggerSegmentationDataModified(segmentationId);\n    return segmentationVolume;\n}\nfunction _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {\n    const { imageData, lower, upper, dimensions } = volumeInfo;\n    let total, overlaps, range;\n    const segScalarDataLength = segVoxelManager.getScalarDataLength();\n    for (let i = 0; i < segScalarDataLength; i++) {\n        if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {\n            const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));\n            const callbackOverlap = ({ value }) => {\n                total = total + 1;\n                if (value >= range.lower && value <= range.upper) {\n                    overlaps = overlaps + 1;\n                }\n            };\n            total = 0;\n            overlaps = 0;\n            range = { lower, upper };\n            let overlapTest = false;\n            segVoxelManager.forEach(callbackOverlap, {\n                imageData,\n                boundsIJK: overlapBounds,\n            });\n            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n            segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);\n        }\n    }\n    return { total, range, overlaps };\n}\nfunction _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {\n    const { lower, upper } = volumeInfo;\n    const scalarDataLength = segVoxelManager.getScalarDataLength();\n    for (let i = 0; i < scalarDataLength; i++) {\n        if (segVoxelManager.getAtIndex[i] === segmentationIndex) {\n            const value = refVoxelManager.getAtIndex(i);\n            segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);\n        }\n    }\n}\nexport default thresholdSegmentationByRange;\n","import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { overwrite, boundsIJK, segmentationId } = options;\n    if (!segmentationId) {\n        throw new Error('Segmentation ID is required to be passed inside thresholdVolumeByRange as options');\n    }\n    const overlapType = options?.overlapType || 0;\n    const segVoxelManager = segmentationVolume.voxelManager;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    if (overwrite) {\n        for (let i = 0; i < scalarDataLength; i++) {\n            segVoxelManager.setAtIndex(i, 0);\n        }\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    let overlaps, total, range;\n    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n        const callbackOverlap = ({ value }) => {\n            total = total + 1;\n            if (value >= range.lower && value <= range.upper) {\n                overlaps = overlaps + 1;\n            }\n        };\n        const { imageData, dimensions, lower, upper } = volumeInfo;\n        const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);\n        total = 0;\n        overlaps = 0;\n        range = { lower, upper };\n        let overlapTest = false;\n        const { voxelManager } = imageData.get('voxelManager');\n        voxelManager.forEach(callbackOverlap, {\n            imageData,\n            boundsIJK: overlapBounds,\n        });\n        if (overlapType === 0) {\n            overlapTest = overlaps > 0;\n        }\n        else if (overlapType == 1) {\n            overlapTest = overlaps === total;\n        }\n        return overlapTest;\n    };\n    const testRange = (volumeInfo, pointIJK) => {\n        const { imageData, lower, upper } = volumeInfo;\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const offset = voxelManager.toIndex(pointIJK);\n        const value = voxelManager.getAtIndex(offset);\n        if (value <= lower || value >= upper) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    const callback = ({ index, pointIJK, pointLPS }) => {\n        let insert = volumeInfoList.length > 0;\n        for (let i = 0; i < volumeInfoList.length; i++) {\n            if (volumeInfoList[i].volumeSize === scalarDataLength) {\n                insert = testRange(volumeInfoList[i], pointIJK);\n            }\n            else {\n                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);\n            }\n            if (!insert) {\n                break;\n            }\n        }\n        if (insert) {\n            segVoxelManager.setAtIndex(index, options.segmentIndex || 1);\n        }\n    };\n    const voxelManager = segmentationVolume.voxelManager;\n    voxelManager.forEach(callback, {\n        imageData: segmentationImageData,\n        boundsIJK,\n    });\n    triggerSegmentationDataModified(options.segmentationId);\n    return segmentationVolume;\n}\nexport default thresholdVolumeByRange;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nconst equalsCheck = (a, b) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\nexport function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {\n    const halfSpacingX = voxelSpacing[0] / 2;\n    const halfSpacingY = voxelSpacing[1] / 2;\n    const halfSpacingZ = voxelSpacing[2] / 2;\n    const voxelCornersIJK = new Array(8);\n    voxelCornersIJK[0] = csUtils.transformWorldToIndex(imageData, [\n        voxelCenter[0] - halfSpacingX,\n        voxelCenter[1] - halfSpacingY,\n        voxelCenter[2] - halfSpacingZ,\n    ]);\n    const offsets = [\n        [1, -1, -1],\n        [-1, 1, -1],\n        [1, 1, -1],\n        [-1, -1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [1, 1, 1],\n    ];\n    for (let i = 0; i < 7; i++) {\n        const [xOff, yOff, zOff] = offsets[i];\n        voxelCornersIJK[i + 1] = csUtils.transformWorldToIndex(imageData, [\n            voxelCenter[0] + xOff * halfSpacingX,\n            voxelCenter[1] + yOff * halfSpacingY,\n            voxelCenter[2] + zOff * halfSpacingZ,\n        ]);\n    }\n    return getBoundingBoxAroundShapeIJK(voxelCornersIJK, dimensions);\n}\nexport function processVolumes(segmentationVolume, thresholdVolumeInformation) {\n    const { spacing: segmentationSpacing } = segmentationVolume;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const volumeInfoList = [];\n    let baseVolumeIdx = 0;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === scalarDataLength &&\n            equalsCheck(spacing, segmentationSpacing)) {\n            baseVolumeIdx = i;\n        }\n        const lower = thresholdVolumeInformation[i].lower;\n        const upper = thresholdVolumeInformation[i].upper;\n        volumeInfoList.push({\n            imageData,\n            lower,\n            upper,\n            spacing,\n            dimensions,\n            volumeSize,\n            voxelManager,\n        });\n    }\n    return {\n        volumeInfoList,\n        baseVolumeIdx,\n    };\n}\nconst segmentIndicesCache = new Map();\nexport const setSegmentationDirty = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = true;\n    }\n};\nexport const setSegmentationClean = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = false;\n    }\n};\nexport const getCachedSegmentIndices = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached && !cached.isDirty) {\n        return cached.indices;\n    }\n    return null;\n};\nexport const setCachedSegmentIndices = (segmentationId, indices) => {\n    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n};\n","import { cache, utilities, eventTarget, Enums, triggerEvent, metaData, } from '@cornerstonejs/core';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getStrategyData } from '../../tools/segmentation/strategies/utils/getStrategyData';\nimport ensureSegmentationVolume from '../../tools/segmentation/strategies/compositions/ensureSegmentationVolume';\nimport ensureImageVolume from '../../tools/segmentation/strategies/compositions/ensureImageVolume';\nexport const triggerWorkerProgress = (workerType, progress) => {\n    triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n        progress,\n        type: workerType,\n    });\n};\nexport const getSegmentationDataForWorker = (segmentationId, segmentIndices) => {\n    const segmentation = getSegmentation(segmentationId);\n    const { representationData } = segmentation;\n    const { Labelmap } = representationData;\n    if (!Labelmap) {\n        console.debug('No labelmap found for segmentation', segmentationId);\n        return null;\n    }\n    const segVolumeId = Labelmap.volumeId;\n    const segImageIds = Labelmap.imageIds;\n    const operationData = {\n        segmentationId,\n        volumeId: segVolumeId,\n        imageIds: segImageIds,\n    };\n    let reconstructableVolume = false;\n    if (segImageIds) {\n        const refImageIds = segImageIds.map((imageId) => {\n            const image = cache.getImage(imageId);\n            return image.referencedImageId;\n        });\n        reconstructableVolume = utilities.isValidVolume(refImageIds);\n    }\n    let indices = segmentIndices;\n    if (!indices) {\n        indices = [getActiveSegmentIndex(segmentationId)];\n    }\n    else if (!Array.isArray(indices)) {\n        indices = [indices, 255];\n    }\n    return {\n        operationData,\n        segVolumeId,\n        segImageIds,\n        reconstructableVolume,\n        indices,\n    };\n};\nexport const prepareVolumeStrategyDataForWorker = (operationData) => {\n    return getStrategyData({\n        operationData,\n        strategy: {\n            ensureSegmentationVolumeFor3DManipulation: ensureSegmentationVolume.ensureSegmentationVolumeFor3DManipulation,\n            ensureImageVolumeFor3DManipulation: ensureImageVolume.ensureImageVolumeFor3DManipulation,\n        },\n    });\n};\nexport const prepareImageInfo = (imageVoxelManager, imageData) => {\n    const imageScalarData = imageVoxelManager.getCompleteScalarDataArray();\n    return {\n        scalarData: imageScalarData,\n        dimensions: imageData.getDimensions(),\n        spacing: imageData.getSpacing(),\n        origin: imageData.getOrigin(),\n        direction: imageData.getDirection(),\n    };\n};\nexport const prepareStackDataForWorker = (segImageIds) => {\n    const segmentationInfo = [];\n    const imageInfo = [];\n    for (const segImageId of segImageIds) {\n        const segImage = cache.getImage(segImageId);\n        const segPixelData = segImage.getPixelData();\n        const { origin, direction, spacing, dimensions } = utilities.getImageDataMetadata(segImage);\n        segmentationInfo.push({\n            scalarData: segPixelData,\n            dimensions,\n            spacing,\n            origin,\n            direction,\n        });\n        const refImageId = segImage.referencedImageId;\n        if (refImageId) {\n            const refImage = cache.getImage(refImageId);\n            if (!refImage) {\n                continue;\n            }\n            const refPixelData = refImage.getPixelData();\n            const refVoxelManager = refImage.voxelManager;\n            const refSpacing = [\n                refImage.rowPixelSpacing,\n                refImage.columnPixelSpacing,\n            ];\n            imageInfo.push({\n                scalarData: refPixelData,\n                dimensions: refVoxelManager\n                    ? refVoxelManager.dimensions\n                    : [refImage.columns, refImage.rows, 1],\n                spacing: refSpacing,\n            });\n        }\n    }\n    return { segmentationInfo, imageInfo };\n};\nexport const getImageReferenceInfo = (segVolumeId, segImageIds) => {\n    let refImageId;\n    if (segVolumeId) {\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const imageIds = segmentationVolume.imageIds;\n        const cachedImage = cache.getImage(imageIds[0]);\n        if (cachedImage) {\n            refImageId = cachedImage.referencedImageId;\n        }\n    }\n    else if (segImageIds?.length) {\n        const segImage = cache.getImage(segImageIds[0]);\n        refImageId = segImage.referencedImageId;\n    }\n    const refImage = cache.getImage(refImageId);\n    const scalingModule = metaData.get('scalingModule', refImageId);\n    const modalityUnitOptions = {\n        isPreScaled: Boolean(refImage?.preScale?.scaled),\n        isSuvScaled: typeof scalingModule?.suvbw === 'number',\n    };\n    return { refImageId, modalityUnitOptions };\n};\n","import { cache } from '@cornerstonejs/core';\nfunction validateRepresentationData(segmentationRepresentationData) {\n    if ('volumeId' in segmentationRepresentationData) {\n        segmentationRepresentationData =\n            segmentationRepresentationData;\n        const cachedVolume = cache.getVolume(segmentationRepresentationData.volumeId);\n        if (!cachedVolume) {\n            throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);\n        }\n    }\n    else if ('imageIds' in segmentationRepresentationData) {\n        segmentationRepresentationData =\n            segmentationRepresentationData;\n        if (!segmentationRepresentationData.imageIds) {\n            throw new Error('The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data');\n        }\n    }\n    else {\n        throw new Error('The segmentationInput.representationData is undefined, please provide a valid representationData');\n    }\n}\nexport function validatePublic(segmentationInput) {\n    if (!segmentationInput.representation.data) {\n        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');\n    }\n    const representationData = segmentationInput.representation\n        .data;\n    validateRepresentationData(representationData);\n}\nexport function validate(segmentationRepresentationData) {\n    validateRepresentationData(segmentationRepresentationData);\n}\n","import { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../enums';\nexport default function setAnnotationLabel(annotation, element, updatedLabel) {\n    annotation.data.label = updatedLabel;\n    triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n}\n","import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, priority, clearFromImageIds, getPromiseRemovedHandler, } from './stackPrefetchUtils';\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    minBefore: 2,\n    maxAfter: 2,\n    directionExtraImages: 10,\n    preserveExistingPool: false,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 5;\nconst enable = (element) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    updateToolState(element);\n    prefetch(element);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n};\nfunction prefetch(element) {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    const { currentImageIdIndex } = stack;\n    indicesToRequestCopy.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n    }\n    function doneCallback(imageId) {\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        const image = cache.getCachedImageBasedOnImageURI(imageId);\n        const { stats } = stackPrefetch;\n        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n        if (decodeTimeInMS) {\n            stats.imageIds.set(imageId, decodeTimeInMS);\n            stats.decodeTimeInMS += decodeTimeInMS;\n            const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n            stats.loadTimeInMS += loadTimeInMS;\n        }\n        if (!stackPrefetch.indicesToRequest.length) {\n            if (image?.sizeInBytes) {\n                const { sizeInBytes } = image;\n                const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n                if (!stackPrefetch.cacheFill) {\n                    stats.initialTime = Date.now() - stats.start;\n                    stats.initialSize = stats.imageIds.size;\n                    updateToolState(element, usage);\n                    prefetch(element);\n                }\n                else if (stats.imageIds.size) {\n                    stats.fillTime = Date.now() - stats.start;\n                    const { size } = stats.imageIds;\n                    stats.fillSize = size;\n                }\n            }\n        }\n    }\n    const requestFn = (imageId, options) => imageLoader\n        .loadAndCacheImage(imageId, options)\n        .then(() => doneCallback(imageId));\n    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            updateToolState(element);\n            prefetch(element);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nconst signum = (x) => (x < 0 ? -1 : 1);\nconst updateToolState = (element, usage) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    let { maxAfter = 2, minBefore = 2 } = configuration;\n    const { directionExtraImages = 10 } = configuration;\n    const stackPrefetchData = getToolState(element) ||\n        {\n            indicesToRequest: [],\n            currentImageIdIndex,\n            stackCount: 0,\n            enabled: true,\n            direction: 1,\n            stats: {\n                start: Date.now(),\n                imageIds: new Map(),\n                decodeTimeInMS: 0,\n                loadTimeInMS: 0,\n                totalBytes: 0,\n            },\n        };\n    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n    stackPrefetchData.direction = signum(delta);\n    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n    stackPrefetchData.enabled = true;\n    if (stackPrefetchData.stackCount < 100) {\n        stackPrefetchData.stackCount += directionExtraImages;\n    }\n    if (Math.abs(delta) > maxAfter || !delta) {\n        stackPrefetchData.stackCount = 0;\n        if (usage) {\n            const positionFraction = currentImageIdIndex / stack.imageIds.length;\n            minBefore = Math.ceil(usage * positionFraction);\n            maxAfter = Math.ceil(usage * (1 - positionFraction));\n            stackPrefetchData.cacheFill = true;\n        }\n        else {\n            stackPrefetchData.cacheFill = false;\n        }\n    }\n    else if (delta < 0) {\n        minBefore += stackPrefetchData.stackCount;\n        maxAfter = 0;\n    }\n    else {\n        maxAfter += stackPrefetchData.stackCount;\n        minBefore = 0;\n    }\n    const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);\n    const indicesToRequest = [];\n    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n        indicesToRequest.push(i);\n    }\n    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n        indicesToRequest.push(i);\n    }\n    stackPrefetchData.indicesToRequest = indicesToRequest;\n    addToolState(element, stackPrefetchData);\n};\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData) {\n        stackPrefetchData.enabled = false;\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackContextPrefetch = {\n    enable,\n    disable,\n    getConfiguration,\n    setConfiguration,\n};\nexport default stackContextPrefetch;\n","import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, getConfiguration as getCoreConfiguration, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, priority, getPromiseRemovedHandler, nearestIndex, range, } from './stackPrefetchUtils';\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    preserveExistingPool: true,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\nfunction prefetch(element) {\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    const stack = getStackData(element);\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    indicesToRequestCopy.forEach(function (imageIdIndex) {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n    const nearest = nearestIndex(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);\n    let imageId;\n    let nextImageIdIndex;\n    const preventCache = false;\n    function doneCallback(image) {\n        console.log('prefetch done: %s', image.imageId);\n        const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n        removeFromList(imageIdIndex);\n    }\n    let lowerIndex = nearest.low;\n    let higherIndex = nearest.high;\n    const imageIdsToPrefetch = [];\n    while (lowerIndex >= 0 ||\n        higherIndex < stackPrefetch.indicesToRequest.length) {\n        const currentIndex = stack.currentImageIdIndex;\n        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n            configuration.maxImagesToPrefetch;\n        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n            configuration.maxImagesToPrefetch;\n        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n        if (!shouldLoadHigher && !shouldLoadLower) {\n            break;\n        }\n        if (shouldLoadLower) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n        if (shouldLoadHigher) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n    }\n    const requestFn = (imageId, options) => imageLoader.loadAndCacheImage(imageId, options);\n    imageIdsToPrefetch.forEach((imageId) => {\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            prefetch(element);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nfunction enable(element) {\n    const stack = getStackData(element);\n    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = {\n        indicesToRequest: range(0, stack.imageIds.length - 1),\n        enabled: true,\n        direction: 1,\n    };\n    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);\n    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n    addToolState(element, stackPrefetchData);\n    prefetch(element);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n}\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n        stackPrefetchData.enabled = false;\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\nexport default stackPrefetch;\n","function getDeltaPoints(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _subtractPoints2D(curr.page, last.page),\n        client: _subtractPoints2D(curr.client, last.client),\n        canvas: _subtractPoints2D(curr.canvas, last.canvas),\n        world: _subtractPoints3D(curr.world, last.world),\n    };\n}\nfunction getDeltaDistance(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _getDistance2D(curr.page, last.page),\n        client: _getDistance2D(curr.client, last.client),\n        canvas: _getDistance2D(curr.canvas, last.canvas),\n        world: _getDistance3D(curr.world, last.world),\n    };\n}\nfunction getDeltaRotation(currentPoints, lastPoints) {\n}\nfunction getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {\n    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n    const deltaDistance = {\n        page: currentDistance.page - lastDistance.page,\n        client: currentDistance.client - lastDistance.client,\n        canvas: currentDistance.canvas - lastDistance.canvas,\n        world: currentDistance.world - lastDistance.world,\n    };\n    return deltaDistance;\n}\nfunction copyPointsList(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction getMeanPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    });\n}\nfunction getMeanTouchPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n            touch: {\n                identifier: null,\n                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n                force: prev.touch.force + curr.touch.force / points.length,\n                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n            },\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n        touch: {\n            identifier: null,\n            radiusX: 0,\n            radiusY: 0,\n            force: 0,\n            rotationAngle: 0,\n        },\n    });\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nfunction _getMeanDistanceBetweenAllIPoints(points) {\n    const pairedDistance = [];\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (i < j) {\n                pairedDistance.push({\n                    page: _getDistance2D(points[i].page, points[j].page),\n                    client: _getDistance2D(points[i].client, points[j].client),\n                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n                    world: _getDistance3D(points[i].world, points[j].world),\n                });\n            }\n        }\n    }\n    return pairedDistance.reduce((prev, curr) => {\n        return {\n            page: prev.page + curr.page / pairedDistance.length,\n            client: prev.client + curr.client / pairedDistance.length,\n            canvas: prev.canvas + curr.canvas / pairedDistance.length,\n            world: prev.world + curr.world / pairedDistance.length,\n        };\n    }, {\n        page: 0,\n        client: 0,\n        canvas: 0,\n        world: 0,\n    });\n}\nfunction _getDistance2D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));\n}\nfunction _getDistance3D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +\n        Math.pow(point0[1] - point1[1], 2) +\n        Math.pow(point0[2] - point1[2], 2));\n}\nexport { getMeanPoints, getMeanTouchPoints, copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaPoints, getDeltaDistance, getDeltaRotation, };\n","import { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nfunction triggerAnnotationRender(element) {\n    annotationRenderingEngine.renderViewport(element);\n}\nexport default triggerAnnotationRender;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\nexport function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`ToolGroup not available for ${toolGroupId}`);\n            return;\n        }\n        const viewportsInfo = toolGroup.getViewportsInfo();\n        viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n                return;\n            }\n            const viewport = renderingEngine.getViewport(viewportId);\n            triggerAnnotationRender(viewport.element);\n        });\n    });\n}\nexport default triggerAnnotationRenderForToolGroupIds;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n","export default function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {\n    const numViewports = viewports.length;\n    const viewportsWithFrameOfReferenceUID = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n            viewportsWithFrameOfReferenceUID.push(viewport);\n        }\n    }\n    return viewportsWithFrameOfReferenceUID;\n}\n","import { vec3 } from 'gl-matrix';\nexport function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {\n    return viewports.filter((viewport) => {\n        const vpCamera = viewport.getCamera();\n        const isParallel = Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n            EPS;\n        return isParallel;\n    });\n}\nexport default filterViewportsWithParallelNormals;\n","import { ToolModes } from '../../enums';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst { Active, Passive, Enabled } = ToolModes;\nexport default function filterViewportsWithToolEnabled(viewports, toolName) {\n    const numViewports = viewports.length;\n    const viewportsWithToolEnabled = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n        if (!toolGroup) {\n            continue;\n        }\n        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);\n        if (hasTool) {\n            viewportsWithToolEnabled.push(viewport);\n        }\n    }\n    return viewportsWithToolEnabled;\n}\nfunction _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {\n    const { toolOptions } = toolGroup;\n    const tool = toolOptions[toolName];\n    if (!tool) {\n        return false;\n    }\n    const toolMode = tool.mode;\n    return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec2 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\nconst DEFAULTS = {\n    MULTIPLIER: 1,\n    RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n    TICKS_BAR_SIZE: 50,\n};\nclass Colorbar extends Widget {\n    constructor(props) {\n        super(props);\n        this._isMouseOver = false;\n        this._isInteracting = false;\n        this._mouseOverCallback = (evt) => {\n            this._isMouseOver = true;\n            this.showTicks();\n            evt.stopPropagation();\n        };\n        this._mouseOutCallback = (evt) => {\n            this._isMouseOver = false;\n            this.hideTicks();\n            evt.stopPropagation();\n        };\n        this._mouseDownCallback = (evt) => {\n            this._isInteracting = true;\n            this.showTicks();\n            this._addVOIEventListeners(evt);\n            evt.stopPropagation();\n        };\n        this._mouseDragCallback = (evt, initialState) => {\n            const multipliers = this.getVOIMultipliers();\n            const currentPoints = this._getPointsFromMouseEvent(evt);\n            const { points: startPoints, voiRange: startVOIRange } = initialState;\n            const canvasDelta = vec2.sub(vec2.create(), currentPoints.local, startPoints.local);\n            const wwDelta = canvasDelta[0] * multipliers[0];\n            const wcDelta = canvasDelta[1] * multipliers[1];\n            if (!wwDelta && !wcDelta) {\n                return;\n            }\n            const { lower: voiLower, upper: voiUpper } = startVOIRange;\n            let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(voiLower, voiUpper);\n            windowWidth = Math.max(windowWidth + wwDelta, 1);\n            windowCenter += wcDelta;\n            const newVoiRange = csUtils.windowLevel.toLowHighRange(windowWidth, windowCenter);\n            this.voiRange = newVoiRange;\n            evt.stopPropagation();\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            this._isInteracting = false;\n            this.hideTicks();\n            this._removeVOIEventListeners();\n            evt.stopPropagation();\n        };\n        this._eventListenersManager =\n            new csUtils.eventListener.MultiTargetEventListenerManager();\n        this._colormaps = Colorbar.getColormapsMap(props);\n        this._activeColormapName = Colorbar.getInitialColormapName(props);\n        this._canvas = this._createCanvas(props);\n        this._ticksBar = this._createTicksBar(props);\n        this._rangeTextPosition =\n            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n        this._canvas.appendTo(this.rootElement);\n        this._ticksBar.appendTo(this.rootElement);\n        this._addRootElementEventListeners();\n    }\n    get activeColormapName() {\n        return this._activeColormapName;\n    }\n    set activeColormapName(colormapName) {\n        if (colormapName === this._activeColormapName) {\n            return;\n        }\n        const colormap = this._colormaps.get(colormapName);\n        if (!colormap) {\n            console.warn(`Invalid colormap name (${colormapName})`);\n            return;\n        }\n        this._activeColormapName = colormapName;\n        this._canvas.colormap = colormap;\n    }\n    get imageRange() {\n        return this._canvas.imageRange;\n    }\n    set imageRange(imageRange) {\n        this._canvas.imageRange = imageRange;\n        this._ticksBar.imageRange = imageRange;\n    }\n    get voiRange() {\n        return this._canvas.voiRange;\n    }\n    set voiRange(voiRange) {\n        const { voiRange: currentVoiRange } = this._canvas;\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, currentVoiRange)) {\n            return;\n        }\n        this._canvas.voiRange = voiRange;\n        this._ticksBar.voiRange = voiRange;\n        this.onVoiChange(voiRange);\n    }\n    get showFullImageRange() {\n        return this._canvas.showFullImageRange;\n    }\n    set showFullImageRange(value) {\n        this._canvas.showFullImageRange = value;\n        this._ticksBar.showFullPixelValueRange = value;\n    }\n    destroy() {\n        super.destroy();\n        this._eventListenersManager.reset();\n    }\n    createRootElement() {\n        const rootElement = document.createElement('div');\n        Object.assign(rootElement.style, {\n            position: 'relative',\n            fontSize: '0',\n            width: '100%',\n            height: '100%',\n        });\n        return rootElement;\n    }\n    onContainerResize() {\n        super.onContainerResize();\n        this.updateTicksBar();\n        this._canvas.size = this.containerSize;\n    }\n    getVOIMultipliers() {\n        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n    }\n    onVoiChange(voiRange) {\n    }\n    showTicks() {\n        this.updateTicksBar();\n        this._ticksBar.visible = true;\n    }\n    hideTicks() {\n        if (this._isInteracting || this._isMouseOver) {\n            return;\n        }\n        this._ticksBar.visible = false;\n    }\n    static getColormapsMap(props) {\n        const { colormaps } = props;\n        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());\n    }\n    static getInitialColormapName(props) {\n        const { activeColormapName, colormaps } = props;\n        const colormapExists = !!activeColormapName &&\n            colormaps.some((cm) => cm.Name === activeColormapName);\n        return colormapExists ? activeColormapName : colormaps[0].Name;\n    }\n    _createCanvas(props) {\n        const { imageRange, voiRange, showFullPixelValueRange } = props;\n        const colormap = this._colormaps.get(this._activeColormapName);\n        return new ColorbarCanvas({\n            colormap,\n            imageRange,\n            voiRange: voiRange,\n            showFullPixelValueRange,\n        });\n    }\n    _createTicksBar(props) {\n        const ticksProps = props.ticks;\n        return new ColorbarTicks({\n            imageRange: props.imageRange,\n            voiRange: props.voiRange,\n            ticks: ticksProps,\n            showFullPixelValueRange: props.showFullPixelValueRange,\n        });\n    }\n    _getPointsFromMouseEvent(evt) {\n        const { rootElement: element } = this;\n        const clientPoint = [evt.clientX, evt.clientY];\n        const pagePoint = [evt.pageX, evt.pageY];\n        const rect = element.getBoundingClientRect();\n        const localPoints = [\n            pagePoint[0] - rect.left - window.pageXOffset,\n            pagePoint[1] - rect.top - window.pageYOffset,\n        ];\n        return { client: clientPoint, page: pagePoint, local: localPoints };\n    }\n    updateTicksBar() {\n        const { width: containerWidth, height: containerHeight } = this.containerSize;\n        if (containerWidth === 0 && containerHeight === 0) {\n            return;\n        }\n        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n        const isHorizontal = containerWidth >= containerHeight;\n        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n        if (!isRangeTextPositionValid(containerWidth, containerHeight, rangeTextPosition)) {\n            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');\n        }\n        let ticksBarTop;\n        let ticksBarLeft;\n        ticksBar.size = { width, height };\n        if (isHorizontal) {\n            ticksBarLeft = 0;\n            ticksBarTop =\n                rangeTextPosition === ColorbarRangeTextPosition.Top\n                    ? -height\n                    : containerHeight;\n        }\n        else {\n            ticksBarTop = 0;\n            ticksBarLeft =\n                rangeTextPosition === ColorbarRangeTextPosition.Left\n                    ? -width\n                    : containerWidth;\n        }\n        ticksBar.top = ticksBarTop;\n        ticksBar.left = ticksBarLeft;\n    }\n    _addRootElementEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        const { rootElement: element } = this;\n        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);\n    }\n    _addVOIEventListeners(evt) {\n        const { _eventListenersManager: manager } = this;\n        const points = this._getPointsFromMouseEvent(evt);\n        const voiRange = { ...this._canvas.voiRange };\n        const initialDragState = { points, voiRange };\n        this._removeVOIEventListeners();\n        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));\n    }\n    _removeVOIEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        manager.removeEventListener(document, 'voi.mouseup');\n        manager.removeEventListener(document, 'voi.mousemove');\n    }\n}\nexport { Colorbar as default, Colorbar };\n","import { eventTarget, VolumeViewport, StackViewport, Enums, utilities, getEnabledElement, cache, } from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\nclass ViewportColorbar extends Colorbar {\n    constructor(props) {\n        const { element, volumeId } = props;\n        const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n        super({ ...props, imageRange, voiRange });\n        this.autoHideTicks = () => {\n            if (this._hideTicksTimeoutId) {\n                return;\n            }\n            const timeLeft = this._hideTicksTime - Date.now();\n            if (timeLeft <= 0) {\n                this.hideTicks();\n            }\n            else {\n                this._hideTicksTimeoutId = window.setTimeout(() => {\n                    this._hideTicksTimeoutId = 0;\n                    this.autoHideTicks();\n                }, timeLeft);\n            }\n        };\n        this._stackNewImageCallback = () => {\n            this.imageRange = ViewportColorbar._getImageRange(this._element);\n        };\n        this._imageVolumeModifiedCallback = (evt) => {\n            const { volumeId } = evt.detail;\n            if (volumeId !== this._volumeId) {\n                return;\n            }\n            const { _element: element } = this;\n            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        };\n        this._viewportVOIModifiedCallback = (evt) => {\n            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.voiRange = voiRange;\n            if (colormap) {\n                this.activeColormapName = colormap.name;\n            }\n            this.showAndAutoHideTicks();\n        };\n        this._viewportColormapModifiedCallback = (evt) => {\n            const { viewportId, colormap, volumeId } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.activeColormapName = colormap.name;\n        };\n        this._element = element;\n        this._volumeId = volumeId;\n        this._addCornerstoneEventListener();\n    }\n    get element() {\n        return this._element;\n    }\n    get enabledElement() {\n        return getEnabledElement(this._element);\n    }\n    getVOIMultipliers() {\n        const { viewport } = this.enabledElement;\n        return getVOIMultipliers(viewport, this._volumeId);\n    }\n    onVoiChange(voiRange) {\n        super.onVoiChange(voiRange);\n        const { viewport } = this.enabledElement;\n        if (viewport instanceof StackViewport) {\n            viewport.setProperties({\n                voiRange: voiRange,\n            });\n            viewport.render();\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { _volumeId: volumeId } = this;\n            const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(volumeId);\n            viewport.setProperties({ voiRange }, volumeId);\n            viewportsContainingVolumeUID.forEach((vp) => vp.render());\n        }\n    }\n    static _getImageRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const imageData = actor.getMapper().getInputData();\n        const scalarData = imageData.getPointData().getScalars();\n        let imageRange;\n        if (!scalarData) {\n            if (!volumeId) {\n                throw new Error('volumeId is required when scalarData is not available');\n            }\n            const volume = cache.getVolume(volumeId);\n            const [minValue, maxValue] = volume.voxelManager.getRange();\n            imageRange = [minValue, maxValue];\n        }\n        else {\n            imageRange = scalarData.getRange();\n        }\n        return imageRange[0] === 0 && imageRange[1] === 0\n            ? defaultImageRange\n            : { lower: imageRange[0], upper: imageRange[1] };\n    }\n    static _getVOIRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();\n        return voiRange[0] === 0 && voiRange[1] === 0\n            ? defaultImageRange\n            : { lower: voiRange[0], upper: voiRange[1] };\n    }\n    showAndAutoHideTicks(interval = 1000) {\n        this._hideTicksTime = Date.now() + interval;\n        this.showTicks();\n        this.autoHideTicks();\n    }\n    _addCornerstoneEventListener() {\n        const { _element: element } = this;\n        eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n    destroy() {\n        super.destroy();\n        const { _element: element } = this;\n        eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n}\nexport { ViewportColorbar as default, ViewportColorbar };\n","export var ColorbarRangeTextPosition;\n(function (ColorbarRangeTextPosition) {\n    ColorbarRangeTextPosition[\"Top\"] = \"top\";\n    ColorbarRangeTextPosition[\"Left\"] = \"left\";\n    ColorbarRangeTextPosition[\"Bottom\"] = \"bottom\";\n    ColorbarRangeTextPosition[\"Right\"] = \"right\";\n})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n    const numPixels = pixelLuminance.length;\n    let min = globalMax;\n    let max = globalMin;\n    let sum = 0;\n    if (numPixels < 2) {\n        return {\n            min,\n            max,\n            mean: (globalMin + globalMax) / 2,\n        };\n    }\n    for (let index = 0; index < numPixels; index++) {\n        const spv = pixelLuminance[index];\n        min = Math.min(min, spv);\n        max = Math.max(max, spv);\n        sum += spv;\n    }\n    return {\n        min,\n        max,\n        mean: sum / numPixels,\n    };\n}\nexport { calculateMinMaxMean };\n","import { utilities as csUtils, StackViewport, VolumeViewport, } from '@cornerstonejs/core';\nfunction extractWindowLevelRegionToolData(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        return extractImageDataVolume(viewport);\n    }\n    if (viewport instanceof StackViewport) {\n        return extractImageDataStack(viewport);\n    }\n    throw new Error('Viewport not supported');\n}\nfunction extractImageDataVolume(viewport) {\n    const { scalarData, width, height } = csUtils.getCurrentVolumeViewportSlice(viewport);\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    return {\n        scalarData,\n        minPixelValue,\n        maxPixelValue,\n        width,\n        height,\n        rows: width,\n        columns: height,\n    };\n}\nfunction extractImageDataStack(viewport) {\n    const imageData = viewport.getImageData();\n    const { scalarData } = imageData;\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    const width = imageData.dimensions[0];\n    const height = imageData.dimensions[1];\n    const { rows, columns, color } = viewport.getCornerstoneImage();\n    return {\n        scalarData,\n        width,\n        height,\n        minPixelValue,\n        maxPixelValue,\n        rows,\n        columns,\n        color,\n    };\n}\nexport { extractWindowLevelRegionToolData };\n","function getLuminanceFromRegion(imageData, x, y, width, height) {\n    const luminance = [];\n    let index = 0;\n    const pixelData = imageData.scalarData;\n    let spIndex, row, column;\n    if (imageData.color) {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n                const red = pixelData[spIndex];\n                const green = pixelData[spIndex + 1];\n                const blue = pixelData[spIndex + 2];\n                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n            }\n        }\n    }\n    else {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = (row + y) * imageData.columns + (column + x);\n                luminance[index++] = pixelData[spIndex];\n            }\n        }\n    }\n    return luminance;\n}\nexport { getLuminanceFromRegion };\n","export const version = '3.24.0';\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n"],"names":["config","getConfig","setConfig","newConfig","polysegInitialized","getPolySeg","addons","polySeg","console","warn","polyseg","init","DEFINED_CURSORS","Symbol","STANDARD_CURSORS","Set","MouseCursor","constructor","name","fallback","this","getName","addFallbackStyleProperty","style","getStyleProperty","getDefinedCursor","definedCursors","getDefinedCursors","mouseCursor","get","has","set","setDefinedCursor","cursor","context","symbol","Map","Object","defineProperty","value","standardCursorNames","values","ELEMENT_CURSORS_MAP","initElementCursor","element","_getElementCursors","_setElementCursor","cursors","resetElementCursor","hideElementCursor","map","WeakMap","ImageMouseCursor","url","x","y","super","getUniqueInstanceName","Number","prefix","utilities","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Height","Probe","RectangleROI","Label","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","assign","create","registerCursor","toolName","svgCursorNames","keys","STATE","AnnotationStyleStates","Highlighted","MODE","ToolModes","Active","SVGMouseCursor","pointer","color","urn","type","getCursorURN","descriptor","getDefinedSVGCursorDescriptor","options","blob","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","URL","createObjectURL","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","prototype","hasOwnProperty","bind","replace","match","key","svgSize","Math","max","cursorName","log","setElementCursor","CursorNames","svgDrawingHelper","annotationUID","ellipseUID","corner1","corner2","dataId","top","bottom","left","right","canvasCoordinates","width","lineWidth","lineDash","undefined","strokeWidth","svgNodeHash","existingEllipse","getSvgNode","w","hypot","h","angle","atan2","PI","center","attributes","cx","cy","rx","ry","stroke","fill","transform","setNodeTouched","svgEllipseElement","document","createElementNS","setAttribute","appendNode","handleGroupUID","handle","uniqueIndex","handleRadius","opacity","r","Error","side","parseFloat","height","existingHandleElement","newHandleElement","drawLine","lineUID","start","end","isNaN","markerStartId","markerEndId","shadow","strokeOpacity","existingLine","layerId","svgLayerElement","id","dropShadowStyle","x1","y1","x2","y2","newLine","drawPath","pathUID","points","pointsArrays","length","Array","isArray","fillColor","fillOpacity","closePath","existingNode","pointsAttribute","i","numArrays","numPoints","j","point","toFixed","d","newNode","drawPolyline","polylineUID","existingPolyLine","firstPoint","newPolyLine","drawRectByCoordinates","rectangleUID","_width","existingRect","topLeft","topRight","bottomLeft","bottomRight","leftEdgeCenter","svgRectElement","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","querySelector","removeChild","getBBox","insertBefore","firstChild","bBox","textUID","textLines","position","padding","fontFamily","fontSize","background","textGroupBoundingBox","svgns","existingTextGroup","textElement","textSpans","from","children","textSpan","appendChild","textAttributes","textGroupAttributes","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","drawHeight","heightUID","midX","endfirstLine","endsecondLine","firstLine","secondLine","threeLine","fanUID","innerRadius","outerRadius","startAngle","endAngle","zIndex","_getHash","existingFanElement","startRad","endRad","outerStartX","cos","outerStartY","sin","outerEndX","outerEndY","innerStartX","innerStartY","largeArcFlag","pathData","setAttributesIfNecessary","newFanElement","toString","setNewAttributesIfValid","drawArrow","arrowUID","viaMarker","markerSize","headLength","legacyDrawArrow","markerFullId","defs","arrowMarker","arrowPath","drawRedactionRect","tlhc","min","abs","svgNode","forEach","currentValue","getAttribute","newValue","removeAttribute","enable","eventTarget","addEventListener","ANNOTATION_COMPLETED","handleAnnotationCompleted","ANNOTATION_MODIFIED","handleAnnotationUpdate","ANNOTATION_REMOVED","handleAnnotationDelete","disable","removeEventListener","Passive","Enabled","onCameraModified","evt","tool","Enums","CAMERA_MODIFIED","onCameraReset","onResetCamera","CAMERA_RESET","onImageRendered","detail","IMAGE_RENDERED","onImageSpacingCalibrated","IMAGE_SPACING_CALIBRATED","KEY_DOWN","KEY_UP","MOUSE_CLICK","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_DOUBLE_CLICK","MOUSE_DRAG","MOUSE_MOVE","MOUSE_UP","MOUSE_WHEEL","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_PRESS","mouseDoubleClickListener","mouseDownListener","mouseMoveListener","capture","preventGhostClick","touchStartListener","passive","wheelListener","segmentationId","modifiedSlicesToUse","representationData","getSegmentation","viewportIds","getViewportIdsWithSegmentation","hasVolumeViewport","some","viewportId","viewport","getEnabledElementByViewportId","VolumeViewport","hasStackViewport","StackViewport","hasBothStackAndVolume","segmentationVolume","cache","getVolume","volumeId","imageData","vtkOpenGLTexture","slicesToUpdate","numSlices","getDimensions","setUpdatedFrame","modified","performVolumeLabelmapUpdate","SegmentationRepresentations","Labelmap","representations","getSegmentationRepresentation","filter","representation","enabledElement","actorEntries","actorEntry","segImageData","actor","getMapper","getInputData","currentSegmentationImageIds","segmentationImage","getImage","performStackLabelmapUpdate","_imageChangeEventListener","eventData","renderingEngineId","getEnabledElementByIds","labelmapRepresentations","actors","getActors","updateLabelmapSegmentationImageReferences","labelmapActors","flatMap","find","derivedImageIds","includes","referencedId","removeActors","uid","currentImageId","getCurrentImageId","derivedImageId","derivedImage","segmentationActorInput","dimensions","spacing","direction","getImageDataMetadata","currentImage","imageId","origin","currentOrigin","originToUse","voxelManager","getConstructor","newPixelData","getScalarData","scalarArray","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","getPointData","setScalars","addImages","representationUID","callback","imageActor","setInputData","segmentationImageData","setDerivedImage","render","getEnabledElement","BaseVolumeViewport","PRE_STACK_NEW_IMAGE","async","contourSegmentationCompletedListener","sourceAnnotation","annotation","isContourSegmentationAnnotation","viewports","getViewportsForAnnotation","viewportWithToolRegistered","silent","toolGroup","getToolGroupForViewport","errorMessage","hasTool","getToolOptions","isFreehandContourSegToolRegisteredForViewport","getViewport","contourSegmentationAnnotations","sourceAnnotationUID","getAllAnnotations","targetAnnotation","areSameSegment","isReferenceViewable","metadata","getValidContourSegmentationAnnotations","triggerEvent","Events","ANNOTATION_CUT_MERGE_PROCESS_COMPLETED","sourcePolyline","data","contour","polyline","intersectingContours","targetPolyline","isContourHole","contourHoleProcessingEnabled","annotationCompletedListener","removed","getRenderingEngines","renderingEngine","getViewports","vp","triggerAnnotationRenderForViewportIds","t","annotationRemovedListener","removeContourSegmentationAnnotation","csToolsInitialized","defaultConfiguration","_removeCornerstoneEventListeners","elementEnabledEvent","ELEMENT_ENABLED","elementDisabledEvent","ELEMENT_DISABLED","addEnabledElement","removeEnabledElement","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","ANNOTATION_SELECTION_CHANGE","SEGMENTATION_MODIFIED","SEGMENTATION_DATA_MODIFIED","SEGMENTATION_REPRESENTATION_MODIFIED","SEGMENTATION_REPRESENTATION_ADDED","destroy","annotationManager","getAnnotationManager","segmentationStateManager","restoreAnnotations","resetState","annotationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedViewports","_throwIfDestroyed","elements","_viewportElements","_triggerRender","delete","size","_render","addViewportElement","removeViewportElement","_reset","renderViewport","_setViewportsToBeRenderedNextFrame","hasBeenDestroyed","_setAllViewportsToBeRenderedNextFrame","add","elementsEnabled","indexOf","window","requestAnimationFrame","getRenderingEngine","enabledTools","eventDetail","draw","anyRendered","renderAnnotation","rendered","ANNOTATION_RENDERED","cancelAnimationFrame","clear","FrameOfReferenceSpecificAnnotationManager","getGroupKey","annotationGroupSelector","FrameOfReferenceUID","_imageVolumeModifiedHandler","frameOfReferenceSpecificAnnotations","annotations","invalidated","getFramesOfReference","getAnnotations","groupKey","getAnnotation","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","addAnnotation","preprocessingFn","push","removeAnnotation","groupAnnotations","toolAnnotations","index","findIndex","splice","removeAnnotations","removedAnnotations","annotationsForTool","saveAnnotations","structuredClone","state","flat","getNumberOfAllAnnotations","count","removeAllAnnotations","IMAGE_VOLUME_MODIFIED","setPreprocessingFn","defaultFrameOfReferenceSpecificAnnotationManager","globalLockedAnnotationUIDsSet","setAnnotationLocked","locked","makeEventDetail","lockedAnnotationUIDsSet","added","isLocked","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","isAnnotationLocked","getAnnotationsLockedCount","checkAndSetAnnotationLocked","freeze","item","ANNOTATION_LOCK_CHANGE","selectedAnnotationUIDs","setAnnotationSelected","selected","preserveSelected","clearSelectionSet","isSelected","selectAnnotation","deselectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","defaultManager","setAnnotationManager","manager","clearParentAnnotation","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotationUIDs","addChildAnnotation","childAnnotation","parentUID","getParentAnnotation","getChildAnnotations","childAnnotationUID","HTMLDivElement","triggerAnnotationAddedForElement","triggerAnnotationAddedForFOR","triggerAnnotationRemoved","annotationManagerUID","invalidateAnnotation","currAnnotation","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","lastVisible","hidden","isVisible","ANNOTATION_VISIBILITY_CHANGE","checkAndSetAnnotationVisibility","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","angleArcLineDash","getAnnotationToolStyles","getViewportToolStyles","getToolGroupToolStyles","toolGroupId","toolGroups","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","mode","alternatives","list","getHierarchalPropertyStyles","highlighted","Selected","Locked","autoGenerated","AutoGenerated","Default","AnnotationGroup","annotationUIDs","_isVisible","visibleFilter","unboundVisibleFilter","setVisible","baseEvent","findNearby","uids","remove","annotationState","resetAnnotationManager","renderers","Contour","Surface","planarContourToolName","triggerSegmentationRender","segmentationRenderingEngine","renderSegmentationsForViewport","triggerSegmentationRenderBySegmentationId","renderSegmentation","_getAllViewports","_renderFlaggedSegmentations","_getViewportIdsForSegmentation","segmentationRepresentations","viewportRenderList","segmentationRenderList","_addPlanarFreeHandToolIfAbsent","display","error","Promise","resolve","allSettled","then","results","segmentationDetails","status","onSegmentationRender","SEGMENTATION_RENDERED","tools","addTool","setToolPassive","initialDefaultState","colorLUT","segmentations","viewportSegRepresentations","internalComputeVolumeLabelmapFromStack","imageIds","segmentationImageIds","volumeLoader","internalConvertStackToVolumeLabelmap","segmentation","defaultSegmentationStateManager","getDefaultRenderingConfig","cfun","ofun","addPoint","_stackLabelmapImageIdReferenceMap","_labelmapImageIdReferenceMap","getState","updateState","updater","newState","getColorLUT","lutIndex","getNextColorLUTIndex","updateSegmentation","payload","draftState","triggerSegmentationModified","addSegmentation","newSegmentation","getLabelmapImageIds","removeSegmentation","filteredSegmentations","triggerSegmentationRemoved","addSegmentationRepresentation","renderingConfig","getSegmentationRepresentations","debug","setRenderInactiveSegmentations","addDefaultSegmentationRepresentation","addLabelmapRepresentation","triggerSegmentationRepresentationModified","segmentReps","segments","segmentIndex","active","colorLUTIndex","_setActiveSegmentation","processLabelmapRepresentationAddition","volumeViewport","isBaseVolumeSegmentation","_updateLabelmapSegmentationReferences","labelmapImageIds","updateCallback","referenceImageId","viewableLabelmapImageIdFound","labelmapImageId","referencedImageId","asOverlay","_updateLabelmapImageIdReferenceMap","stackViewport","_updateAllLabelmapSegmentationImageReferences","getImageIds","sliceIndex","withNavigation","labelmapData","getLabelmapImageIdsForImageId","_generateMapKey","getCurrentLabelmapImageIdsForViewport","getCurrentLabelmapImageIdForViewport","getStackSegmentationImageIdsForViewport","associatedReferenceImageAndLabelmapImageIds","removeSegmentationRepresentationsInternal","specifier","removedRepresentations","currentRepresentations","activeRepresentationRemoved","every","shouldRemove","removeSegmentationRepresentations","triggerSegmentationRepresentationRemoved","remainingRepresentations","removeSegmentationRepresentation","suppressEvent","currentValues","newValues","setActiveSegmentation","getActiveSegmentation","activeSegRep","segRep","viewportRepresentations","typeMatch","idMatch","getSegmentationRepresentationVisibility","viewportRepresentation","setSegmentationRepresentationVisibility","entries","segment","addColorLUT","removeColorLUT","_getStackIdForImageIds","slice","round","join","getAllViewportSegmentationRepresentations","getSegmentationRepresentationsBySegmentationId","result","viewportReps","filteredReps","indexToUse","colorLUTToUse","missingColorLUTs","addSegmentationRepresentations","segmentationInputArray","segmentationInput","addContourRepresentationToViewport","contourInputArray","input","addContourRepresentationToViewportMap","viewportInputMap","inputArray","addLabelmapRepresentationToViewport","labelmapInputArray","addLabelmapRepresentationToViewportMap","addSurfaceRepresentationToViewport","surfaceInputArray","addSurfaceRepresentationToViewportMap","inputData","contourData","geometryIds","annotationUIDsMap","normalizedSegments","segmentsConfig","label","cachedStats","rest","normalizedSegment","surfaceData","geometryId","geometry","getGeometry","normalizeSurfaceSegments","normalizeSegments","addSegmentations","suppressEvents","setColorLUT","colorLUTsIndex","segmentationRepresentation","getSegmentIndexColor","colorValue","setSegmentIndexColor","colorReference","getActiveSegmentIndex","activeSegmentIndex","getSegmentations","viewportSegmentations","getViewportSegmentations","getViewportSegmentationRepresentations","computeStackLabelmapFromVolume","convertVolumeToStackLabelmap","computeVolumeLabelmapFromStack","args","getActorEntry","filterFn","filteredActors","getLabelmapActorUID","getLabelmapActorEntry","getLabelmapActorEntries","getActorEntries","startsWith","getSurfaceActorEntry","getSurfaceRepresentationUID","updateSegmentations","segmentationUpdateArray","segmentationUpdate","visibility","setSegmentIndexVisibility","getSegmentIndexVisibility","getHiddenSegmentIndices","reduce","acc","getStyle","setStyle","renderInactiveSegmentations","getRenderInactiveSegmentations","resetToGlobalStyle","hasCustomStyle","getViewportsAssociatedToSegmentation","getViewportAssociatedToSegmentation","getViewportWithMatchingViewPlaneNormal","dotThreshold","annotationViewPlaneNormal","viewPlaneNormal","normalizedAnnotationNormal","camera","getCamera","normalizedCameraNormal","dotProduct","getAnnotationMapFromSegmentation","contourRepresentationData","annotationMap","segmentIndices","annotationUIDsInSegmentMap","annotationUIDsInSegment","hasChildAnnotations","childPolylinesInformation","isClosed","closed","holesClosed","childInfo","childPolylines","holesPolyline","holesUIDs","closePolyline","lastPoint","extractSegmentPolylines","polyLinesMap","polylines","annotationsInfo","annotationInfo","getPolylinesMap","polylinesCanvasMap","convertContourPolylineToCanvasSpace","decimateContours","epsilon","polylineCanvas","decimatedPolyline2D","decimate","point2D","canvasToWorld","removeCompleteContourAnnotation","removeContourHoles","holeDetectionResults","findContourHoles","hole","holeIndexes","removeContourIslands","threshold","islands","findIslands","smoothContours","knotsRatioPercentage","smoothedPolyline","interpolateSegmentPoints","clearSegmentValue","setAtIndex","triggerSegmentationDataModified","removeSegment","setNextSegmentAsActive","isThisSegmentActive","updatedSegments","sort","a","b","currentIndex","nextSegmentIndex","previousSegmentIndex","setActiveSegmentIndex","helpers","convertStackToVolumeLabelmap","internalAddSegmentationRepresentation","representationInput","getColorLUTIndex","colorLUTOrIndex","JSON","parse","stringify","rep","removeAllSegmentations","immediate","_removeSegmentationRepresentations","labelmapDisplay","contourDisplay","removeRepresentation","surfaceDisplay","_removeRepresentationObject","removeAllSegmentationRepresentations","removeLabelmapRepresentation","removeContourRepresentation","removeSurfaceRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegmentIndices","parseInt","_getViewportIndex","arr","ar","_containsViewport","synchronizerId","eventName","eventHandler","_viewportOptions","_onEvent","_ignoreFiredEvents","_targetViewports","_eventSource","currentTarget","_sourceViewports","s","fireEvent","_enabled","_eventName","_eventHandler","_options","eventSource","_auxiliaryEvents","auxiliaryEvents","isDisabled","_hasSourceElements","setOptions","setEnabled","enabled","getOptions","viewportInfo","addTarget","addSource","source","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","removeTarget","getViewportElement","hasSourceViewport","hasTargetViewport","sourceViewport","sourceEvent","promises","targetViewport","ex","vp1","vp2","unique","vps","concat","u","_getUniqueViewports","_remove","disableHandler","getEventSource","synchronizers","sync","synchronizer","pop","synchronizerIndex","synchronizersFilteredByIds","notDisabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","viewportsInfo","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","getViewportsInfo","getToolInstance","toolInstanceName","toolInstance","getToolInstances","configuration","toolDefinition","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","renderingEngineUIDToUse","_findRenderingEngine","vpId","getActivePrimaryMouseButtonTool","Settings","getRuntimeSettings","setViewportsCursorByToolName","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","setToolMode","setToolDisabled","setToolEnabled","setToolActive","toolBindingsOptions","bindings","binding","TouchBinding","numTouchPoints","MouseBinding","obj","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","matchBindings","removeAllBindings","getDefaultPrimaryBindings","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","_getCursor","setToolConfiguration","overwrite","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","setActivePrimaryTool","activeToolName","getCurrentActivePrimaryToolName","clone","newToolGroupId","fnToolFilter","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","TOOL_MODE_CHANGED","renderingEngines","matchingEngines","engine","binding1","binding2","modifierKey","tg","toolGroupIndex","svgLayer","svgLayerId","classList","pointerEvents","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","viewportUid","renderingEngineUid","dataset","elementHash","svgNodeCache","_setSvgNodeCache","enabledElements","hasToolByName","removeTool","cancelActiveManipulations","toolsWithData","cancel","VIEWPORT_ELEMENT","_removeViewportFromSynchronizers","_removeViewportFromToolGroup","_removeEnabledElement","foundElementIndex","el","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","defaultState","isInteractingWithTool","isMultiPartToolActive","resetCornerstoneToolsState","resetSvgNodeCache","areViewportsCoplanar","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","getSpatialRegistration","targetId","sourceId","imageSliceSyncCallback","sViewport","disabled","imageId1","sourceImagePositionPatient","metaData","imagePositionPatient","targetImageIds","registrationMatrixMat4","getFrameOfReferenceUID","useInitialPosition","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","closestImageIdIndex","distance","Infinity","imageIndexToSet","getCurrentImageIdIndex","imageIndex","presentationViewSyncCallback","_synchronizerInstance","_sourceEvent","presentationView","getViewPresentation","setViewPresentation","slabThicknessSyncCallback","slabThickness","getSlabThickness","setSlabThickness","voiSyncCallback","modifiedEvent","range","invertStateChanged","invert","colormap","tProperties","voiRange","syncInvertState","syncColormap","_actors","setProperties","zoomPanSyncCallback","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createStackImageSynchronizer","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","STACK_NEW_IMAGE","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","createPresentationViewSynchronizer","viewPresentation","createVOISynchronizer","VOI_MODIFIED","COLORMAP_MODIFIED","createZoomPanSynchronizer","csEvents","isSegmentation","AdvancedMagnifyToolActions","PARALLEL_THRESHOLD","CONSTANTS","AdvancedMagnifyTool","Actions","toolProps","defaultToolProps","supportedInteractionTypes","magnifyingGlass","radius","zoomFactor","zoomFactorList","autoPan","actions","showZoomFactorsList","method","Secondary","KeyboardBindings","Shift","addNewAnnotation","currentPoints","worldPos","world","canvasPos","canvas","canvasHandlePoints","_getCanvasHandlePoints","viewUp","getReferencedImageId","magnifyViewportId","getToolName","sourceViewportId","isCanvasAnnotation","handles","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","delta","len","viewportIdsToRender","getViewportIdsWithToolToRender","preventDefault","dispose","isPointNearTool","canvasCoords","proximity","canvasTop","canvasBottom","canvasLeft","radiusPoint","getCanvasCircleRadius","toolSelectedCallback","editData","_activateModify","handleSelectedCallback","handleIndex","p","_endCallback","newAnnotation","_deactivateModify","isDrawing","triggerAnnotationCompleted","_dragDrawCallback","deltaPoints","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","renderStatus","filteredAnnotations","filterInteractableAnnotationsForElement","activeHandleCanvasCoords","drawHandles","circleUID","drawCircle","magnifyViewport","update","canvasCenterPos","canvasRadius","AdvancedMagnifyViewportManager","getInstance","canvasPoint","viewportElement","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","createElement","stopPropagation","keyCode","which","toLowerCase","option","title","defaultSelected","sourceElement","AdvancedMagnifyViewport","_addSourceElementEventListener","_magnifyViewportsMap","magnifyViewportInfo","_annotationRemovedCallback","destroyViewport","_newStackImageCallback","magnifyViewportsMapEntries","_getMagnifyViewportsMapEntriesBySourceViewportId","stackActorReInitialized","_newVolumeImageCallback","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","_initialize","_singleton","_removeEventListeners","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","newEnabledElement","_addEventListeners","newStackHandler","VIEWPORT_NEW_IMAGE_SET","newVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","_enabledElement","_sourceToolGroup","_magnifyToolGroup","_isViewportReady","_radius","_resized","_canAutoPan","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_mouseDragCallback","_resizeViewportAsync","_resizeViewport","_syncViewports","disableElement","parentNode","magnifyToolGroup","_inheritBorderRadius","magnifyElement","borderRadius","_createViewportNode","overflow","boxSizing","_convertZoomFactorToParallelScale","parallelScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","_cloneStack","setStack","_cloneVolumes","volumeInputArray","setVolumes","_cloneViewport","sourceViewportOptions","viewportInput","defaultOptions","enableElement","_cancelMouseEventCallback","target","closest","canvasCurrent","magnifyRadius","dist","distanceToPoint","maxDist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","newWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","newPosition","_addBrowserEventListeners","_removeBrowserEventListeners","sourceCanvas","_syncViewportsCameras","focalPoint","sqrt","pow","updatedFocalPoint","updatedPosition","_syncStackViewports","setImageIdIndex","sourceProperties","getProperties","getImageData","resize","AnnotationEraserTool","preMouseDownCallback","_deleteNearbyAnnotations","preTouchStartCallback","interactionType","annotationsToRemove","interactableAnnotations","createAnnotationMemo","deleting","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","viewportIndicatorsConfig","panSize","enableHDPIHandles","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","mobile","toolCenter","initializeViewport","_getAnnotations","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","normal","clientWidth","clientHeight","_getViewportsInfo","getToolGroup","resetCrosshairs","resetPan","resetZoom","resetToCenter","resetRotation","resetCamera","resetSlabThickness","_computeToolCenter","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","point1","normal2","point2","normal3","point3","firstPlane","secondPlane","thirdPlane","setToolCenter","jumpWorld","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","CROSSHAIR_TOOL_CENTER_CHANGED","_autoPanViewportIfNecessary","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","near","getHandleNearImagePoint","_areViewportIdArraysEqual","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","worldToCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","buildFromDegree","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","line","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","devicePixelRatio","handleUID","referenceColorCoordinates","xOffset","yOffset","circleRadius","_onNewVolume","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","volumeIds","getAllVolumeIds","otherVolumeIds","viewportsAnnotationsToUpdate","sameScene","_applyDeltaShiftToSelectedViewportCameras","_dragCallback","dir1","dir2","centerCanvas","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","translate","otherViewportsIds","renderViewports","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","lastPoints","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","toolCenterCanvas","pan","visiblePointCanvas","visiblePointWorld","deltaPointsWorld","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","c","_applyDeltaShiftToViewportCamera","newFocalPoint","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","getVolumeId","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","jumpToWorld","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","_activateDraw","viewportProperties","rotation","originalViewportRotation","magnifyToolElement","STACK","_dragEndCallback","_deactivateDraw","getTargetId","split","OverlayMarkerType","OrientationMarkerTool","CUBE","AXIS","VTPFILE","OVERLAY_MARKER_TYPES","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","ANNOTATED_CUBE","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","resolution","AXES","CUSTOM","polyDataURL","_resizeObservers","initViewports","_subscribeToViewportEvents","cleanUpData","orientationMarker","orientationMarkers","updateViewport","updatingOrientationMarker","unsubscribe","unobserve","subscribeToElementResize","resizeObserver","ResizeObserver","setTimeout","observe","offscreenMultiRenderWindow","getRenderWindow","filterViewportsWithToolEnabled","widget","getWidget","isDeleted","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","polyData","shallowCopy","getOutputData","setActiveScalars","mapper","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","EPSILON","OverlayGridTool","A","sourceImageIds","_init","imagePlaneModule","pointSets","calculateImageIdPointSets","viewportData","rows","columns","rowCosines","columnCosines","rowPixelSpacing","columnPixelSpacing","pointSet1","pointSet2","imageIdNormal","getImageIdNormal","isParallel","targetViewportPlane","targetData","initializeViewportData","pointSetsToUse","pointSetToUse","topBottomVec","isPerpendicular","lineStartsWorld","lineEndsWorld","lineStartWorld","lineEndWorld","vec1","vec2","dot","imageOrientationPatient","rowCosineVec","colCosineVec","PanTool","touchDragCallback","mouseDragCallback","PlanarRotateTool","mouseWheelCallback","wheel","setAngle","startPoints","currentPointWorld","startPointWorld","centerWorld","v1","v2","cross","rotAngle","rotMat","Float32Array","rotatedViewUp","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","textBox","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","isElementWithCursor","updateViewportImage","lineWidthBase","e","crosshairUIDs","upper","lower","centerSpace","lineLength","plane","currentMousePosition","closestIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","ReferenceLines","enforceSameFrameOfReference","showFullDimension","sourceViewportCanvasCornersInWorld","sourceViewPlaneNormal","topRightVec","newNormal","handleFullDimension","targetImage","getTargetImageData","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","indexToWorld","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","offset","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","updateCursorSize","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","triggerAnnotationModified","ChangeTypes","HandlesUpdated","dragCallback","sculpt","registerShapes","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mouseCanvasPoint","deltaWorld","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","contourIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertIndex","insertHandleRadially","last","previousIndex","nextIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","canvasPoints","toolIndex","distanceFromTool","renderShape","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","cacheId","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","floor","colorToString","getProperty","getColor","StackScrollTool","debounceIfNotLoaded","loop","deltaY","_scroll","_scrollDrag","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","debounceLoading","scrollSlabs","numberOfSlices","getNumberOfSlices","offsetHeight","TrackballRotateTool","rotateIncrementDegrees","rotateSampleDistanceFactor","_hasResolutionChanged","getDefaultActor","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","_viewportAddedListener","disconnect","rotateCamera","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","acos","sign","upVec","atV","rightV","forwardV","angleY","DIRECTIONS","VolumeRotateTool","cz","ax","ay","az","WindowLevelRegionTool","minWindowWidth","applyWindowLevelRegion","bottomLeftCanvas","topRightCanvas","bottomRightCanvas","topLeftCanvas","bottomRightWorld","topLeftWorld","getAnnotationStyle","drawRect","windowLevel","startCanvas","endCanvas","pixelLuminanceData","minMaxMean","minPixelValue","maxPixelValue","windowWidth","windowCenter","mean","voiLutFunction","VOILUTFunction","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","scalarData","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint8Array","Uint16Array","Int16Array","frame","buffer","_getMinMax","modality","newRange","viewportsContainingVolumeUID","isPreScaled","properties","volume","Modality","scaling","preScale","scaled","scalingParameters","suvbw","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","imageDynamicRange","imageVolume","calculatedDynamicRange","getMiddleSliceData","pixel","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","getRange","imageDataRange","getScalars","getData","voxel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","initialMousePosWorld","dirVec","_dragParallelProjection","pinch","deltaDistance","k","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","imageWidth","imageHeight","canvasAspect","displayArea","scaledImageWidth","imageArea","scaledImageHeight","minParallelScaleRequired","minScaleInWorld","maxScaleInWorld","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","_zoom","currentPointsList","parallelProjection","_panCallback","eventDetails","page","client","AngleTool","showAngleArc","arcOffset","getTextLines","defaultGetTextLines","angleStartedNotYetCompleted","getViewReference","movingTextBox","canvasPoint1","canvasPoint2","line1","canvasPoint3","line2","doneEditMemo","createMemo","worldPosDelta","_throttledCalculateCachedStats","_calculateCachedStats","anglePoints","temp","getLinkedTextBoxStyle","canvasTextBoxCoords","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","trailing","hydrate","instance","hydrateBase","serializableOptions","worldPos1","worldPos2","worldPos3","targetIds","StatsUpdated","cachedVolumeStats","String","fromCharCode","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","arrowHeadStyle","memo","setAnnotationLabel","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","stopImmediatePropagation","updatedText","_isInsideVolume","index1","index2","doneChangingTextCallback","prompt","transformWorldToIndex","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","unit","dataId1","dataId2","secondLineUID","getTextBoxCoordsCanvas","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","image","index3","index4","handles1","handles2","scale","scale1","units1","scale2","units2","dist1","_calculateLength","dist2","widthUnit","vector1","vector2","majorAxis","minorAxis","major0","major1","minor0","minor1","pos1","pos2","dz","CircleROITool","storePointData","centerPointRadius","statsCalculator","BasicStatsCalculator","dXCanvas","dYCanvas","canvasEnd","canvasCorners","getCanvasCircleCorners","areaUnit","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","area","stdDev","radiusUnit","perimeter","wasInvalidated","pos1Index","pos2Index","boundsIJK","xRadius","yRadius","zRadius","ellipseObj","worldWidth","worldHeight","isEmptyArea","aspect","pixelUnitsOptions","isSuvScaled","modalityUnit","pointsInShape","statsCallback","isInObject","pointLPS","pointInEllipse","fast","returnPoints","stats","getStatistics","statsArray","array","radiusLine","areaLine","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","_mouseDownCallback","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","mid1","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","DragProbeTool","postMouseDownCallback","postTouchStartCallback","ETDRSGridTool","degrees","diameters","diametersCanvas","diameter","worldMeasureToCanvas","degreesRad","angleRadians","degree","measurement","p1","p2","p1Canvas","p2Canvas","EllipticalROITool","initialRotation","getRotation","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","newHalfCanvasWidth","canvasRight","newHalfCanvasHeight","getCanvasEllipseCorners","centerPoint","_getCanvasEllipseCenter","post2Index","ellipse","rotLocation","normalized","ellipseCanvasPoints","HeightTool","_calculateHeight","outside","KeyImageTool","dataSeries","seriesLevel","dataPoint","isPoint","canvasPosition","createAnnotationForViewport","eventDispatchDetail","it","setPoint","LabelTool","textGroupElement","bbox","translateX","translateY","matches","initialWorldPos","anchorWorldPos","LabelChange","LengthTool","undo","redo","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","setupBaseEditData","scissors","nearestEdge","repeatInterpolation","interpolation","originalPoints","worldToSlice","sliceToWorld","handleSmoothing","hIndex","testPoint","startSearch","findPathToPoint","minPoint","findMinNearby","acceptedPath","path","addPoints","updateAnnotation","scissorsNext","InterpolationUpdated","renderAnnotationInstance","renderContext","showInterpolationPolyline","polylineCanvasPoints","isContourSegmentationTool","LivewireContourTool","contourHoleAdditionModifierKey","snapHandleNearby","cancelInProgress","proximitySquared","startPoint","endPoint","clearAnnotation","clearEditData","changeType","Completed","triggerChangeEvent","triggerContourAnnotationCompleted","doubleClick","worldPosOriginal","controlPoints","currentPath","getControlPoints","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","pathPoints","prependPath","confirmedPath","getLastPoint","addControlPoint","_mouseMoveCallback","lastCanvasPoint","imgWidth","imgHeight","slicePoint","editHandle","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","getCalibratedLengthUnitsAndScale","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","_renderStats","textboxStyle","eventType","throttle","nextPos","viewportImageData","vtkImageData","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","ijkPoint","startPos","createInstanceFromRawPixelData","currentPathNext","confirmedPathNext","createAnnotation","event","handlePoints","numHandles","previousHandle","nextHandle","slicePos","pathPointsLeft","pathPointsRight","reverse","appendPath","contourSegmentationAnnotation","annotationStyle","canvasHandles","textbox","livewirePath","pointArray","imagePoints","targetWindingDirection","Clockwise","updateContourPolyline","ProbeTool","probeDefaults","textCanvasOffset","mergeDefaultProps","ijk","getAtIJKPoint","imageURI","calibratedResults","hasEnhancedRegionValues","units","RegionSegmentPlusTool","isPartialVolume","positiveSeedVariance","negativeSeedVariance","subVolumePaddingPercentage","islandRemoval","mouseTimer","allowedToProceed","worldPoint","clearTimeout","onMouseStable","mouseStabilityDelay","refVolume","growCutData","referencedVolumeId","seeds","positiveSeedIndices","negativeSeedIndices","worldIslandPoints","runGrowCut","getRemoveIslandData","getGrowCutLabelmap","mergedOptions","growCut","RegionSegmentTool","currentWorldPoint","circleBorderPoint","circleCenterPoint","sphereInfo","segmentationData","canvasCenterPoint","canvasBorderPoint","vecCenterToBorder","getSegmentStyle","SplineContourSegmentationTool","annotationCutMergeCompletedBinded","annotationCutMergeCompleted","initializeListeners","removeListeners","splineToolNames","simplifiedSpline","convertContourSegmentationAnnotation","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","SplineTypes","spline","Cardinal","Class","CatmullRom","Linear","BSpline","drawPreviewEnabled","enableTwoPointPreview","lastControlPointDeletionKeys","AddControlPoint","DeleteControlPoint","Ctrl","fireChangeOnUpdate","isPointNearCurve","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","closeContour","addNewPoint","closestControlPoint","getClosestControlPointWithinDistance","moveAnnotation","addControlPointCallback","splineType","splineConfig","_getSplineConfig","closestPointInfo","getClosestPoint","addControlPointAtU","uValue","deleteControlPointCallback","annotationCompletedBinded","annotationCompleted","cancelAnnotation","annotationLocked","childAnnotations","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","getPolylinePoints","updateWindingDirection","numControlPoints","previewPolylinePoints","getPreviewPolylinePoints","controlPointsConnectors","createInterpolatedSplineControl","increment","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","setControlPoints","fixedResolution","fixedScale","splineInstance","SplineClass","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","lineSegment","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","values2","transformIndexToWorld","UltrasoundPleuraBLineTool","USPleuraBLineAnnotationType","BLINE","PLEURA","bLineColor","pleuraColor","drawDepthGuide","depth_ratio","depthGuideColor","depthGuideThickness","depthGuideDashLength","depthGuideDashGap","depthGuideOpacity","fanOpacity","showFanAnnotations","updatePercentageCallback","pleuraAnnotations","bLineAnnotations","annotationType","getActiveAnnotationType","newPoint","isInsideFanShape","getFanShapeGeometryParameters","fanCenter","indexToCanvasRatio","getIndexToCanvasRatio","unMergedPleuraIntervals","mergedPleuraIntervals","pleuraIntervalsDisplayed","bLineIntervalsDisplayed","drawAnnotation","getColorForLineType","lineInterval","fanNumber","interval","clippedInterval","fanDataId","drawFan","calculateBLinePleuraPercentage","activeAnnotationType","filterAnnotations","filterFunction","countAnnotations","getImageIdIndex","annotationMapping","counts","bLine","pleura","deleteAnnotations","setActiveAnnotationType","deleteLastAnnotationType","annotationList","updateFanGeometryConfiguration","fanGeometry","isFanShapeGeometryParametersValid","deriveFanGeometryFromViewport","calculateFanGeometry","pleuraIntervals","bLineIntervals","diffVector","radToDegree","rad","degreeToRad","indexToCanvas","depth_radius","theta_start","theta_range","arc_length","num_dashes","theta_step","theta1","theta2","start_point","end_point","calculateFanShapeCorners","imageBuffer","hull","roughContour","rough","slack","n","next","walk","to","idx","i2","i3","P2","P3","pathA","pathB","globalYmin","upperPath","topY","arcPts","P1","best","P4","pickPoints","refined","edgeBuf","opts","directions","snapQuadrant","pt","xmin","xmax","ymin","ymax","xi","yi","xAlign","yAlign","refineCornersDirectional","step","angleRad","deriveFanGeometry","params","centerResult","intersectLine","tempAngle","d1","d4","d2","d3","exportContourJpeg","pixelData","strokeStyle","quality","ctx","getContext","totalPixels","channels","imgData","createImageData","out","baseIn","baseOut","v","putImageData","beginPath","moveTo","lineTo","toDataURL","getPixelData","saveBinaryData","filename","href","download","body","click","downloadFanJpeg","contourType","simplified","jpegDataUrl","fan","startAngleInDegrees","endAngleInDegrees","exportFanJpeg","generateConvexHullFromContour","segmentLargestUSOutlineFromBuffer","channelCount","mask","isForeground","labels","currentLabel","regionSizes","getter","px","py","pixelCount","onFlood","diagonals","floodFill","largestLabel","isBorder","nx","ny","outer","dirs","current","prev","dx0","dy0","startDir","nextPt","bdx","bdy","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","rect","_getRectangleImageCoordinates","bottomLeftWorld","topRightWorld","point0","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldPos1Index","worldPos2Index","worldToIndexVec3","iMin","iMax","jMin","jMax","kMin","kMax","yMultiple","zMultiple","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex","substring","_getTargetStackUID","NEGATIVE_PIXEL_RANGE","POSITIVE_PIXEL_RANGE","ISLAND_PIXEL_RANGE","WholeBodySegmentTool","positivePixelRange","negativePixelRange","islandPixelRange","linePoints","_getHorizontalLineWorldPoints","horizontalLines","worldLine1P1","worldLine1P2","worldLine2P1","worldLine2P2","worldSquarePoints","referencedVolume","worldTopLeft","worldBottomRight","_getWorldBoundingBoxFromProjectedSquare","boundingBoxInfo","ijkTopLeft","ijkBottomRight","positiveSeedValue","negativeSeedValue","labelmapVolumeId","labelmapVolume","referencedVolumeData","getCompleteScalarDataArray","islandPointIndexes","pixelValue","_projectWorldPointAcrossSlices","worldEdgePoint","vecDirection","_getViewportVolume","ijkLineP1","ijkLineP2","_getCuboidIJKEdgePointsFromProjectedWorldPoint","_getWorldCuboidCornerPoints","cuboidPoints","worldSquarePoint","worldEdgePoints","worldCuboidPoints","_getHorizontalLineIJKPoints","ijkPoint1","ijkPoint2","TRANSFORM_MATRIX","getTransformMatrix","CardinalSpline","props","_scale","_fixedScale","s2","CatmullRomSpline","CubicSpline","getPreviewCurveSegments","controlPointPreview","closeSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","curveSegments","curveSegment","_getCurveSegment","getSplineCurves","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","curveSegmentIndex","p0","p3","_getCurveSegmentPoints","tt","ttt","tValues","qValues","p0Index","p2Index","p3Index","_getLineSegments","numLineSegments","inc","maxU","lineSegments","previousLineSegmentsLength","aabb","curveSegmentLength","lineSegAABB","lineSegLength","LinearSpline","QuadraticBezier","hasTangentPoints","QuadraticSpline","getLineSegments","Spline","_controlPoints","_invalidated","_length","_resolution","_fixedResolution","_closed","_update","_aabb","addControlPoints","_getLineSegmentAt","_curveSegments","controlPointPos","deleteControlPointByIndex","minControlPoints","clearControlPoints","updateControlPoint","newControlPoint","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","squaredDist","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","closestPoint","csA","csB","distanceSquared","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","getClosestPointOnControlPointLines","_convertCurveSegmentsToPolyline","closeDistance","previewCurveSegments","_getCurveSegmmentsWithinDistance","maxDistSquared","containsPoint","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","numIntersections","curveSegAABB","lineSegmentAABB","isVerticalLine","xIntersection","curveSegLength","polylinePoints","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","AnnotationDisplayTool","arguments","frameOfReference","viewReference","DefaultHistoryMemo","BaseTool","defaults","strategies","defaultStrategy","activeStrategy","strategyOptions","mergedDefaults","initialProps","defaultProps","additionalProps","applyActiveStrategy","operationData","call","applyActiveStrategyCallback","callbackType","extraArgs","setConfiguration","newConfiguration","getViewReferenceId","createZoomPanMemo","zoom","zoomPanMemo","restoreMemo","currentPan","currentZoom","commitMemo","polySegConversionInProgressForViewportId","processedViewportSegmentations","contourRepresentation","canComputeRequestedRepresentation","computeContourData","hasContourDataButNotMatchingViewport","viewportNormal","uidSet","randomAnnotationUIDs","annotationNormal","_checkContourNormalsMatchViewport","validGeometry","geometryData","contours","_checkContourGeometryMatchViewport","viewportProcessed","viewportStatus","RENDERED","computeSurfaceData","pointsAndPolys","polys","polyDataCache","clipAndCacheSurfacesForViewport","rawResults","extractContourData","createAndAddContourSegmentationsFromClippedSurfaces","renderImmediate","labelMapConfigCache","polySegConversionInProgress","_setLabelmapColorAndOpacity","labelmapActorEntry","activeSegmentation","isActiveLabelmap","labelmapStyle","numColors","outlineWidth","renderOutline","outlineOpacity","activeSegmentOutlineWidthDelta","_getLabelmapConfig","segmentsHidden","segmentColor","segmentSpecificLabelmapConfig","fillAlpha","renderFill","forceOpacityUpdate","forceColorUpdate","_needsTransferFunctionUpdate","addRGBPoint","segmentOpacity","removePoint","addPointLong","setClamping","labelmapActor","preLoad","setRGBTransferFunction","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","setLabelOutlineThickness","setVisibility","labelmapConfig","segmentsLabelmapConfig","configToUse","fillAlphaInactive","outlineWidthInactive","renderFillInactive","renderOutlineInactive","outlineOpacityInactive","cacheUID","oldConfig","cfunMTime","getMTime","ofunMTime","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","oldCfunMTime","oldOfunMTime","_addLabelmapToViewport","labelmapActorEntries","computeLabelmapData","SurfaceData","updateSurfaceData","surfaces","isHidden","surface","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL","brushSize","useCenterSegmentIndex","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","StrategyCallbacks","AcceptPreview","RejectPreview","Interpolate","useBallStructuringElement","noUseDistanceTransform","noUseExtrapolation","interpolateExtrapolation","_editData","createEditData","_previewData","isDrag","timerStart","Date","now","hoverData","_hoverData","createHoverData","getOperationData","OnInteractionStart","timer","time","rejectPreview","previewCallback","strategyData","strategy","segmentationVoxelManager","Preview","OnInteractionEnd","acceptPreview","_calculateCursor","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","brushCursor","computeInnerCircleRadius","GetStatistics","interpolate","invalidateBrushCursor","getActiveSegmentationData","toolMetadata","brushCursorUID","centerSegmentIndexInfo","dynamicRadiusInCanvas","circleUID1","CircleROIStartEndThresholdTool","numSlicesToPropagate","calculatePointsInsideVolume","showTextBox","throttleTimeout","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","statistics","labelmapUID","_computeProjectionPoints","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","viewplaneNormal","tempStartCoordinate","tempEndCoordinate","_getCoordinateForViewplaneNormal","roundedStartCoordinate","roundedEndCoordinate","cameraCoordinate","roundedCameraCoordinate","middleCoordinate","isMiddleSlice","_getIndexOfCoordinatesForViewplaneNormal","lineWidthToUse","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","handlesToStart","startWorld","indexToWorldVec3","endWorld","projectionAxisIndex","newProjectionPoints","basePoints","pointsInsideVolume","measureInfo","modalityUnitOptions","worldProjectionPointIndex","indexOfProjection","numSlicesToPropagateFromStart","numSlicesToPropagateToEnd","endPos","viewplaneNormalAbs","pos","_context","CircleScissorsTool","FILL_INSIDE","ERASE_INSIDE","activeLabelmapSegmentation","segmentsLocked","segmentLocking","segmentationImageId","LabelMapEditWithContourTool","annotationsToViewportMap","viewportIdsChecked","allowOpenContours","onViewportAddedToToolGroupBinded","onViewportAddedToToolGroup","onSegmentationModifiedBinded","onSegmentationModified","annotationModified","cleanUpListeners","checkContourSegmentation","activeSeg","viewportContoursToLabelmap","isEqual","PaintFillTool","activeSegmentationRepresentation","currentSegmentationImageId","getDirection","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","flooded","scalarDataIndex","framesModified","getFramesModified","boundaries","minJ","maxJ","seedIndex3D","z","getAtIJK","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","toIndex","getScalarDataPosition","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","RectangleROIStartEndThresholdTool","projectionPointsImageIds","indexOfDirection","roundedStartCoord","roundedEndCoord","coord","roundedCoord","firstOrLastSlice","habdles","projectionPoint","RectangleROIThresholdTool","RectangleScissorsTool","SegmentBidirectionalTool","existingAnnotation","SegmentLabelTool","hoverTimeout","searchRadius","hoverTimer","_setHoveredSegment","_setHoveredSegmentForType","hoveredSegmentIndex","getSegmentIndexAtWorldPoint","hoveredSegmentLabel","SegmentSelectTool","SelectMode","Inside","Border","_setActiveSegment","_setActiveSegmentForType","getSegmentIndexAtLabelmapBorder","getHoveredContourSegmentationAnnotation","SphereScissorsTool","getEditData","EnsureImageVolumeFor3DManipulation","referencedImageIds","imageVoxelManager","EnsureSegmentationVolumeFor3DManipulation","segImageIds","segVolume","initializeCircle","Initialize","centerIJK","circleCornersIJK","getBoundingBoxAroundShapeIJK","createPointInEllipse","isInObjectBoundsIJK","worldInfo","sphereObj","radius2","precalculated","precalculatePointInEllipse","CIRCLE_STRATEGY","regionFill","setValue","determineSegmentIndex","labelmapStatistics","CIRCLE_THRESHOLD_STRATEGY","dynamicThreshold","fillInsideCircle","strategyFunction","thresholdInsideCircle","fillOutsideCircle","initializeRectangle","pointInShapeFn","rectangleCornersIJK","isStackViewport","isAligned","getSpacing","EPS","pointsBoundsLPS","getBoundingBoxAroundShapeWorld","xMin","xMax","yMin","yMax","zMin","zMax","createPointInRectangle","RECTANGLE_STRATEGY","RECTANGLE_THRESHOLD_STRATEGY","fillInsideRectangle","thresholdInsideRectangle","ContourWindingDirection","AnnotationMultiSlice","setStartRange","startRange","setRange","setEndRange","endRange","rangeEndSliceIndex","getSliceIndexForImage","multiSliceReference","MetadataReferenceModified","setViewportFrameRange","setSingle","getFrameRange","getFrameRangeStr","setFrameRange","annotationHydration","worldPoints","getClosestImageIdForStackViewport","getClassName","getTargetVolumeId","distanceImagePairs","ImagePositionPatient","dir","calculateDistanceToImage","numSlicesToProject","sliceNormalIndex","calculateBoundingBox","isWorld","is3D","clipBounds","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","USER","calibrateSpacing","ViewportStatus","debounced","dynamicVolumesPlayingMap","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","playClipContext","waitForRendered","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","scroll","_createStackViewportCinePlayContext","_getVolumeFromViewport","isDynamicVolume","numDimensionGroups","dimensionGroupNumber","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","_createVolumeViewportCinePlayContext","VideoViewport","getSliceIndex","play","fps","setPlaybackRate","getFrameRate","_createVideoViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","bounce","timeouts","isTimeVarying","vector","sample","delay","sum","limit","_getPlayClipTimeouts","playClipAction","newStepIndex","CLIP_STOPPED","_stopClipWithData","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","toolState","pause","dynamicCineElement","clearInterval","dynamicVolumeId","addToolState","getToolState","getToolStateByViewportId","addContourSegmentationAnnotation","annotationsUIDsSet","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","contourSegmentationOperation","sourceAnnotationOrUID","targetAnnotationOrUID","getViewportFromAnnotation","intersectionInfo","hasIntersection","findAllIntersectingContours","sourceAABB","targetAABB","lineSegmentsIntersect","projectedPolyline","DEFAULT_CONTOUR_SEG_TOOL_NAME","endPointWorld","originalToolName","interpolationUID","interpolationCompleted","DEFAULT_CONTOUR_SEG_TOOLNAME","addPolylinesToSegmentation","currentSet","getPolylines","extractPolylines","segmentIndex1","segmentIndex2","polyLines1","polyLines2","polyLinesCanvas1","polyLinesCanvas2","addition","polyLinesWorld","unifyPolylineSets","annotationUIDsMapNew","subtraction","processMultipleIntersections","holeOperations","mergeOperations","primaryHoleTarget","holeAnnotation","holeContour","holePolylineCanvas","windingDirection","CounterClockwise","createPolylineHole","updateViewportsForAnnotations","allAnnotationsToRemove","allResultPolylines","allHoles","holes","getContourHolesData","sourceStartPoint","shouldMerge","resultPolyline","subtractedPolylines","holeData","baseAnnotation","newAnnotations","createNewAnnotationFromPolyline","parentPolyline","reassignHolesToNewAnnotations","processSequentialIntersections","updatedToolNames","convertContourPolylineToWorld","checkIntersection","combinePolylines","mergePolylines","contourHolesData","unassignedContourHolesSet","reassignedContourHolesMap","assignHoleToPolyline","newPolylines","mergedPolyline","newPolyline","contourHolesDataArray","contourHoleData","templateAnnotation","polylinesSetA","polylinesSetB","processedFromA","processedFromB","polylineA","merged","polylineB","intersection","unifyMultiplePolylineSets","polylineSets","unifyAnnotationPolylines","annotationsSetA","annotationsSetB","convertPolylineToCanvasSpace","subtractPolylineSets","currentPolylines","wasSubtracted","currentPolyline","subtractMultiplePolylineSets","basePolylineSet","subtractorSets","subtractAnnotationPolylines","baseAnnotations","subtractorAnnotations","findNextLink","lines","contourPoints","cell","nextLine","remainingLines","findContours","firstCell","shift","extraContours","findContoursFromReducedSet","findHandlePolylineIndex","closestDistance","testIndex","islandIndexes","getSignedArea","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","canvasHoleContour","getContourHolesDataWorld","getDeduplicatedVTKPolyDataPoints","bypass","getPoints","getLines","pointsArray","getNumberOfPoints","_","getPoint","linesArray","getNumberOfCells","getCell","newPoints","newIndex","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","firstPolyline","secondPolyline","firstDistance","secondDistance","processContourHoles","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","hContour","outerContour","innerContour","vertices","pointsNotEnclosed","inside","xj","yj","getIsPointInsidePolygon","checkEnclosed","contourHoleSet","holeIndex","isPolygonInsidePolygon","inner","containsPoints","closedPolylines","originalIndex","outerArea","potentialHole","generateContourSetsFromLabelmap","registerComputeWorker","WorkerTypes","GENERATE_CONTOUR_SETS","segVolumeId","getOrCreateSegmentationVolume","vol","segmentationInfo","getOrigin","contourSets","getWebWorkerManager","executeTask","refImages","refImageId","refImageDataMetadata","processedContourSets","contourSet","sliceContours","refImageIndex","imageDataMetadata","scanAxisNormal","FrameNumber","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","validateAnnotation","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","random","register","RectangleROIStartEndThreshold","acceptAutogeneratedInterpolations","selector","InterpolationManager","acceptAutoGenerated","polylineData","transforms","polylineWorldPoints","currentClosedState","lastToFirstDist","updatedWindingDirection","sumOverDimensionGroups","dimensionGroups","arrayLength","getScalarDataLength","resultArray","getDimensionGroupScalarData","operationFunctions","SUM","AVERAGE","sumArray","averageOverDimensionGroups","SUBTRACT","scalarData1","scalarData2","generateImageFromTimeData","dynamicVolume","operation","dimensionGroupNumbers","frameNumbers","operationFunction","updateVolumeFromTimeData","targetVolume","targetVoxelManager","resetModifiedSlices","modifiedSlices","maskVolumeId","worldCoordinate","dataInTime","ijkCoords","maskImageData","segVoxelManager","scalarDataLength","nonZeroVoxelIndices","actualLen","getAtIndex","nonZeroVoxelValuesInTime","isSameVolume","valuesInTime","getAtIndexAndDimensionGroup","toIJK","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","perDimensionGroupSum","averageCallback","averageValues","_getDimensionGroupDataMask","coordinate","worldToIndex","scalarIndex","_getDimensionGroupDataCoordinate","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","found","findAnnotationNearPointByTool","currentId","CalibrationTypes","PIXEL_UNITS","VOXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","calibration","hasPixelSpacing","volumeUnit","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","ERROR","PROJECTION","CALIBRATED","UNKNOWN","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","getPixelValueUnitsImageId","getPixelValueUnits","generalSeriesModule","petSeriesModule","_handlePTModality","_getSphereBoundsInfo","circlePoints","directionVectors","radiusWorld","row","rowCosine","column","columnCosine","vecNormal","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJK","getSphereBoundsInfo","scanAxis","getSphereBoundsInfoFromViewport","getEnabledElements","roundNumber","numPoint","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","maxDistIndex","decimatedPolyline","srcIndex","dstIndex","refPoint","aX","aY","bX","numPolylinePoints","distFirstToLastPoints","distanceToPointSquared","findClosestPoint","sourcePoints","minDistance","MAX_SAFE_INTEGER","sourcePoint","_distanceBetween","moveAnnotationToViewPlane","projectedDistance","acquisitionMapping","ijkPrime","fromIJK","jkMapping","ikMapping","normalizeViewportPlane","boundsIJKPrime","mapping","getOrientationStringLPS","orientation","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","smoothAnnotation","pointInSurroundingSphereCallback","spacings","maxRadiusIJK","ceil","sphereCornersIJK","getBoundingBoxAroundShape","_computeBoundsIJKWithCamera","_getBounds","createScalarVolumeVoxelManager","pointToString","decimals","idx3","getPolyDataPointIndexes","linesData","segmentSize","findStartingPoint","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","referenceVolume","AllBoundsIJK","pointsToUse","g","accumulator","registered","workerManager","computeWorkerConfig","computeWorker","maxWorkerInstances","autoTerminateOnIdle","idleTimeThreshold","registerWorker","Worker","uuidv4","ChangeTypesForInterpolation","toolNames","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","isInterpolationUpdate","SegmentStatsCalculator","calculators","statsInit","statsData","calculator","volumetricStatsCallback","maxIJKs","dataCopy","volumetricGetStatistics","volumeScale","entry","VolumetricCalculator","volumetricState","optionsWithUnit","InstanceVolumetricCalculator","setBrushSizeForToolGroup","viewportsInfoArray","getBrushSizeForToolGroup","toolInstances","brushToolInstance","setBrushThresholdForToolGroup","getBrushThresholdForToolGroup","computeMetabolicStats","segmentationIds","COMPUTE_STATISTICS","labelmapVolumes","mergedLabelmap","createMergedLabelmapForIndex","referenceImageIds","labelmap","firstImage","volumeInfo","getVolumeContainingImageId","getOrCreateImageVolume","getReferenceVolumeForSegmentation","imageInfo","calculateForVolume","contourAndFindLargestBidirectional","containedSegmentIndices","createBidirectionalToolData","bidirectionalData","VoxelManager","RLEVoxelMap","createLabelmapMemo","createRleMemo","isUndo","undoVoxelManager","redoVoxelManager","useVoxelManager","setAtIJKPoint","slices","getArrayOfModifiedSlices","createRLEHistoryVoxelManager","operationType","copyMap","createRLEVolumeVoxelManager","createLabelmapVolumeForViewport","labelmaps","outputData","cachedVolume","mergedVolume","setCompleteScalarDataArray","findLargestBidirectional","maxBidirectional","isInSegment","sliceContour","bidirectional","createBidirectionalForSlice","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","distance2","testCenter","handle0","handle1","unitMajor","maxMinorPoints","lpad","string","character","seed","onBoundary","equals","startNode","permutations","perms","permutation","permute","perm","countNonZeroes","prunedPermutations","stack","visits","bounds","currentArgs","flood","job","getArgs","prevArgs","previousArgs","visited","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getBrushToolInstances","generateVolumeId","getReferenceVolumeForSegmentationVolume","segmentationVolumeId","indexIJK","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","segmentationActorEntry","deltaK","neighborIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","desiredRepresentation","representationType","getScalarValueFromWorld","getSegmentIndexAtWorldForLabelmap","annotationsSet","isPointInsidePolyline3D","getSegmentIndexAtWorldForContour","getSegmentLargestBidirectional","COMPUTE_LARGEST_BIDIRECTIONAL","segData","reconstructableVolume","calculateVolumeBidirectional","isStack","calculateStackBidirectional","radiusForVol1","updateStatsArray","newStat","existingIndex","stat","processSegmentationStatistics","radiusIJK","testMax","testStats","getSphereStats","peakValue","peakPoint","mtv","suvMean","lesionGlycolysis","imageVoxels","centerLPS","_pointLPS","boundsOrig","finalStats","calculateVolumeStatistics","calculateStackStatistics","getUniqueSegmentIndices","cachedResult","keySet","addImageSegmentIndices","addVolumeSegmentIndices","handleLabelmapSegmentation","handleContourSegmentation","handleSurfaceSegmentation","WEBGPU_MEMORY_LIMIT","DEFAULT_GROWCUT_OPTIONS","windowSize","maxProcessingTime","inspection","numCyclesInterval","numCyclesBelowThreshold","referenceVolumeId","workGroupSize","numIterations","volumePixelData","requiredLimits","maxStorageBufferBindingSize","maxBufferSize","adapter","navigator","gpu","requestAdapter","device","requestDevice","BUFFER_SIZE","byteLength","UPDATED_VOXELS_COUNTER_BUFFER_SIZE","Uint32Array","BYTES_PER_ELEMENT","BOUNDS_BUFFER_SIZE","Int32Array","shaderModule","createShaderModule","code","paramsArrayValues","gpuParamsBuffer","createBuffer","usage","GPUBufferUsage","UNIFORM","COPY_DST","gpuVolumePixelDataBuffer","STORAGE","queue","writeBuffer","gpuLabelmapBuffers","COPY_SRC","gpuStrengthBuffers","gpuCounterBuffer","gpuBoundsBuffer","initialBounds","bindGroupLayout","createBindGroupLayout","GPUShaderStage","COMPUTE","bindGroups","outputLabelmapBuffer","outputStrengthBuffer","previouLabelmapBuffer","previousStrengthBuffer","createBindGroup","layout","resource","pipeline","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","workGroupSizeX","workGroupSizeY","workGroupSizeZ","numWorkGroups","gpuUpdatedVoxelsCounterStagingBuffer","MAP_READ","limitProcessingTime","performance","currentInspectionNumCyclesInterval","belowThresholdCounter","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","updatedVoxelsCounterResultBuffer","getMappedRange","updatedVoxelsRatio","unmap","outputLabelmapBufferIndex","labelmapStagingBuffer","boundsStagingBuffer","labelmapResultBuffer","labelmapResult","boundsResultBuffer","boundsResult","minZ","maxZ","clearBounds","setBounds","POSITIVE_SEED_VALUE","NEGATIVE_SEED_VALUE","_createAndCacheSegmentationSubVolumeForBoundingBox","subVolume","subVolPixelData","startSliceIndex","stopSliceIndex","pixelsPerSlice","zOffset","_setPositiveSeedValues","sliceOffset","bfs","slicePixelIndex","volumeVoxelIndex","volumeVoxelValue","scanLine","limitX","incX","_setNegativeSeedValues","runGrowCutForBoundingBox","subVolumeBoundsIJK","targetBuffer","POSITIVE_SEED_VARIANCE","NEGATIVE_SEED_VARIANCE","vecColumn","sphereCenterPoint","sphereRadius","refVolImageData","topCirclePoint","bottomCirclePoint","sphereBoundsInfo","_getGrowCutSphereBoundsInfo","_createAndCacheSegmentationSubVolumeForSphere","refVolumePixelData","worldStartPos","numPixelsPerSlice","ijkStartPosition","referencePixelValue","positiveSeedVarianceValue","minPositivePixelValue","maxPositivePixelValue","neighborsCoordDelta","startVoxelIndex","ijkVoxel","neighborCoordDelta","nz","neighborVoxelIndex","neighborPixelValue","worldVecRowDir","worldVecSliceDir","ijkSphereCenter","negativeSeedVarianceValue","minNegativePixelValue","maxNegativePixelValue","rotationAngle","worldQuat","vecRotation","worldCircleBorderPoint","ijkCircleBorderPoint","runGrowCutForSphere","ijkVecRowDir","ijkVecColDir","vec","sphereBoundsIJK","_createSubVolumeFromSphere","MAX_POSITIVE_SEEDS","calculateGrowCutSeeds","refImageData","referenceVolumeVoxelManager","neighborhoodRadius","initialNeighborhoodRadius","positiveK","positiveStdDevMultiplier","negativeK","negativeStdDevMultiplier","negativeSeedMargin","negativeSeedsTargetPatches","ijkStart","initialStats","positiveIntensityMin","positiveIntensityMax","startValue","currentQueueIndex","neighborValue","positiveSum","positiveSumSq","positiveCount","positiveMean","positiveVariance","negativeDiffThreshold","minXm","minYm","minZm","maxXm","maxYm","maxZm","attempts","patchesAdded","maxAttempts","rz","centerIndex","centerValue","patchContributed","runOneClickGrowCut","positiveSeedLabel","negativeSeedLabel","isLineInSegment","ijk1","ijk2","testIJK","testSize","unitDelta","createIsInSegment","createIsInSegmentMetadata","SegmentationEnum","IslandRemoval","fillInternalEdge","maxInternalRemove","initialize","segmentationVoxels","hasSource","sourceVoxelManager","previewVoxelManager","previewSegmentIndex","clickedPoints","getBoundsIJK","bound","depth","segmentSet","fillFrom","oldVal","SEGMENT","normalizer","selectedPoints","floodFillSegmentIsland","floodedCount","clickedPoint","iPrime","jPrime","kPrime","ISLAND","removeExternalIslands","rle","clearPoint","rowModified","removeInternalIslands","forEachRow","baseIndex","lastRle","INTERIOR","rowPrev","getRun","rowNext","isLast","isFirst","prevCovers","covers","nextCovers","EXTERIOR","singlePlane","newType","INTERIOR_TEST","INTERIOR_SMALL","rowRle","thresholdVolumeInformation","validToolNames","_validateAnnotations","outputSegmentationVolume","segmentContourAction","configurationData","getSegment","defaultGetSegment","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","segmentData","segmentationIndex","overlapType","baseVolumeIdx","volumeInfoList","refVoxelManager","volumeSize","_handleSameSizeVolume","overlaps","segScalarDataLength","overlapBounds","callbackOverlap","overlapTest","_handleDifferentSizeVolume","testOverlapRange","voxelSpacing","voxelCenter","testRange","insert","equalsCheck","getVoxelOverlap","halfSpacingX","halfSpacingY","halfSpacingZ","voxelCornersIJK","offsets","xOff","yOff","zOff","processVolumes","segmentationSpacing","segmentIndicesCache","setSegmentationDirty","cached","isDirty","getCachedSegmentIndices","setCachedSegmentIndices","triggerWorkerProgress","workerType","progress","WEB_WORKER_PROGRESS","getSegmentationDataForWorker","refImageIds","prepareVolumeStrategyDataForWorker","ensureSegmentationVolumeFor3DManipulation","ensureImageVolumeFor3DManipulation","prepareStackDataForWorker","segImageId","segImage","segPixelData","refImage","refPixelData","refSpacing","getImageReferenceInfo","cachedImage","scalingModule","Boolean","validateRepresentationData","segmentationRepresentationData","validatePublic","validate","updatedLabel","resetPrefetchTimeout","maxImagesToPrefetch","minBefore","maxAfter","directionExtraImages","preserveExistingPool","prefetch","stackPrefetchData","stackPrefetch","indicesToRequest","removeFromList","imageIdIndex","indicesToRequestCopy","currentImageIdIndex","getImageLoadObject","isLoaded","imageLoadPoolManager","filterRequests","requestFn","imageLoader","getCachedImageBasedOnImageURI","decodeTimeInMS","loadTimeInMS","sizeInBytes","getMaxCacheSize","cacheFill","fillTime","fillSize","initialTime","initialSize","updateToolState","doneCallback","requestType","addRequest","onImageUpdated","stackCount","totalBytes","positionFraction","minIndex","maxIndex","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","getConfiguration","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","low","higherIndex","high","imageIdsToPrefetch","shouldLoadLower","shouldLoadHigher","indexOfCurrentImage","getDeltaPoints","curr","getMeanPoints","_subtractPoints2D","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","pairedDistance","triggerAnnotationRenderForToolGroupIds","toolGroupIds","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","vpCamera","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","DEFAULTS","MULTIPLIER","RANGE_TEXT_POSITION","Right","TICKS_BAR_SIZE","Colorbar","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","_mouseOutCallback","hideTicks","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","local","voiLower","voiUpper","newVoiRange","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_canvas","_createCanvas","_ticksBar","_createTicksBar","_rangeTextPosition","ticks","appendTo","rootElement","_addRootElementEventListeners","activeColormapName","colormapName","imageRange","currentVoiRange","onVoiChange","showFullImageRange","showFullPixelValueRange","reset","createRootElement","onContainerResize","updateTicksBar","containerSize","colormaps","items","Name","cm","ticksProps","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","rangeTextPosition","ticksBarTop","ticksBarLeft","Top","Left","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","getImageActor","minValue","maxValue","getRGBTransferFunction","ColorbarRangeTextPosition","calculateMinMaxMean","pixelLuminance","globalMin","globalMax","numPixels","spv","extractWindowLevelRegionToolData","extractImageDataVolume","getCornerstoneImage","extractImageDataStack","getLuminanceFromRegion","luminance","spIndex","red","green","blue","version","HASH_UNDEFINED","funcTag","genTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","freeSelf","self","root","Function","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","getNative","nativeCreate","symbolProto","symbolToString","Hash","ListCache","MapCache","assocIndexOf","eq","baseGet","object","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","isHostObject","toSource","getMapData","__data__","getValue","memoize","baseToString","number","quote","resolver","TypeError","memoized","apply","Cache","other","isObjectLike","exports","defaultValue"],"sourceRoot":""}