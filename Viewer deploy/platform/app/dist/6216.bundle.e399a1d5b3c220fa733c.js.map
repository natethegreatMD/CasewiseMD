{"version":3,"file":"6216.bundle.e399a1d5b3c220fa733c.js","mappings":"4IAEA,MAAMA,EAAmB,mBAwBzB,SAASC,EAAWC,EAAYC,GAC5B,GAAKC,EAAA,GAAMC,aAAaH,GAGxB,OAAIE,EAAA,GAAMC,aAAaH,GAAYC,GACxBC,EAAA,GAAMC,aAAaH,GAAYC,GAAUG,YADpD,CAGJ,CACA,SAASC,EAAWC,EAAiBN,EAAYO,EAASN,GACtD,IAAKC,EAAA,GAAMC,aAAaH,GACpB,OAAO,KAEXE,EAAA,GAAMC,aAAaH,GAAYC,GAAY,CACvCO,SAAS,EACTJ,OAAQG,GAEZD,EAAgBG,YAAYF,EAChC,CACA,SAASG,EAAeV,EAAYC,GAC3BC,EAAA,GAAMC,aAAaH,IAGpBE,EAAA,GAAMC,aAAaH,GAAYC,KAC/BC,EAAA,GAAMC,aAAaH,GAAYC,GAAUO,SAAU,EAE3D,CACA,SAASG,EAAeL,EAAiBN,GAChCE,EAAA,GAAMC,aAAaH,IAGxBY,OAAOC,KAAKX,EAAA,GAAMC,aAAaH,IAAac,QAASb,IACjD,MAAMc,EAAab,EAAA,GAAMC,aAAaH,GAAYC,IAC7Cc,EAAWP,SAAWO,EAAWX,SAClCE,EAAgBU,YAAYD,EAAWX,eAChCF,EAAA,GAAMC,aAAaH,GAAYC,KAGlD,CACA,QA7DA,SAA6BgB,GACzB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,WAAEG,EAAU,kBAAEC,GAAsBH,EACpClB,EAAa,GAAGoB,KAAcC,IAC9Bf,EAaV,SAAsBW,GAClB,MAAMK,EAAkB,IAAIxB,IACtByB,EAAqBN,EAAQO,cAAcF,GAC3CG,EAAWF,GAAoBC,cAAc,uBACnD,OAAOC,CACX,CAlB4BC,CAAaT,GAIrC,OAHAL,OAAOC,KAAKX,EAAA,GAAMC,aAAaH,IAAac,QAASb,IACjDC,EAAA,GAAMC,aAAaH,GAAYC,GAAUO,SAAU,IAEhD,CACHF,gBAAiBA,EACjBqB,sBAAuBzB,EAAA,GAAMC,aAC7BJ,WAAYA,EAAW6B,KAAKC,KAAM7B,GAClCK,WAAYA,EAAWuB,KAAKC,KAAMvB,EAAiBN,GACnDU,eAAgBA,EAAekB,KAAKC,KAAM7B,GAC1CW,eAAgBA,EAAeiB,KAAKC,KAAMvB,EAAiBN,GAEnE,ECbA,QALA,SAAciB,EAASa,GACnB,MAAMC,EAAmB,EAAoBd,GAC7Ca,EAAGC,GACHA,EAAiBpB,gBACrB,C,wECoCA,QAtCA,SAAoBoB,EAAkBC,EAAeC,EAAWC,EAAQC,EAAQC,EAAU,CAAC,EAAGC,EAAS,IACnG,MAAM,MAAEC,EAAK,KAAEC,EAAI,MAAEC,EAAK,UAAEC,EAAS,SAAEC,EAAQ,YAAEC,EAAW,cAAEC,GAAmBhC,OAAOiC,OAAO,CAC3FP,MAAO,iBACPC,KAAM,cACNC,MAAO,IACPE,cAAUI,EACVL,eAAWK,EACXF,cAAe,EACfD,YAAa,GACdP,GACGW,EAAcN,GAAaD,EAE3BQ,GAAc,OAAShB,EAAe,SAAUC,GAChDgB,EAAwBlB,EAAiBhC,WAAWiD,GACpDE,EAAa,CACfC,GAAI,GAAGjB,EAAO,KACdkB,GAAI,GAAGlB,EAAO,KACdmB,EAAG,GAAGlB,IACNmB,OAAQhB,EACRC,OACA,eAAgBQ,EAChB,mBAAoBL,EACpB,eAAgBC,EAChB,iBAAkBC,GAEtB,GAAIK,GACA,OAAyBC,EAAYD,GACrClB,EAAiBrB,eAAesC,OAE/B,CACD,MAAMO,EAAmBC,SAASC,gBAnBxB,6BAmB+C,UAC1C,KAAXpB,GACAkB,EAAiBG,aAAa,UAAWrB,IAE7C,OAAwBa,EAAYK,GACpCxB,EAAiB1B,WAAWkD,EAAkBP,EAClD,CACJ,C,kDClCA,QALA,SAAqBjB,EAAkBC,EAAe2B,EAAgBC,EAAcxB,EAAU,CAAC,GAC3FwB,EAAa9C,QAAQ,CAAC+C,EAAQC,MAC1B,OAAW/B,EAAkBC,EAAe2B,EAAgBE,EAAQzB,EAAS0B,IAErF,C,uECoBA,QAvBA,SAAkB/B,EAAkBC,EAAe+B,EAASC,EAAwBC,EAAUC,EAAa9B,EAAU,CAAC,GAClH,MAAM+B,EAAQH,EAAuBI,OAAS,GACxC,EAAAC,EAAA,GAAiBL,EAAwBC,GACzCA,EACAK,EASV,SAA4BJ,GACxB,MAAQK,EAAGC,EAAMC,EAAGC,EAAG,OAAEC,EAAM,MAAEnC,GAAU0B,EACrCU,EAAYpC,EAAQ,EACpBqC,EAAaF,EAAS,EAK5B,MAAO,CAJW,CAACH,EAAOI,EAAWF,GAClB,CAACF,EAAME,EAAMG,GACX,CAACL,EAAOI,EAAWF,EAAMC,GAC1B,CAACH,EAAOhC,EAAOkC,EAAMG,GAE7C,CAlB8BC,CAAmBZ,GACvCa,GAAM,EAAAV,EAAA,GAAiBC,EAAmBH,GAC1Ca,EAAgBpE,OAAOiC,OAAO,CAChCP,MAAO,mBACPG,UAAW,IACXC,SAAU,OACXN,IACH,EAAA6C,EAAA,GAASlD,EAAkBC,EAAe,QAAQ+B,IAAWI,EAAOY,EAAKC,EAC7E,ECAA,QAZA,SAA2BjD,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiBpB,EAAwBqB,EAASjD,EAAU,CAAC,GAC5I,MAAM4C,EAAgBpE,OAAOiC,OAAO,CAChCyC,aAAc,IACdC,UAAW,CACPhB,GAAG,EACHE,GAAG,IAERrC,GACGoD,GAAoB,EAAAC,EAAA,GAAY1D,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiBJ,GAE/G,OADA,EAASjD,EAAkBC,EAAekD,EAAYlB,EAAwBoB,EAAiBI,EAAmBR,GAC3GQ,CACX,C,2DCXe,SAASE,EAAS3D,EAAkBC,EAAe2D,EAAcxB,EAAOY,EAAK3C,EAAU,CAAC,EAAGC,EAAS,IAC/G,MAAMuD,EAAU,CAACzB,EAAM,GAAIA,EAAM,IAC3B0B,EAAW,CAACd,EAAI,GAAIZ,EAAM,IAC1B2B,EAAa,CAAC3B,EAAM,GAAIY,EAAI,IAC5BgB,EAAc,CAAChB,EAAI,GAAIA,EAAI,KACjC,OAAsBhD,EAAkBC,EAAe2D,EAAc,CAACC,EAASC,EAAUC,EAAYC,GAAc3D,EAASC,EAChI,C,mFCqNA,MAAM2D,EAAoB,IAzN1B,MACI,WAAAC,GACIpE,KAAKqE,OAAS,CACVC,OAAQ,CAAC,EACTC,cAAe,CAAC,EAChBC,eAAgB,CAAC,EAEzB,CACA,QAAAC,CAASC,EAAWC,GAChB,MAAM,WAAEpF,EAAU,eAAEqF,EAAc,KAAEC,EAAI,aAAEC,GAAiBJ,EACrDK,EAAgB/E,KAAKgF,SAASN,GACpC,IAAIO,EAaJ,GALIA,EAPC1F,GAAeqF,EAOA5E,KAAKkF,kCAAkC,IAChDH,KACAJ,GACJE,GATa,IACTE,KACAJ,IASNE,EACD,MAAM,IAAIM,MAAM,mCAEpB,GAAI5F,EAAY,CACPS,KAAKqE,OAAOG,eAAejF,KAC5BS,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,6BAA6B,EAC7BC,gBAAiB,CAAC,IAG1B,MAAMA,EAAkBrF,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAC/D,GAAIT,EAAgB,CACXS,EAAgBT,KACjBS,EAAgBT,GAAkB,CAAC,GAElCS,EAAgBT,GAAgBC,KACjCQ,EAAgBT,GAAgBC,GAAQ,CAAC,GAE7C,MAAMS,EAAYD,EAAgBT,GAAgBC,QAC7B5D,IAAjB6D,GACKQ,EAAUC,aACXD,EAAUC,WAAa,CAAC,GAE5BD,EAAUC,WAAWT,GAAgBG,GAGrCK,EAAUE,YAAcP,CAEhC,KACK,CACD,MAAMQ,EAAwB,uBACzBJ,EAAgBI,KACjBJ,EAAgBI,GAAyB,CAAC,GAEzCJ,EAAgBI,GAAuBZ,KACxCQ,EAAgBI,GAAuBZ,GAAQ,CAAC,GAEpDQ,EAAgBI,GAAuBZ,GAAMW,YACzCP,CACR,CACJ,MACK,GAAIL,EAAgB,CAChB5E,KAAKqE,OAAOE,cAAcK,KAC3B5E,KAAKqE,OAAOE,cAAcK,GAAkB,CAAC,GAE5C5E,KAAKqE,OAAOE,cAAcK,GAAgBC,KAC3C7E,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAQ,CAAC,GAEvD,MAAMa,EAAY1F,KAAKqE,OAAOE,cAAcK,GAAgBC,QACvC5D,IAAjB6D,GACKY,EAAUH,aACXG,EAAUH,WAAa,CAAC,GAE5BG,EAAUH,WAAWT,GAAgBG,GAGrCS,EAAUF,YAAcP,CAEhC,MAEIjF,KAAKqE,OAAOC,OAAOO,GAAQI,CAEnC,CACA,iCAAAC,CAAkCP,EAAQE,GACtC,MAAMc,EAAkB,IAAKhB,GAC7B,GAAIE,IAAS,8BAAkCe,SAAU,CACrD,MAAMC,EAAiBF,EACvBE,EAAeC,wBAA0BD,EAAeE,cACxDF,EAAeG,uBAAyBH,EAAeI,aACvDJ,EAAeK,qBAAuBL,EAAeM,WACrDN,EAAeO,oBAAsBP,EAAeQ,UACpDR,EAAeS,yBAA2BT,EAAeU,cAC7D,MACK,GAAI1B,IAAS,8BAAkC2B,QAAS,CACzD,MAAMC,EAAgBd,EACtBc,EAAcT,uBAAyBS,EAAcR,aACrDQ,EAAcH,yBAA2BG,EAAcF,eACvDE,EAAcC,sBAAwBD,EAAcE,YACpDF,EAAcX,wBAA0BW,EAAcV,cACtDU,EAAcP,qBAAuBO,EAAcN,WACnDM,EAAcL,oBAAsBK,EAAcJ,SACtD,CACA,OAAOV,CACX,CACA,QAAAX,CAASN,GACL,MAAM,WAAEnF,EAAU,eAAEqF,EAAc,KAAEC,EAAI,aAAEC,GAAiBJ,EAC3D,IAAIkC,EAAgB5G,KAAK6G,gBAAgBhC,GACrCO,GAA8B,EAoBlC,GAnBIpF,KAAKqE,OAAOC,OAAOO,KACnB+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOC,OAAOO,KAG1B7E,KAAKqE,OAAOE,cAAcK,KAAkBC,KAC5C+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMW,kBAElCvE,IAAjB6D,GACA9E,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMU,aAAaT,KAC7D8B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMU,WAAWT,MAItEvF,GAAcS,KAAKqE,OAAOG,eAAejF,GAAa,CACtD6F,EACIpF,KAAKqE,OAAOG,eAAejF,GAAY6F,4BAC3C,MAAM0B,EAAsB,uBACxB9G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgByB,KAAuBjC,KAC9E+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgByB,GAAqBjC,GAAMW,cAGzFZ,GACA5E,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,KAAkBC,KACzE+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMW,kBAE/DvE,IAAjB6D,GACA9E,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMU,aAAaT,KAC1F8B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMU,WAAWT,KAI3G,CACA,OAAO8B,CACX,CACA,8BAAAG,CAA+BxH,GAC3B,OAAOS,KAAKqE,OAAOG,eAAejF,IAAa6F,2BACnD,CACA,8BAAA4B,CAA+BzH,EAAY6F,GAClCpF,KAAKqE,OAAOG,eAAejF,KAC5BS,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,6BAA6B,EAC7BC,gBAAiB,CAAC,IAG1BrF,KAAKqE,OAAOG,eAAejF,GAAY6F,4BACnCA,CACR,CACA,eAAAyB,CAAgBhC,GACZ,OAAQA,GACJ,KAAK,8BAAkCe,SACnC,OAAO,SACX,KAAK,8BAAkCY,QACnC,OAAO,SACX,KAAK,8BAAkCS,QACnC,MAAO,CAAC,EACZ,QACI,MAAM,IAAI9B,MAAM,gCAAgCN,KAE5D,CACA,sBAAAqC,CAAuBtC,GACf5E,KAAKqE,OAAOE,cAAcK,WACnB5E,KAAKqE,OAAOE,cAAcK,EAEzC,CACA,0BAAAuC,GACInH,KAAKqE,OAAOE,cAAgB,CAAC,CACjC,CACA,kBAAA6C,CAAmB7H,GACXS,KAAKqE,OAAOG,eAAejF,WACpBS,KAAKqE,OAAOG,eAAejF,EAE1C,CACA,sBAAA8H,GACI,IAAK,MAAM9H,KAAcS,KAAKqE,OAAOG,eAAgB,CACjD,MACMY,EADgBpF,KAAKqE,OAAOG,eAAejF,GACC6F,4BAClDpF,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,8BACAC,gBAAiB,CAAC,EAE1B,CACJ,CACA,kBAAAiC,GACItH,KAAKmH,6BACLnH,KAAKqH,wBACT,CACA,cAAAE,CAAe7C,GACX,MAAM,KAAEG,GAASH,EACX8C,EAAQxH,KAAKgF,SAASN,GACtB+C,EAAezH,KAAK6G,gBAAgBhC,GAC1C,OAAQ,EAAA6C,UAAA,UAAoBF,EAAOC,EACvC,E,wECxNG,SAASE,EAAgC/C,EAAgBgD,EAAqB9C,GACjF,MAAM+C,EAAc,CAChBjD,iBACAgD,sBACA9C,iBAEJ,QAAqBF,IACrB,IAAAkD,cAAa,EAAAC,YAAa,EAAAC,OAAOC,2BAA4BJ,EACjE,C,kDCVO,SAASK,EAAsB3I,GAElC,OADiC,KACD2I,sBAAsB3I,EAC1D,C,kDCHO,SAAS4I,EAAwC5I,EAAYmF,GAEhE,OADiC,KACDyD,wCAAwC5I,EAAYmF,EACxF,C,6DC2BA,QA7BA,UAAuC,eAAEE,EAAc,KAAEC,EAAI,KAAEuD,IAC3D,MAAMC,GAAe,OAAgBzD,GACrC,IAAKyD,EACD,MAAM,IAAIlD,MAAM,gBAAgBP,eAKpC,OAHIyD,EAAaC,mBAAmBzD,IAChC0D,QAAQC,KAAK,+BAA+B3D,qCAAwCD,sBAEhFC,GACJ,KAAK,IAA4Be,SAMjC,KAAK,IAA4BY,QAKjC,KAAK,IAA4BS,QACzBmB,IACAC,EAAaC,mBAAmBzD,GAAQuD,GAE5C,MACJ,QACI,MAAM,IAAIjD,MAAM,+BAA+BN,KAE3D,C,6DCbA,QAfA,SAAiCtF,EAAYC,GACpCA,IACDA,GAAoB,IAAAiJ,uBAAsBC,KAAMC,GAAOA,EAAGC,eAAeF,KAAMG,GAAOA,EAAGC,KAAOvJ,KAAcuJ,IAElH,MAAMC,EAAyB,KAAMC,WAAWC,OAAQC,GAAOA,EAAGC,cAAcC,KAAMP,GAAOA,EAAGrJ,oBAAsBA,KAChHqJ,EAAGtJ,YAAcsJ,EAAGtJ,aAAeA,KACzC,GAAKwJ,EAAuBxG,OAA5B,CAGA,GAAIwG,EAAuBxG,OAAS,EAChC,MAAM,IAAI4C,MAAM,qDAAqD3F,qBAAqCD,oFAG9G,OAAOwJ,EAAuB,EAL9B,CAMJ,C,wECbA,MAAMM,UAA8C,WACvCrJ,KAAKsJ,SAAW,uCAAyC,CAClE,WAAAlF,CAAYmF,GAORC,MANqB,EAAA9B,UAAA,UAAoB,CACrC+B,cAAe,CACXC,gBAAgB,EAChBC,mBAAmB,IAExBJ,GAEP,CACA,yBAAAK,GACI,OAAO,CACX,CACA,wBAAAC,CAAyBC,GACrB,MAAMC,EAAaD,EAAcC,YAC3B,YAAEC,GAAgBD,EAClBE,EAAeT,MAAMK,yBAAyBC,GACpD,GAAIE,EAAa,CACb,MAAM,eAAEpF,GAAmBmF,EAAW3B,KAAKC,cAC3C,IAAAV,iCAAgC/C,EACpC,CACA,OAAOqF,CACX,EAEJ,S,oTCFA,MAAM,sBAAEC,GAA0B,EAAAC,UAC5B,QAAEC,GAAY,EAAAC,UACdC,EAAqB,EAAIF,EAC/B,MAAMG,UAA8B,WACvBvK,KAAKsJ,SAAW,mBAAqB,CAC9C,WAAAlF,CAAYmF,EAAY,CAAC,EAAGiB,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrChB,cAAe,CACXiB,gBAAgB,EAChBC,QAAQ,EACRC,2BAA2B,EAC3BC,+BAAgC,EAAAC,iBAAiBC,MACjDC,+BAAgC,CAC5BC,SAAS,EACT3K,OAAQ,GAEZqJ,mBAAmB,EACnBuB,sBAAuB,GACvBC,iCAAkC,EAClCC,eAAe,EACfC,mBAAoB,EACpBC,UAAW,CACPC,aAAa,EACbC,cAAc,EACdC,0BAA2B,GAC3BC,2BAA4B,IAEhCC,cAAe,CACXV,SAAS,EACTW,wBAAyB,MAE7BC,SAAU,CACNZ,SAAS,EACTa,QAAS,IAEbC,6BAA6B,EAC7BrC,gBAAgB,EAChBsC,aAAcC,EACdC,gBAAiB,EAAAC,wBAGrB3C,MAAMD,EAAWiB,GACjBxK,KAAKoM,WAAY,EACjBpM,KAAKqM,iBAAkB,EACvBrM,KAAKsM,eAAgB,EACrBtM,KAAKuM,iBAAoBC,IACrB,MAAM3E,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACdkC,EAAa/J,KAAK0M,iBAAiBF,GACzCxM,KAAK2M,cAAc5C,EAAY3K,GAC/B,MAAMwN,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eAIzE,OAHA9M,KAAK+M,aAAaP,EAAKzC,EAAY6C,GACnCJ,EAAIQ,kBACJ,OAAsCJ,GAC/B7C,GAEX/J,KAAKiN,uBAAyB,CAACT,EAAKzC,EAAY/H,KAC5C,MAAM6F,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACd+E,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAKkN,2BAA2BV,EAAKzC,EAAY6C,EAAqB5K,IAE1EhC,KAAKmN,qBAAuB,CAACX,EAAKzC,KAC9B,MAAMlC,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACd+E,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACrE/C,EAAW3B,KAAKgF,QAAQC,OACxBrN,KAAKsN,0BAA0Bd,EAAKzC,EAAY6C,GAGhD5M,KAAKuN,wBAAwBf,EAAKzC,EAAY6C,GAElDJ,EAAIQ,kBAERhN,KAAKwN,gBAAkB,CAACpO,EAAS2K,EAAY0D,EAAcC,KACvD,MAAMrO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,GACb8K,SAAUyD,GAAW7D,EAAW3B,KAAKgF,QAC7C,IAAIS,EAAgBF,EAASG,cAAcF,EAAO,IAClD,IAAK,IAAI3L,EAAI,EAAGA,EAAI2L,EAAOrL,OAAQN,IAAK,CACpC,MAAM8L,EAAKF,EACLG,EAAKL,EAASG,cAAcF,EAAO3L,IAEzC,GADmBiI,EAAsBuD,EAAcM,EAAIC,EAAIN,GAE3D,OAAO,EAEXG,EAAgBG,CACpB,CACA,IAAKjE,EAAW3B,KAAKgF,QAAQC,OACzB,OAAO,EAEX,MAAMY,EAASN,EAASG,cAAcF,EAAO,IACvCM,EAAOP,EAASG,cAAcF,EAAOA,EAAOrL,OAAS,IAC3D,OAAO2H,EAAsBuD,EAAcQ,EAAQC,EAAMR,IAE7D1N,KAAKmO,OAAU/O,IACX,MAAMgN,EAAYpM,KAAKoM,UACjBE,EAAgBtM,KAAKsM,cACrBD,EAAkBrM,KAAKqM,gBACzBD,EACApM,KAAKoO,cAAchP,GAEdkN,EACLtM,KAAKqO,sBAAsBjP,GAEtBiN,GACLrM,KAAKsO,wBAAwBlP,IAGrCY,KAAKuO,sBAAwB,CAACxE,EAAY4D,EAAUa,EAAiBnP,KACjE,MAAM,KAAE+I,GAAS2B,GACX,YAAE0E,GAAgBrG,GAChB+B,SAAUyD,EAAM,OAAEP,GAAWjF,EAAKgF,QACpCsB,EAAY3P,OAAOC,KAAKyP,GAC9B,IAAK,IAAIxM,EAAI,EAAGA,EAAIyM,EAAUnM,OAAQN,IAAK,CACvC,MAAM0M,EAAWD,EAAUzM,GACrB2M,EAAQ5O,KAAK6O,mBAAmBF,GACtC,IAAKC,EACD,SAEJ,MAAM,UAAEE,EAAS,SAAEC,GAAaH,EAC1BI,EAAoBpB,EAAOqB,IAAKC,GAAMvB,EAASG,cAAcoB,IAC7DC,EAAsB,CACxBC,aAAa,OAAoBzB,EAAUgB,GAC3CU,YAAarP,KAAKqP,YAAY1B,EAAUgB,EAAU5E,EAAWgF,SAASO,oBAEpEC,GAAe,OAAmBR,EAASS,SAAUzF,EAAWgF,SAASO,kBAAmBH,GAC5FM,GAAkB,QAAiCb,EAAO,KAC5D,MAAMzE,EAAW/B,EAAKgF,QAAQjD,SACxBuF,EAAYvF,EAAS5H,OACrBoN,EAAoB,IAAIC,MAAMF,GACpC,IAAK,IAAIzN,EAAI,EAAGA,EAAIyN,EAAWzN,IAC3B0N,EAAkB1N,GAAK0L,EAASG,cAAc3D,EAASlI,IAE3D,MAAQ4N,KAAMC,EAAYC,KAAMC,EAAYC,KAAMC,EAAYC,KAAMC,GAAgB,mBAAsBT,GACpGU,EAAiB1C,EAAS2C,cAAc,CAACJ,EAAYE,IACrDG,EAAiB,kCAA8BzB,EAAWuB,GAC1DG,EAAqB7C,EAAS2C,cAAc,CAC9CR,EACAE,IAGJ,MAAO,CAACO,EADmB,kCAA8BzB,EAAW0B,MAGlEC,EAAczB,EAAkB,GAChC0B,EAAqB/C,EAAS2C,cAAcG,GAC5CE,EAAchD,EAAS2C,cAAc,CACvCG,EAAY,GAAK,EACjBA,EAAY,KAEVG,EAAcjD,EAAS2C,cAAc,CACvCG,EAAY,GACZA,EAAY,GAAK,IAEfI,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,GAC/CvD,EACArN,KAAK+Q,wBAAwB,CACzBpC,WACAhB,WACAqB,oBACApB,SACAkB,YACAC,WACAN,cACAc,eACAE,kBACAoB,WACAC,aAIJ9Q,KAAKgR,sBAAsB,CACvBjC,WACAC,oBACAL,WACAF,cACAc,eACAE,kBACAoB,WACAC,YAGZ,CACA,MAAM9G,EAAcD,EAAWC,YAK/B,OAJAD,EAAWC,aAAc,EACrBA,IACA,IAAAiH,2BAA0BlH,EAAY1K,EAAesO,SAASvO,QAAS,EAAA8R,YAAYC,cAEhF1C,GAEXzO,KAAKoR,aAAe,CAACrH,EAAY4D,EAAUtO,EAAgBa,KACvD,MAAM,KAAEkI,GAAS2B,EACX4E,EAAW3O,KAAKqR,YAAY1D,GAC5B2D,EAAiB,CACnBC,YAAavR,KAAKuR,YAClBjI,SAAUtJ,KAAK8M,cACfvN,WAAYF,EAAesO,SAAS7E,GACpC3I,cAAe4J,EAAW5J,eAExBI,EAAUP,KAAKwR,sBAAsBF,EAAgBvH,GAC3D,IAAKxJ,EAAQkR,WACT,OAEJ,MAAMnO,EAAYtD,KAAKyJ,cAAcuC,aAAa5D,EAAMuG,GACxD,IAAKrL,GAAkC,IAArBA,EAAUf,OACxB,OAEJ,MAAMyM,EAAoB5G,EAAKgF,QAAQjD,SAAS8E,IAAKC,GAAMvB,EAASG,cAAcoB,IAClF,IAAK9G,EAAKsJ,QAAQlO,QAAQmO,SAAU,CAChC,MAAMC,GAAsB,IAAAC,wBAAuB7C,GACnD5G,EAAKsJ,QAAQlO,QAAQsO,cACjBnE,EAAS2C,cAAcsB,EAC/B,CACA,MAAMrO,EAAkBoK,EAASG,cAAc1F,EAAKsJ,QAAQlO,QAAQsO,eAE9DzP,GAAc,IAAA0P,mBAAkB7R,EAAkB6J,EAAW5J,eAAiB,GADjE,IACiFmD,EAAWC,EAAiByL,EAAmB,CAAC,EAAGzO,IAC/ImC,EAAGC,EAAMC,EAAGC,EAAG,MAAElC,EAAK,OAAEmC,GAAWT,EAC3C+F,EAAKsJ,QAAQlO,QAAQwO,iBAAmB,CACpCjO,QAAS4J,EAAS2C,cAAc,CAAC3N,EAAME,IACvCmB,SAAU2J,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,IAChDoB,WAAY0J,EAAS2C,cAAc,CAAC3N,EAAME,EAAMC,IAChDoB,YAAayJ,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,EAAMC,OAGjE,OAAiB9C,OACjB,OAAuBA,OACvB,OAA8BA,OAC9B,OAA4BA,OAC5B,OAA+BA,OAC/B,OAAsBA,MACtBA,KAAKiS,gCAAiC,OAASjS,KAAKuO,sBAAuB,IAAK,CAAE2D,UAAU,GAChG,CACA,uCAAAC,CAAwC/S,EAASgT,GAC7C,IAAKA,IAAgBA,EAAY7P,OAC7B,OAEJ,MAAMlD,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACrB,IAAIgT,EACJ,GAAI1E,aAAoB,EAAA2E,eAAgB,CACpC,MAAMC,EAAS5E,EAAS6E,aAClB,yBAAEC,GAA6B,iDAA6C9E,EAAU4E,GAC5FF,EAAuBrS,KAAK0S,6BAA6BN,EAAaG,EAAQE,EAClF,MAEIJ,GAAuB,IAAAM,6BAA4BhF,EAAUyE,GAEjE,OAAOC,CACX,CACA,4BAAAK,CAA6BN,EAAaG,EAAQE,GAC9C,MAAM,gBAAEG,GAAoBL,EACtBM,EAAiCT,EAAYnJ,OAAQ6J,IACvD,IAAIC,EAA4BD,EAAG/D,SAAS6D,gBAC5C,IAAKE,EAAG/D,SAASO,oBACZyD,GACDD,EAAG/D,SAASiE,oBAAqB,CACjC,IAAK,MAAMC,KAASH,EAAG1K,KAAKgF,QAAQjD,SAAU,CAC1C,MAAM+I,EAAS,SAAS,cAAeD,EAAOV,EAAOY,YAC/CC,EAAa,SAASF,EAAQX,EAAOK,iBAC3C,IAAK,oBAAgBQ,EAAY,GAC7B,OAAO,CAEf,CAGA,OAFAN,EAAG/D,SAAS6D,gBAAkBL,EAAOK,gBACrCE,EAAG/D,SAASsE,iBAAmBd,EAAOY,YAC/B,CACX,CACA,IAAKJ,EAA2B,CAC5B,MAAM,kBAAEzD,GAAsBwD,EAAG/D,UAC3B,wBAAEuE,GAA4B,EAAAC,SAAA,IAAa,mBAAoBjE,GAC/DkE,EAAe,gBAAgBF,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GG,EAAe,gBAAgBH,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHP,EAA4B,cAC5B,WAAWA,EAA2BS,EAAcC,GACpDX,EAAG/D,SAAS6D,gBAAkBG,CAClC,CACA,MAAMW,EAAaC,KAAKC,IAAI,SAAShB,EAAiBG,IAClDzI,EACJ,OAAOyI,GAA6BW,IAExC,IAAKb,EAA+BtQ,OAChC,MAAO,GAEX,MAAMsR,EAA+BpB,EAA2B,GAC1D,WAAEU,GAAeZ,EACjBuB,EAAyB,GAC/B,IAAK,MAAM/J,KAAc8I,EAAgC,CACrD,MACMI,EADOlJ,EAAW3B,KACLgF,QAAQjD,SAAS,GACpC,IAAKJ,EAAWgK,UACZ,SAEJ,MAAMC,EAAM,cACZ,SAASA,EAAKb,EAAYF,GAC1B,MAAMgB,EAAM,SAASD,EAAKpB,GACtBe,KAAKC,IAAIK,GAAOJ,GAChBC,EAAuBI,KAAKnK,EAEpC,CACA,OAAO+J,CACX,CACA,yBAAAlK,GACI,OAAO,CACX,CACA,gBAAA8C,CAAiBF,GACb,MAAM2H,EAAW3H,EAAIC,OAAO2H,cAAcC,MACpCC,EAAoB9K,MAAMkD,iBAAiBF,GAcjD,OAVmB,sBAAkB8H,EAAmB,CACpDlM,KAAM,CACFgF,QAAS,CACLjD,SAAU,CAAC,IAAIgK,KAEnBI,MAAO,GACP9F,YAAa,CAAC,GAElB7C,wBAX6B7B,IAC7BA,EAAW3B,KAAKsJ,QAAQ9D,OAAOrL,OAAS,IAahD,CACA,kBAAAiS,CAAmBC,GACf,OAAOjL,MAAMgL,mBAAmBC,EACpC,CACA,wBAAA5K,CAAyBC,GACrB,MAAM,eAAEzK,EAAc,SAAEsP,EAAQ,iBAAEzO,GAAqB4J,EACjDC,EAAaD,EAAcC,WACjC,IAAI2K,GAAe,EACnB,MAAM,SAAE/G,EAAQ,gBAAEa,GAAoBnP,EAChC+M,EAAYpM,KAAKoM,UACjBE,EAAgBtM,KAAKsM,cACrBD,EAAkBrM,KAAKqM,gBAC7B,GAAMD,GAAaE,GAAiBD,EAS/B,CACD,MAAMsI,EAAsB3U,KAAK4U,WAAW7K,WAAW5J,cACvD,GAAI4J,EAAW5J,gBAAkBwU,EAC7B,GAAIvI,EACApM,KAAK6U,wBAAwBxV,EAAgBa,EAAkB6J,QAE9D,GAAIsC,EACLrM,KAAK8U,+BAA+BzV,EAAgBa,EAAkB6J,OAErE,KAAIuC,EAIL,MAAM,IAAInH,MAAM,WAAWnF,KAAK8M,4CAHhC9M,KAAK+U,6BAA6B1V,EAAgBa,EAAkB6J,EAIxE,MAGI/J,KAAKyJ,cAAcsC,6BACyB,IAA5ChC,EAAW3B,KAAKgF,QAAQjD,SAAS5H,OACjCvC,KAAKgV,6BAA6B3V,EAAgBa,EAAkB6J,GAGpE/J,KAAKiV,cAAc5V,EAAgBa,EAAkB6J,GAG7D2K,GAAe,CACnB,MAlCQ1U,KAAKyJ,cAAcsC,6BACyB,IAA5ChC,EAAW3B,KAAKgF,QAAQjD,SAAS5H,OACjCvC,KAAKgV,6BAA6B3V,EAAgBa,EAAkB6J,GAGpE/J,KAAKiV,cAAc5V,EAAgBa,EAAkB6J,GA8B7D,GAAK/J,KAAKyJ,cAAcC,eAKxB,OAFA1J,KAAKkV,wBAAwBnL,EAAY4E,EAAUhB,EAAUa,EAAiBnP,GAC9EW,KAAKoR,aAAarH,EAAY4D,EAAUtO,EAAgBa,GACjDwU,CACX,CACA,uBAAAQ,CAAwBnL,EAAY4E,EAAUhB,EAAUa,EAAiBnP,GACrE,MAAMsV,EAAsB3U,KAAK4U,YAAY7K,WAAW5J,cACxD,IAAI4J,EAAW5J,gBAAkBwU,GAC5B3U,KAAK4U,YAAYO,iBAGjBnV,KAAK4U,YAAYO,cAAe,CACjC,MAAM,KAAE/M,GAAS2B,EACZ3B,EAAKqG,YAAYE,IAAWyG,KAYxBrL,EAAWC,aAChBhK,KAAKiS,+BAA+BlI,EAAY4D,EAAUa,EAAiBnP,IAZ3E+I,EAAKqG,YAAYE,GAAY,CACzBa,SAAU,KACV6F,KAAM,KACNC,IAAK,KACLC,KAAM,KACNC,OAAQ,KACRC,SAAU,KACVL,KAAM,MAEVpV,KAAKuO,sBAAsBxE,EAAY4D,EAAUa,EAAiBnP,GAK1E,CACJ,CACA,uBAAA0R,EAAwB,SAAEpD,EAAQ,OAAEC,EAAM,UAAEkB,EAAS,SAAEC,EAAQ,YAAEN,EAAW,SAAEE,EAAQ,aAAEY,EAAY,kBAAEP,EAAiB,gBAAES,EAAe,SAAEoB,EAAQ,SAAEC,IAChJ,MAAM,MAAE4E,EAAK,SAAED,EAAQ,KAAEL,GAAS3F,GAC5B,aAAEkG,GAAiBhI,EAASiI,eAC5BC,EAAgB,kCAA8B/G,EAAWlB,EAAO,IACtEiI,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5C,IAAIE,EAAOF,EAAc,GACrBG,EAAOH,EAAc,GACrBI,EAAOJ,EAAc,GACrBK,EAAOL,EAAc,GACrBM,EAAON,EAAc,GACrBO,EAAOP,EAAc,GACzB,IAAK,IAAIQ,EAAI,EAAGA,EAAIzI,EAAOrL,OAAQ8T,IAAK,CACpC,MAAMR,EAAgB,kCAA8B/G,EAAWlB,EAAOyI,IACtER,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CE,EAAOpC,KAAK2C,IAAIP,EAAMF,EAAc,IACpCG,EAAOrC,KAAK2B,IAAIU,EAAMH,EAAc,IACpCI,EAAOtC,KAAK2C,IAAIL,EAAMJ,EAAc,IACpCK,EAAOvC,KAAK2B,IAAIY,EAAML,EAAc,IACpCM,EAAOxC,KAAK2C,IAAIH,EAAMN,EAAc,IACpCO,EAAOzC,KAAK2B,IAAIc,EAAMP,EAAc,GACxC,CACA,MAAMU,EAAiB,kCAA8BzH,EAAWlB,EAAO,IACvE2I,EAAe,GAAK5C,KAAKmC,MAAMS,EAAe,IAC9CA,EAAe,GAAK5C,KAAKmC,MAAMS,EAAe,IAC9CA,EAAe,GAAK5C,KAAKmC,MAAMS,EAAe,IAC9C,IAAIlB,EAAO,EAAAlL,SAAA,QAAiB6E,GAAqB0G,EAAQA,EACzDL,GAAQxE,EAAWC,EACnB,IAAI0F,GAAY,OAAmBxH,EAAmB3B,QAAUqI,EAChEc,GAAa7C,KAAK8C,KAAK9C,KAAK+C,IAAI7F,EAAU,GAAK8C,KAAK+C,IAAI5F,EAAU,IAClE,MAAM6F,EAAS,KAAQX,EAAOD,GACxBa,EAAS,KAAQV,EAAOD,GACxBY,EAAS,KAAQT,EAAOD,GAC9BJ,EAAOpC,KAAKmC,MAAMC,EAAOY,GACzBX,EAAOrC,KAAKmD,KAAKd,EAAOW,GACxBV,EAAOtC,KAAKmC,MAAMG,EAAOW,GACzBV,EAAOvC,KAAKmD,KAAKZ,EAAOU,GACxBT,EAAOxC,KAAKmC,MAAMK,EAAOU,GACzBT,EAAOzC,KAAKmD,KAAKV,EAAOS,GACxB,MAAME,EAAY,CACd,CAAChB,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAELY,EAAclI,EAAUmI,aAAa,CAACjB,EAAME,EAAME,IAClDc,EAAevJ,EAASG,cAAckJ,GAC5C,IAGIG,EAHAC,EAAS,EACTC,EAAgB,GAChBC,EAAsB,EAEtB3B,IACAwB,EAAgBxB,EAAa1W,QAAQe,KAAKyJ,cAAcyC,gBAAgBqL,cAAe,CACnFzI,YACA0I,WAAY,CAACC,EAAUC,KACnB,IAAIC,GAAS,EACb,MAAM1E,EAAQtF,EAASG,cAAc2J,GAsBrC,OArBIxE,EAAM,IAAMmE,IACZE,EAAsB,EACtBF,EAASnE,EAAM,GACfoE,GAAgB,IAAAO,wCAAuC5I,EAAmBiE,EAAO,CAACiE,EAAa,GAAIjE,EAAM,KACzGoE,EAAcQ,KACH,SAAUC,EAAGC,GAChB,OAAOD,EAMZ,KANyBC,EAMzB,GALW,EACAD,EAIX,GAJsBC,EAItB,IAHgB,EACD,CACd,IAGJV,EAAc9U,QAAU0Q,EAAM,GAAKoE,EAAc,GAAG,KACpDA,EAAcW,QACdV,KAEAA,EAAsB,GAAM,IAC5BK,GAAS,GAENA,GAEXZ,YACAkB,aAAcjY,KAAKyJ,cAAciB,kBAGzC,MAAMwN,EAAQlY,KAAKyJ,cAAcyC,gBAAgBiM,gBACjD1J,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnB6F,OACAmB,YACAjB,KAAM2C,EAAM3C,MAAM6C,MAClB9C,IAAK4C,EAAM5C,KAAK8C,MAChB9B,IAAK4B,EAAM5B,KAAK8B,MAChB5C,OAAQ0C,EAAM1C,QAAQ4C,MACtBC,WAAYH,EAAMI,MAClBnB,cAAeA,EACf1B,WACAlG,eACA6F,OAER,CACA,qBAAApE,EAAsB,SAAErC,EAAQ,SAAEI,EAAQ,kBAAEC,EAAiB,YAAEP,EAAW,aAAEc,EAAY,gBAAEE,EAAe,SAAEoB,EAAQ,SAAEC,IACjH,MAAM,MAAE4E,EAAK,KAAEN,GAAS3F,EACxB,IAAIlN,GAAS,OAAmByM,EAAmB3B,QAAUqI,EAC7DnT,GAAUoR,KAAK8C,KAAK9C,KAAK+C,IAAI7F,EAAU,GAAK8C,KAAK+C,IAAI5F,EAAU,IAC/DrC,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnBjN,SACAgN,eACA6F,OAER,EAEJ,SAASnJ,EAAoB7D,EAAMuG,GAC/B,MAAM4J,EAAoBnQ,EAAKqG,YAAYE,IACrC,KAAE0G,EAAI,KAAEE,EAAI,OAAEC,EAAM,OAAEjT,EAAM,UAAEiU,EAAS,IAAElB,EAAG,IAAEgB,EAAG,YAAEkC,EAAW,KAAEpD,EAAI,SAAEK,EAAQ,aAAElG,GAAkBgJ,GAAqB,CAAC,EACxHjV,EAAY,GAClB,GAAI,qBAAiB+R,GAAO,CACxB,MAAMoD,EAAWD,EACX,8BACA,SAAS,wBAAoBnD,MAASI,IAC5CnS,EAAU4Q,KAAKuE,EACnB,CAmBA,OAlBI,qBAAiBlD,IACjBjS,EAAU4Q,KAAK,SAAS,wBAAoBqB,MAAShG,KAErD,qBAAiB+F,IACjBhS,EAAU4Q,KAAK,QAAQ,wBAAoBoB,MAAQ/F,KAEnD,qBAAiB+G,IACjBhT,EAAU4Q,KAAK,QAAQ,wBAAoBoC,MAAQ/G,KAEnD,qBAAiBiG,IACjBlS,EAAU4Q,KAAK,YAAY,wBAAoBsB,MAAWjG,KAE1D,qBAAiBiH,IACjBlT,EAAU4Q,KAAK,cAAc,wBAAoBsC,MAAcpB,KAE/D,qBAAiB7S,IACjBe,EAAU4Q,KAAK,GAAG,wBAAoB3R,MAAW6S,KAE9C9R,CACX,CACA,S,4PCxiBA,MAAM,sBAAEoV,GAA0B,YAClC,MAAMC,UAAyB,YAClB3Y,KAAKsJ,SAAW,cAAgB,CACzC,WAAAlF,CAAYmF,EAAY,CAAC,EAAGiB,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrChB,cAAe,CACXiB,gBAAgB,EAChBC,QAAQ,EACRC,2BAA2B,EAC3BlB,gBAAgB,EAChBsC,aAAcC,EACdC,gBAAiB,EAAAC,wBAGrB3C,MAAMD,EAAWiB,GACjBxK,KAAKuM,iBAAoBC,IACrB,MAAM3E,EAAc2E,EAAIC,QAClB,cAAE2H,EAAa,QAAEhV,GAAYyI,EAC7BsM,EAAWC,EAAcC,MACzBhV,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACrBW,KAAKoM,WAAY,EACjB,MAAMrC,EAAc/J,KAAgB,YAAE4Y,4BAA4BjL,EAAU,CACxEvF,KAAM,CACFsJ,QAAS,CACL9D,OAAQ,CACJ,IAAIuG,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER3Q,QAAS,CACLmO,UAAU,EACVG,cAAe,CAAC,EAAG,EAAG,GACtBE,iBAAkB,CACdjO,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,MAIhCuK,YAAa,CAAC,MAGtB,QAAc1E,EAAY3K,GAC1B,MAAMwN,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eAazE,OAZA9M,KAAK6Y,SAAW,CACZ9O,aACA6C,sBACAkM,YAAa,EACb3D,eAAe,EACf4D,eAAe,EACfpH,UAAU,GAEd3R,KAAKgZ,cAAc5Z,IACnB,IAAA6Z,mBAAkB7Z,GAClBoN,EAAIQ,kBACJ,OAAsCJ,GAC/B7C,GAEX/J,KAAKwN,gBAAkB,CAACpO,EAAS2K,EAAY0D,EAAcC,KACvD,MAAMrO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,GACf,KAAE+I,GAAS2B,GACX,OAAE6D,GAAWxF,EAAKsJ,QAClBwH,EAAevL,EAASG,cAAcF,EAAO,IAC7CuL,EAAexL,EAASG,cAAcF,EAAO,IAC7CwL,EAAOpZ,KAAKqZ,8BAA8B,CAC5CH,EACAC,IAEElG,EAAQ,CAACxF,EAAa,GAAIA,EAAa,KACvC,KAAE9K,EAAI,IAAEE,EAAG,MAAElC,EAAK,OAAEmC,GAAWsW,EAErC,OADwB,kBAA0B,CAACzW,EAAME,EAAKlC,EAAOmC,GAASmQ,IACvDvF,GAK3B1N,KAAKmN,qBAAuB,CAACX,EAAKzC,KAC9B,MAAMlC,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACpBkC,EAAWuP,aAAc,EACzB,MAAM1M,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAK6Y,SAAW,CACZ9O,aACA6C,sBACAuI,eAAe,GAEnBnV,KAAKuZ,gBAAgBna,IACrB,IAAA6Z,mBAAkB7Z,GAClB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEoP,GAAoBnP,GAC5B,OAAsCuN,GACtCJ,EAAIQ,kBAERhN,KAAKiN,uBAAyB,CAACT,EAAKzC,EAAY/H,KAC5C,MAAM6F,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,KAAEO,GAAS2B,EACjBA,EAAWuP,aAAc,EACzB,IACIR,EADA3D,GAAgB,EAEhBnT,EAAO8P,cACPqD,GAAgB,EAGhB2D,EAAc1Q,EAAKsJ,QAAQ9D,OAAO4L,UAAWtK,GAAMA,IAAMlN,GAE7D,MAAM4K,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAK6Y,SAAW,CACZ9O,aACA6C,sBACAkM,cACA3D,iBAEJnV,KAAKuZ,gBAAgBna,IACrB,IAAA6Z,mBAAkB7Z,GAClB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEoP,GAAoBnP,GAC5B,OAAsCuN,GACtCJ,EAAIQ,kBAERhN,KAAKyZ,aAAgBjN,IACjB,MAAM3E,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,WAAEkC,EAAU,oBAAE6C,EAAmB,cAAEmM,EAAa,SAAEpH,GAAa3R,KAAK6Y,UACpE,KAAEzQ,GAAS2B,EACbgP,IAAkBpH,IAGtBvJ,EAAKsJ,QAAQgI,kBAAoB,KACjC1Z,KAAK2Z,kBAAkBva,GACvBY,KAAK4Z,gBAAgBxa,IACrB,IAAAya,oBAAmBza,GACnBY,KAAK8Z,eACL9Z,KAAK6Y,SAAW,KAChB7Y,KAAKoM,WAAY,EACbpM,KAAK+Z,sBACL/Z,KAAKyJ,cAAcmB,4BACnB,QAAiBb,EAAW5J,gBAEhC,OAAsCyM,GAClCmM,IACA,IAAAiB,4BAA2BjQ,KAGnC/J,KAAKia,cAAiBzN,IAClBxM,KAAKoM,WAAY,EACjB,MAAMvE,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,WAAEkC,EAAU,oBAAE6C,EAAmB,YAAEkM,EAAW,cAAE3D,EAAa,cAAE4D,GAAmB/Y,KAAK6Y,SAC7F7Y,KAAKka,WAAW9a,EAAS2K,EAAY,CAAEgP,kBACvC,MAAM,KAAE3Q,GAAS2B,EACjB,GAAIoL,EAAe,CACf,MAAM,YAAEgF,GAAgBtS,EAClBuS,EAAgBD,EAAY9F,OAC5B,QAAE7Q,GAAY4E,EAAKsJ,SACnB,cAAEI,GAAkBtO,EAC1BsO,EAAc,IAAMsI,EAAc,GAClCtI,EAAc,IAAMsI,EAAc,GAClCtI,EAAc,IAAMsI,EAAc,GAClC5W,EAAQmO,UAAW,CACvB,MACK,QAAoB1Q,IAAhB6X,EAA2B,CAChC,MAAM,YAAEqB,GAAgBtS,EAClBuS,EAAgBD,EAAY9F,OAC5B,OAAEzG,GAAWxF,EAAKsJ,QACxB9D,EAAO3O,QAASgU,IACZA,EAAM,IAAMmH,EAAc,GAC1BnH,EAAM,IAAMmH,EAAc,GAC1BnH,EAAM,IAAMmH,EAAc,KAE9BrQ,EAAWC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEoK,GAAkBvM,EACpBxI,GAAiB,IAAAC,mBAAkBF,IACnC,cAAE0O,EAAa,cAAEwC,GAAkBjR,EAAesO,SAClDwG,EAAWC,EAAcC,OACzB,OAAEzG,GAAWxF,EAAKsJ,QAExB,IAAI2I,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACJ,OATAhN,EAAOkL,GAAe,IAAI3E,GASlB2E,GACJ,KAAK,EACL,KAAK,EACDuB,EAAmBvM,EAAcF,EAAO,IACxC4M,EAAiB1M,EAAcF,EAAO,IACtC0M,EAAoB,CAACE,EAAe,GAAIH,EAAiB,IACzDE,EAAgB,CAACF,EAAiB,GAAIG,EAAe,IACrDE,EAAmBpK,EAAcgK,GACjCK,EAAerK,EAAciK,GAC7B3M,EAAO,GAAK8M,EACZ9M,EAAO,GAAK+M,EACZ,MACJ,KAAK,EACL,KAAK,EACDL,EAAoBxM,EAAcF,EAAO,IACzC2M,EAAgBzM,EAAcF,EAAO,IACrCyM,EAAmB,CACfE,EAAc,GACdD,EAAkB,IAEtBE,EAAiB,CACbF,EAAkB,GAClBC,EAAc,IAElBE,EAAkBnK,EAAc+J,GAChCO,EAAgBtK,EAAckK,GAC9B5M,EAAO,GAAK6M,EACZ7M,EAAO,GAAKgN,EAGpB7Q,EAAWC,aAAc,CAC7B,CACAhK,KAAK6Y,SAASlH,UAAW,GACF,IAAArS,mBAAkBF,IACzC,OAAsCwN,GAClC7C,EAAWC,cACX,IAAAiH,2BAA0BlH,EAAY3K,EAAS,EAAA8R,YAAY2J,iBAGnE7a,KAAKmO,OAAU/O,IACX,GAAIY,KAAKoM,UAAW,CAChBpM,KAAKoM,WAAY,EACjBpM,KAAK4Z,gBAAgBxa,GACrBY,KAAK2Z,kBAAkBva,IACvB,IAAAya,oBAAmBza,GACnB,MAAM,WAAE2K,EAAU,oBAAE6C,EAAmB,cAAEmM,GAAkB/Y,KAAK6Y,UAC1D,KAAEzQ,GAAS2B,EAQjB,OAPAA,EAAWuP,aAAc,EACzBlR,EAAKsJ,QAAQgI,kBAAoB,MACjC,OAAsC9M,GAClCmM,IACA,IAAAiB,4BAA2BjQ,GAE/B/J,KAAK6Y,SAAW,KACT9O,EAAW5J,aACtB,GAEJH,KAAKgZ,cAAiB5Z,IAClB,KAAM0b,uBAAwB,EAC9B1b,EAAQ2b,iBAAiB,EAAA/S,OAAOgT,SAAUhb,KAAKyZ,cAC/Cra,EAAQ2b,iBAAiB,EAAA/S,OAAOiT,WAAYjb,KAAKia,eACjD7a,EAAQ2b,iBAAiB,EAAA/S,OAAOkT,WAAYlb,KAAKia,eACjD7a,EAAQ2b,iBAAiB,EAAA/S,OAAOmT,YAAanb,KAAKyZ,cAClDra,EAAQ2b,iBAAiB,EAAA/S,OAAOoT,UAAWpb,KAAKyZ,cAChDra,EAAQ2b,iBAAiB,EAAA/S,OAAOqT,WAAYrb,KAAKia,eACjD7a,EAAQ2b,iBAAiB,EAAA/S,OAAOsT,UAAWtb,KAAKyZ,eAEpDzZ,KAAK4Z,gBAAmBxa,IACpB,KAAM0b,uBAAwB,EAC9B1b,EAAQmc,oBAAoB,EAAAvT,OAAOgT,SAAUhb,KAAKyZ,cAClDra,EAAQmc,oBAAoB,EAAAvT,OAAOiT,WAAYjb,KAAKia,eACpD7a,EAAQmc,oBAAoB,EAAAvT,OAAOkT,WAAYlb,KAAKia,eACpD7a,EAAQmc,oBAAoB,EAAAvT,OAAOmT,YAAanb,KAAKyZ,cACrDra,EAAQmc,oBAAoB,EAAAvT,OAAOoT,UAAWpb,KAAKyZ,cACnDra,EAAQmc,oBAAoB,EAAAvT,OAAOqT,WAAYrb,KAAKia,eACpD7a,EAAQmc,oBAAoB,EAAAvT,OAAOsT,UAAWtb,KAAKyZ,eAEvDzZ,KAAKuZ,gBAAmBna,IACpB,KAAM0b,uBAAwB,EAC9B1b,EAAQ2b,iBAAiB,EAAA/S,OAAOgT,SAAUhb,KAAKyZ,cAC/Cra,EAAQ2b,iBAAiB,EAAA/S,OAAOiT,WAAYjb,KAAKia,eACjD7a,EAAQ2b,iBAAiB,EAAA/S,OAAOmT,YAAanb,KAAKyZ,cAClDra,EAAQ2b,iBAAiB,EAAA/S,OAAOoT,UAAWpb,KAAKyZ,cAChDra,EAAQ2b,iBAAiB,EAAA/S,OAAOqT,WAAYrb,KAAKia,eACjD7a,EAAQ2b,iBAAiB,EAAA/S,OAAOsT,UAAWtb,KAAKyZ,eAEpDzZ,KAAK2Z,kBAAqBva,IACtB,KAAM0b,uBAAwB,EAC9B1b,EAAQmc,oBAAoB,EAAAvT,OAAOgT,SAAUhb,KAAKyZ,cAClDra,EAAQmc,oBAAoB,EAAAvT,OAAOiT,WAAYjb,KAAKia,eACpD7a,EAAQmc,oBAAoB,EAAAvT,OAAOmT,YAAanb,KAAKyZ,cACrDra,EAAQmc,oBAAoB,EAAAvT,OAAOoT,UAAWpb,KAAKyZ,cACnDra,EAAQmc,oBAAoB,EAAAvT,OAAOqT,WAAYrb,KAAKia,eACpD7a,EAAQmc,oBAAoB,EAAAvT,OAAOsT,UAAWtb,KAAKyZ,eAEvDzZ,KAAKwb,iBAAmB,CAACnc,EAAgBa,KACrC,IAAIwU,GAAe,EACnB,MAAM,SAAE/G,GAAatO,GACf,QAAED,GAAYuO,EACpB,IAAIyE,GAAc,QAAepS,KAAK8M,cAAe1N,GACrD,IAAKgT,GAAa7P,OACd,OAAOmS,EAGX,GADAtC,EAAcpS,KAAKmS,wCAAwC/S,EAASgT,IAC/DA,GAAa7P,OACd,OAAOmS,EAEX,MAAM/F,EAAW3O,KAAKqR,YAAY1D,GAC5Ba,EAAkBb,EAAS8N,qBAC3BnK,EAAiB,CACnBC,YAAavR,KAAKuR,YAClBjI,SAAUtJ,KAAK8M,cACfvN,WAAYF,EAAesO,SAAS7E,IAExC,IAAK,IAAI7G,EAAI,EAAGA,EAAImQ,EAAY7P,OAAQN,IAAK,CACzC,MAAM8H,EAAaqI,EAAYnQ,IACzB,cAAE9B,EAAa,KAAEiI,GAAS2B,GAC1B,OAAE6D,EAAM,kBAAE8L,GAAsBtR,EAAKsJ,QACrC1C,EAAoBpB,EAAOqB,IAAKC,GAAMvB,EAASG,cAAcoB,IACnEoC,EAAenR,cAAgBA,EAC/B,MAAM,MAAEM,EAAK,UAAEG,EAAS,SAAEC,GAAab,KAAKwU,mBAAmB,CAC3DzK,aACAuH,oBAEE,gBAAEsB,EAAe,OAAE8I,GAAW/N,EAAS6E,YAC7C,GAAKpK,EAAKqG,YAAYE,IACqB,MAAvCvG,EAAKqG,YAAYE,GAAU8G,UAW1B,GAAI1L,EAAWC,cAChBhK,KAAKiS,+BAA+BlI,EAAY6I,EAAiB8I,EAAQlN,EAAiBnP,GACtFsO,aAAoB,EAAA2E,gBAAgB,CACpC,MAAM,kBAAEhD,GAAsBvF,EAAWgF,SACzC,IAAK,MAAMJ,KAAYvG,EAAKqG,YACxB,GAAIE,EAASgN,WAAW,WAAY,CACdnN,EAAgBoN,oBACClT,KAAMG,IACrC,MAAMgT,EAAqB,yBAAqBvM,GAC1CwM,EAAcjT,EAAGiT,YAAYD,GAC7BE,EAAkB,yBAAqBlT,EAAGmT,qBAChD,OAAOF,GAAeC,IAAoBF,YAGnCzT,EAAKqG,YAAYE,EAEhC,CAER,OA5BAvG,EAAKqG,YAAYE,GAAY,CACzBa,SAAU,KACV6F,KAAM,KACNC,IAAK,KACLC,KAAM,KACNC,OAAQ,KACRC,SAAU,MAEdzV,KAAKuO,sBAAsBxE,EAAY6I,EAAiB8I,EAAQlN,EAAiBnP,GAsBrF,IAAKsO,EAAS8N,qBAEV,OADAlT,QAAQC,KAAK,uCACNkM,EAEX,IAAIuH,EACJ,KAAK,IAAAC,qBAAoB/b,GACrB,SAQJ,IANK,IAAAgc,oBAAmBhc,IACnBH,KAAK6Y,UADN,MAEAa,IAEAuC,EAA2B,CAACjN,EAAkB0K,KAE9CuC,EAA0B,CAC1B,MAAMna,EAAiB,KACvB,IAAAsa,aAAelc,EAAkBC,EAAe2B,EAAgBma,EAA0B,CACtFxb,SAER,CACA,MAAMD,EAAS,GAAGL,SACZ2D,EAAe,KACrB,2BAAY5D,EAAkBC,EAAe2D,EAAckL,EAAmB,CAC1EvO,QACAI,WACAD,aACDJ,GACHkU,GAAe,EACf,MAAMnU,EAAUP,KAAKwR,sBAAsBF,EAAgBvH,GAC3D,IAAKxJ,EAAQkR,WAAY,CACrBrJ,EAAKsJ,QAAQlO,QAAU,CACnBmO,UAAU,EACVG,cAAe,CAAC,EAAG,EAAG,GACtBE,iBAAkB,CACdjO,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAMZ,EAAYtD,KAAKyJ,cAAcuC,aAAa5D,EAAMuG,GACxD,IAAKrL,GAAkC,IAArBA,EAAUf,OACxB,SAEJ,IAAK6F,EAAKsJ,QAAQlO,QAAQmO,SAAU,CAChC,MAAMC,GAAsB,IAAAC,wBAAuB7C,GACnD5G,EAAKsJ,QAAQlO,QAAQsO,cACjBnE,EAAS2C,cAAcsB,EAC/B,CACA,MAAMrO,EAAkBoK,EAASG,cAAc1F,EAAKsJ,QAAQlO,QAAQsO,eAC9DzO,EAAa,IACbhB,GAAc,IAAA0P,mBAAqB7R,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiByL,EAAmB,CAAC,EAAGzO,IACjImC,EAAGC,EAAMC,EAAGC,EAAG,MAAElC,EAAK,OAAEmC,GAAWT,EAC3C+F,EAAKsJ,QAAQlO,QAAQwO,iBAAmB,CACpCjO,QAAS4J,EAAS2C,cAAc,CAAC3N,EAAME,IACvCmB,SAAU2J,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,IAChDoB,WAAY0J,EAAS2C,cAAc,CAAC3N,EAAME,EAAMC,IAChDoB,YAAayJ,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,EAAMC,IAEjE,CACA,OAAO4R,GAEX1U,KAAKqZ,8BAAiCzL,IAClC,MAAOyO,EAAQC,GAAU1O,EACzB,MAAO,CACHjL,KAAMgR,KAAK2C,IAAI+F,EAAO,GAAIC,EAAO,IACjCzZ,IAAK8Q,KAAK2C,IAAI+F,EAAO,GAAIC,EAAO,IAChC3b,MAAOgT,KAAKC,IAAIyI,EAAO,GAAKC,EAAO,IACnCxZ,OAAQ6Q,KAAKC,IAAIyI,EAAO,GAAKC,EAAO,MAG5Ctc,KAAKuO,sBAAwB,CAACxE,EAAY6I,EAAiB8I,EAAQlN,EAAiBnP,KAChF,IAAKW,KAAKyJ,cAAcC,eACpB,OAEJ,MAAM,KAAEtB,GAAS2B,GACX,SAAE4D,GAAatO,GACf,QAAED,GAAYuO,EACd4O,EAAYnU,EAAKsJ,QAAQ9D,OAAO,GAChC4O,EAAYpU,EAAKsJ,QAAQ9D,OAAO,IAChC,YAAEa,GAAgBrG,EAClBsG,EAAY3P,OAAOC,KAAKyP,GAC9B,IAAK,IAAIxM,EAAI,EAAGA,EAAIyM,EAAUnM,OAAQN,IAAK,CACvC,MAAM0M,EAAWD,EAAUzM,GACrB2M,EAAQ5O,KAAK6O,mBAAmBF,GACtC,IAAKC,EACD,SAEJ,MAAM,WAAE6N,EAAU,UAAE3N,EAAS,SAAEC,EAAQ,aAAE4G,GAAiB/G,EACpD8N,EAAYhE,EAAsB5J,EAAWyN,GACnDG,EAAU,GAAK/I,KAAKmC,MAAM4G,EAAU,IACpCA,EAAU,GAAK/I,KAAKmC,MAAM4G,EAAU,IACpCA,EAAU,GAAK/I,KAAKmC,MAAM4G,EAAU,IACpC,MAAMC,EAAYjE,EAAsB5J,EAAW0N,GAInD,GAHAG,EAAU,GAAKhJ,KAAKmC,MAAM6G,EAAU,IACpCA,EAAU,GAAKhJ,KAAKmC,MAAM6G,EAAU,IACpCA,EAAU,GAAKhJ,KAAKmC,MAAM6G,EAAU,IAChC3c,KAAK4c,gBAAgBF,EAAWC,EAAWF,GAAa,CACxDzc,KAAK+Z,sBAAuB,EAC5B,MAMMhD,EAAY,CACd,CAPSpD,KAAK2C,IAAIoG,EAAU,GAAIC,EAAU,IACjChJ,KAAK2B,IAAIoH,EAAU,GAAIC,EAAU,KAO1C,CANShJ,KAAK2C,IAAIoG,EAAU,GAAIC,EAAU,IACjChJ,KAAK2B,IAAIoH,EAAU,GAAIC,EAAU,KAM1C,CALShJ,KAAK2C,IAAIoG,EAAU,GAAIC,EAAU,IACjChJ,KAAK2B,IAAIoH,EAAU,GAAIC,EAAU,OAMxC,WAAEE,EAAU,YAAEC,IAAgB,OAAkClK,EAAiB8I,EAAQa,EAAWC,GACpG9K,EAAU,CAACgL,EAAWC,IACtB,MAAEjH,EAAK,SAAED,IAAa,QAAiC7G,EAAO8C,GAC9D2D,EAAO1B,KAAKC,IAAIiJ,EAAaC,IAAgBpH,EAAQA,GACrDqH,EAAoB,CACtB3N,aAAa,OAAoBzB,EAAUgB,GAC3CU,YAAarP,KAAKqP,YAAY1B,EAAUgB,EAAU5E,EAAWgF,SAASO,oBAEpEC,GAAe,OAAmBR,EAASS,SAAUzF,EAAWgF,SAASO,kBAAmByN,GAClG,IAAI5F,EACAxB,IACAwB,EAAgBxB,EAAa1W,QAAQe,KAAKyJ,cAAcyC,gBAAgBqL,cAAe,CACnFR,YACAjI,YACAmJ,aAAcjY,KAAKyJ,cAAciB,kBAGzC,MAAMwN,EAAQlY,KAAKyJ,cAAcyC,gBAAgBiM,gBACjD1J,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnB6F,OACAE,KAAM2C,EAAM3C,MAAM6C,MAClB5C,OAAQ0C,EAAM1C,QAAQ4C,MACtB9C,IAAK4C,EAAM5C,KAAK8C,MAChB9B,IAAK4B,EAAM5B,KAAK8B,MAChBC,WAAYH,EAAMI,MAClBnB,cAAeA,EACf1B,WACAlG,eAER,MAEIvP,KAAK+Z,sBAAuB,EAC5BtL,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SAG/B,CACA,MAAMxF,EAAcD,EAAWC,YAK/B,OAJAD,EAAWC,aAAc,EACrBA,IACA,IAAAiH,2BAA0BlH,EAAY3K,EAAS,EAAA8R,YAAYC,cAExD1C,GAEXzO,KAAK4c,gBAAkB,CAACI,EAAQC,EAAQR,IAC5B,kCAA8BO,EAAQP,IAC1C,kCAA8BQ,EAAQR,GAE9Czc,KAAKiS,gCAAiC,OAASjS,KAAKuO,sBAAuB,IAAK,CAAE2D,UAAU,GAChG,QACSlS,KAAKkd,QAAU,CAAC3d,EAAYqO,EAAQrN,KACzC,MAAMlB,GAAiB,IAAA8d,+BAA8B5d,GACrD,IAAKF,EACD,OAEJ,MAAM,oBAAE2T,EAAmB,kBAAE1D,EAAiB,gBAAEsD,EAAe,SAAEwK,EAAQ,SAAEzP,GAAc3N,KAAKqd,YAAY1E,EAAkBtZ,EAAgBuO,EAAQrN,IAC9I,aAAE+c,KAAiBC,GAAwBhd,GAAW,CAAC,EACvDwJ,EAAa,CACf5J,cAAeI,GAASJ,eAAiB,qBACzCiI,KAAM,CACFsJ,QAAS,CACL9D,SACA8L,kBAAmB,MAEvBnF,MAAO,GACP9F,YAAa,CAAC,GAElB6K,aAAa,EACbkE,eAAe,EACfxT,aAAa,EACbyT,UAAU,EACV1J,WAAW,EACXhF,SAAU,CACNzF,SAAU8T,EAAStQ,cACnB8F,kBACAI,sBACA1D,uBACGiO,KAGX,QAAcxT,EAAY4D,EAASvO,UACnC,OAAsC,CAACuO,EAAS7E,KACjD,EAEP,SAASmD,EAAoB7D,EAAMuG,GAC/B,MAAM4J,EAAoBnQ,EAAKqG,YAAYE,IACrC,KAAE0G,EAAI,KAAEE,EAAI,IAAED,EAAG,OAAEE,EAAM,SAAEC,EAAQ,aAAElG,EAAY,IAAE+G,GAAQiC,EACjE,GAAIhD,QACA,OAEJ,MAAMjS,EAAY,GAgBlB,OAfI,qBAAiB+R,IACjB/R,EAAU4Q,KAAK,SAAS,wBAAoBmB,MAASI,KAErD,qBAAiBF,IACjBjS,EAAU4Q,KAAK,SAAS,wBAAoBqB,MAAShG,KAErD,qBAAiB+F,IACjBhS,EAAU4Q,KAAK,QAAQ,wBAAoBoB,MAAQ/F,KAEnD,qBAAiB+G,IACjBhT,EAAU4Q,KAAK,QAAQ,wBAAoBoC,MAAQ/G,KAEnD,qBAAiBiG,IACjBlS,EAAU4Q,KAAK,YAAY,wBAAoBsB,MAAWjG,KAEvDjM,CACX,CACA,S,sNC7jBe,MAAMoa,UAAyB,YACjC1d,KAAK2d,YAAc,CACxBC,QAAS,KACTxe,QAAS,KACTye,WAAY,EACZC,MAAO,KACPC,WAAY,CAACC,IAAKA,KAClBC,QAAQ,EACT,CACH,WAAA7Z,CAAYmF,EAAWiB,GACnBhB,MAAMD,EAAWiB,GACjBxK,KAAKke,QAAU,IAAIC,IACnBne,KAAKoe,gBAAkB,IAAID,IAC3Bne,KAAKqe,uBAAyB,CAC1BvZ,aAAc,KACdwZ,iBAAiB,EACjBC,iBAAiB,EACjBC,eAAgB,GAExB,CACA,mBAAAC,CAAoBjS,GAChB,MAAM,GAAE1D,EAAE,cAAE4V,GAAkBlS,EAAIC,OAClC,GAAsB,aAAlBiS,EAAJ,CAGA,GAAI1e,KAAKoe,gBAAgBO,IAAI7V,GAAK,CAC9B9I,KAAK4e,WAAa,KAClB,MAAMC,EAAW7e,KAAKoe,gBAAgBU,IAAIhW,GACpC1J,EAAUyf,GAAUzf,QACpB2f,EAAgB/e,KAAKgf,iBAAiB5f,GAC5C2f,EAAcja,aAAe+Z,GAAU/Z,aACnC1F,GACAY,KAAKif,6BAA4B,IAAA3f,mBAAkBF,GAAU2f,EAAe,EAAAG,kBAAkBC,cAEtG,CACAnf,KAAKof,aAAanB,QAAS,CAX3B,CAYJ,CACA,gBAAImB,GACA,OAAO1B,EAAiBC,WAC5B,CACA,UAAAzD,CAAWtV,EAAgBya,GACvB,MAAMC,EAAiBD,EAAyBvW,GAChD,GAAI9I,KAAKuf,MACLvf,KAAKuf,KAAKF,2BAA6BA,EACvC,OAAOrf,KAAKuf,KAEhB,IAAIA,EAAOvf,KAAKke,QAAQY,IAAIQ,GAY5B,OAXKC,EAKGA,EAAKC,mBACLD,EAAO,qBAAgC3a,EAAgBya,GACvDrf,KAAKke,QAAQuB,IAAIH,EAAgBC,KANrCA,EAAO,qBAAgC3a,EAAgBya,GACvDrf,KAAKke,QAAQuB,IAAIH,EAAgBC,IAQrCvf,KAAKuf,KAAOA,EACLA,CACX,CACA,cAAAG,CAAetgB,GACX,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACfsgB,GAAqB,OAAsBhS,EAAS7E,IAC1D,IAAK6W,EAAoB,CACrB,MAAMC,EAAQ,IAAIC,YAAY,EAAAC,MAAA,OAAaC,YAAa,CACpDtT,OAAQ,CACJ5H,KAAM,eACNmb,QAAS,qGAEbC,YAAY,IAGhB,OADA,EAAAlY,YAAYmY,cAAcN,GACnB,IACX,CACA,MAAM,eAAEhb,GAAmB+a,EACrBQ,GAAiB,IAAAC,yBAAwBxb,IACzC,mBAAE0D,IAAuB,OAAgB1D,GAO/C,OANiB5E,KAAKqgB,YAAY,CAC9B1S,WACArF,qBACA6X,iBACAvb,kBAGR,CACA,WAAAyb,EAAY,SAAE1S,EAAQ,mBAAErF,EAAkB,eAAE6X,EAAc,eAAEvb,IACxD,GAAI+I,aAAoB,EAAA2S,mBAAoB,CACxC,MAAM,SAAEC,GAAajY,EAAmB,IAA4B1C,UAC9D4a,EAAS7S,EAAS8S,YAExB,GADwB9S,aAAoB,EAAA+S,cACvB,CACjB,MAAMd,EAAQ,IAAIC,YAAY,EAAAC,MAAA,OAAaC,YAAa,CACpDtT,OAAQ,CACJ5H,KAAM,eACNmb,QAAS,2DAEbC,YAAY,IAGhB,OADA,EAAAlY,YAAYmY,cAAcN,GACnB,IACX,CACA,MAAMe,EAAUH,EAAOvR,IAAK2R,GAAe,EAAAC,MAAMC,UAAUF,EAAWG,eAChEC,EAAqB,EAAAH,MAAMC,UAAUP,GACrCU,EAAgCN,EAAQjY,KAAMwY,GAAW,oBAAgBA,EAAOzE,WAAYuE,EAAmBvE,cAAc8D,UAAYI,EAAQ,IAAIJ,SAC3J,MAAO,CACHA,WACAY,mBAAoBnhB,KAAKyJ,cAAc2X,WAAWb,UAC9CU,EACJd,iBAER,CACK,CACD,MAAMkB,GAAsB,QAAqC1T,EAAS7E,GAAIlE,GAC9E,IAAKyc,EACD,OAEJ,MAAO,CACHC,QAASD,EACTlB,iBAER,CACJ,CACA,eAAAoB,CAAgBniB,EAASoiB,GACrB,MAAMniB,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACfkT,EAAS5E,EAAS6E,aAClB,gBAAEI,EAAe,OAAE8I,GAAWnJ,EAC9B3F,EAAsB,CAACe,EAAS7E,KAChC,aAAEhE,EAAY,eAAEF,EAAc,aAAE6c,GAAiBzhB,KAAK0hB,0BAA0B/T,IAAa,CAAC,EAYpG,MAAO,CACHgU,YAZgB,CAChB5S,SAAU,CACN6D,gBAAiB,IAAIA,GACrB8I,OAAQ,IAAIA,GACZ1I,oBAAqBrF,EAASiU,yBAC9BtS,kBAAmB,GACnBhG,SAAUtJ,KAAK8M,cACf2U,gBAEJrZ,KAAM,CAAC,GAIPoZ,eACA1c,eACA6I,WACA/I,iBACA6c,eACA7U,sBAER,CACA,yBAAA8U,CAA0B/T,GACtB,MAAMpO,EAAaoO,EAAS7E,GACtB+Y,GAAuB,OAAsBtiB,GACnD,IAAKsiB,EACD,OAEJ,MAAM,eAAEjd,GAAmBid,EACrB/c,GAAe,OAAsBF,GAC3C,IAAKE,EACD,OAGJ,MAAO,CACHA,eACAF,iBACA6c,cAJiB,IAAAK,sBAAqBviB,EAAYqF,EAAgBE,GAM1E,CACA,gBAAAka,CAAiB5f,GACb,MAAMyZ,EAAW7Y,KAAK+hB,WAAa/hB,KAAK0f,eAAetgB,IACjD,aAAE0F,EAAY,eAAEF,EAAc,YAAE+c,GAAgB3hB,KAAK4e,YAAc5e,KAAKuhB,gBAAgBniB,IACxF,KAAEgJ,EAAI,SAAE2G,EAAW,CAAC,GAAM4S,GAAe,CAAC,GAC1C,gBAAE/O,EAAe,OAAE8I,GAAW3M,EAC9BiT,EAAchiB,KAAKyJ,cAAcmU,SAASqE,gBAAgBnd,IAC1D,SAAE6I,IAAa,IAAArO,mBAAkBF,GACjCqiB,GAAe,IAAAK,sBAAqBnU,EAAS7E,GAAIlE,EAAgBE,GACvE,IAAKkd,IAAgBP,EACjB,OAEJ,IAAIS,EAAe,KAAMC,EAAsB,KAC3CniB,KAAKyJ,cAAcmU,SAAS3S,UAC5BiX,EAAeF,GAqJ3B,SAAsBxgB,EAAG4gB,EAAGrK,EAAGD,EAAGuK,EAAS,IACvC,MAAO,CACH1O,KAAK2O,MAAM9gB,GAAK,IAAMA,GAAK6gB,GAC3B1O,KAAK2O,MAAMF,GAAK,IAAMA,GAAKC,GAC3B1O,KAAK2O,MAAMvK,GAAK,IAAMA,GAAKsK,GAC3BvK,EAER,CA5J0CyK,IAAgBd,GAC9CU,EAAsB,KAkB1B,MAhBsB,IACftJ,EACHjL,OAAQxF,GAAMsJ,SAAS9D,OACvB9I,eACA8N,kBACA4P,gBAAiBxiB,KAAKof,aAAanB,OACnC1M,YAAavR,KAAKuR,YAClB3M,iBACA8W,SACA2C,uBAAwBre,KAAKqe,uBAC7BoE,eAAgBziB,KAAKyJ,cAAcgZ,eACnChZ,cAAezJ,KAAKyJ,cACpByY,eACAC,sBACAjI,WAAYla,KAAKka,WAAWna,KAAKC,MAGzC,CACA,UAAA0iB,CAAWtjB,EAAUY,KAAKof,aAAahgB,QAASmB,GAC5C,MAAM,aAAE6e,GAAiBpf,KACnB2iB,EAAepiB,GAASoiB,cACT,IAAjBA,EACA3iB,KAAK4iB,cAAcxjB,IAEG,IAAjBujB,GACL3iB,KAAK6iB,cAAczjB,GAEvB,MAAMC,GAAiB,IAAAC,mBAAkBF,GACnC0jB,EAAU9iB,KAAKif,4BAA4B5f,EAAgBW,KAAKgf,iBAAiB5f,GAAU,EAAA8f,kBAAkB6D,YAEnH,OADA3D,EAAanB,QAAS,EACf6E,CACX,CACA,aAAAD,CAAczjB,EAAUY,KAAKof,aAAahgB,SACtC,IAAKA,EACD,OAEJY,KAAK8Z,eACL,MAAMza,GAAiB,IAAAC,mBAAkBF,GACzCY,KAAKif,4BAA4B5f,EAAgBW,KAAKgf,iBAAiB5f,GAAU,EAAA8f,kBAAkB8D,eACnGhjB,KAAKof,aAAaxB,QAAU,KAC5B5d,KAAKof,aAAanB,QAAS,CAC/B,CACA,aAAA2E,CAAcxjB,EAAUY,KAAKof,aAAahgB,SACtC,IAAKA,EACD,OAEJ,MAAM2f,EAAgB/e,KAAKgf,iBAAiB5f,GACxCY,KAAKuf,MAAQvf,KAAKuf,KAAKzW,IACvB9I,KAAKoe,gBAAgBqB,IAAIzf,KAAKuf,KAAKzW,GAAI,CACnC1J,UACA0F,aAAcia,EAAcja,eAGpC,MAAMzF,GAAiB,IAAAC,mBAAkBF,GACzCY,KAAKif,4BAA4B5f,EAAgB0f,EAAe,EAAAG,kBAAkBC,eAClFnf,KAAK8Z,eACL9Z,KAAKof,aAAaxB,QAAU,KAC5B5d,KAAKof,aAAanB,QAAS,CAC/B,CACA,iCAAOgF,CAA2BtV,EAAUpN,GACxC,MAAM2iB,EAAiB3iB,GAAS2iB,iBAAkB,EAC5C9Q,GAAc,IAAA+Q,qBACdC,GAAkB,IAAAzQ,6BAA4BhF,EAAUyE,GAC9D,IAAKgR,GAAiB7gB,OAClB,OAEJ,MAAM8gB,EAAqBD,EAAgBna,OAAQc,GAAeA,EAAW3B,KAAKgF,SAASjD,UAAU5H,QACrG,IAAK8gB,EAAmB9gB,OACpB,OAEJ,MAQMqb,EARgB,IAAIF,EAAiB,CAAC,EAAG,CAC3CjU,cAAe,CACX6Z,WAAY,CACRC,mBAAoB,EAAAC,kBAExBf,eAAgB,wBAGMC,WAAW/U,EAASvO,UAC5C,KAAEmgB,EAAI,eAAE3a,GAAmBgZ,EAC3B6F,EAAgBlE,GAAM5J,aACtB+N,EAAqBD,EAAcE,oBAAsBF,GACzD,WAAEhH,GAAegH,EACjB3U,EAAYnB,EACbiW,kBACAC,MAAMC,YACNC,eACL,IAAK,MAAMha,KAAcsZ,EAAoB,CACzC,MAAMtM,EAAY,CACd,CAACiN,KAAWA,KACZ,CAACA,KAAWA,KACZ,CAACA,KAAWA,OAEV,SAAE7Z,GAAaJ,EAAW3B,KAAKgF,QACrC,IAAK,MAAM6F,KAAS9I,EAAU,CACP2E,EAAUmV,aAAahR,GAC/BhU,QAAQ,CAACilB,EAAGC,KACnBpN,EAAUoN,GAAK,GAAKxQ,KAAK2C,IAAIS,EAAUoN,GAAK,GAAID,GAChDnN,EAAUoN,GAAK,GAAKxQ,KAAK2B,IAAIyB,EAAUoN,GAAK,GAAID,IAExD,CACAnN,EAAU9X,QAAQ,CAACmlB,EAAOD,KACtBC,EAAM,GAAKzQ,KAAK2O,MAAM3O,KAAK2B,IAAI,EAAG8O,EAAM,KACxCA,EAAM,GAAKzQ,KAAK2O,MAAM3O,KAAK2C,IAAImG,EAAW0H,GAAO,EAAGC,EAAM,OAE9D,MAAMC,GAAc,OAAsBzf,GACpCmZ,EAAahU,EAAW3B,KAAKsJ,UAAU,IAAMvH,EAAS,GACtDma,EAAaxV,EAAUmV,aAAalG,GAAY9O,IAAI0E,KAAK2O,OACzDiC,EAAab,EAAmBc,cAAcF,IAAe,EACnE,IAAIG,GAAe,EACfC,GAAmB,EACvB,IAAK,MAAMC,KAAaxa,EAAU,CAC9B,MAAMya,EAAY9V,EAAUmV,aAAaU,GAAW1V,IAAI0E,KAAK2O,OACvDuC,EAAYnB,EAAmBc,cAAcI,GAC/CC,IAAcN,EACdE,GAAe,EAEVI,GAAa,IAClBH,GAAmB,EAE3B,CACA,MACM5f,EADU2f,GAAgBC,EAE1BH,EACe,IAAfA,EACIF,EACA,EACV,IAAK,IAAIpiB,EAAI8U,EAAU,GAAG,GAAI9U,GAAK8U,EAAU,GAAG,GAAI9U,IAChD,IAAK,IAAIoU,EAAIU,EAAU,GAAG,GAAIV,GAAKU,EAAU,GAAG,GAAIV,IAChD,IAAK,IAAIyO,EAAI/N,EAAU,GAAG,GAAI+N,GAAK/N,EAAU,GAAG,GAAI+N,IAAK,CACrD,MAAMC,EAAajW,EAAUmI,aAAa,CAAChV,EAAGoU,EAAGyO,KAC7B,IAAAE,yBAAwBD,EAAY5a,IAEpDsZ,EAAcwB,SAAShjB,EAAGoU,EAAGyO,EAAGhgB,EAExC,CAGJoe,IACA,IAAAgC,kBAAiBnb,EAAW5J,cAEpC,CACA,MAAMglB,EAAS1B,EAAc2B,4BAC7B,IAAAzd,iCAAgC/C,EAAgBugB,EACpD,E,kDCzOJ,QA/GA,SAAkBE,EAAMC,EAAM/kB,GAC1B,IAAIglB,EAAUC,EAAUC,EAAS9N,EAAQ+N,EAASC,EAC9CC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACT5T,GAAW,EACf,MAAM6T,GAAUT,GAAiB,IAATA,GAAsD,mBAAjCU,OAAOC,sBACpD,GAAoB,mBAATZ,EACP,MAAM,IAAIa,UAAU,uBASxB,SAASC,EAAWC,GAChB,MAAMC,EAAOd,EACPe,EAAUd,EAIhB,OAHAD,EAAWC,OAAWvkB,EACtB2kB,EAAiBQ,EACjBzO,EAAS0N,EAAKkB,MAAMD,EAASD,GACtB1O,CACX,CACA,SAAS6O,EAAWC,EAAanB,GAC7B,OAAIS,EACOC,OAAOC,sBAAsBQ,GAEjCC,WAAWD,EAAanB,EACnC,CAoBA,SAASqB,EAAaP,GAClB,MAAMQ,EAAoBR,EAAOT,EAEjC,YAAyB1kB,IAAjB0kB,GACJiB,GAAqBtB,GACrBsB,EAAoB,GACnBd,GAJuBM,EAAOR,GAIGH,CAC1C,CACA,SAASoB,IACL,MAAMT,EAAOU,KAAKC,MAClB,GAAIJ,EAAaP,GACb,OAAOY,EAAaZ,GAExBV,EAAUc,EAAWK,EArBzB,SAAuBT,GACnB,MACMa,EAAsBb,EAAOR,EAC7BsB,EAAc5B,GAFMc,EAAOT,GAGjC,OAAOG,EACDnS,KAAK2C,IAAI4Q,EAAazB,EAAUwB,GAChCC,CACV,CAcuCC,CAAcf,GACrD,CACA,SAASY,EAAaZ,GAElB,OADAV,OAAUzkB,EACNiR,GAAYqT,EACLY,EAAWC,IAEtBb,EAAWC,OAAWvkB,EACf0W,EACX,CAcA,SAASyP,KAAaf,GAClB,MAAMD,EAAOU,KAAKC,MACZM,EAAaV,EAAaP,GAIhC,GAHAb,EAAWc,EACXb,EAAWxlB,KACX2lB,EAAeS,EACXiB,EAAY,CACZ,QAAgBpmB,IAAZykB,EACA,OAzDZ,SAAqBU,GAGjB,OAFAR,EAAiBQ,EACjBV,EAAUc,EAAWK,EAAcvB,GAC5BO,EAAUM,EAAWC,GAAQzO,CACxC,CAqDmB2P,CAAY3B,GAEvB,GAAIG,EAEA,OADAJ,EAAUc,EAAWK,EAAcvB,GAC5Ba,EAAWR,EAE1B,CAIA,YAHgB1kB,IAAZykB,IACAA,EAAUc,EAAWK,EAAcvB,IAEhC3N,CACX,CAIA,OAnGA2N,EAAOiC,OAAOjC,IAAS,GACnB,OAAS/kB,KACTslB,EAAU2B,QAAQjnB,EAAQslB,SAC1BC,EAAS,YAAavlB,EACtBklB,EAAUK,EAASnS,KAAK2B,IAAIiS,OAAOhnB,EAAQklB,UAAY,EAAGH,GAAQG,EAClEvT,EAAW,aAAc3R,EAAUinB,QAAQjnB,EAAQ2R,UAAYA,GA2FnEkV,EAAUjZ,OAjCV,gBACoBlN,IAAZykB,GA3CR,SAAqB5c,GACjB,GAAIid,EACA,OAAOC,OAAOyB,qBAAqB3e,GAEvC4e,aAAa5e,EACjB,CAuCQ6e,CAAYjC,GAEhBE,EAAiB,EACjBL,EAAWI,EAAeH,EAAWE,OAAUzkB,CACnD,EA4BAmmB,EAAUQ,MA3BV,WACI,YAAmB3mB,IAAZykB,EAAwB/N,EAASqP,EAAaF,KAAKC,MAC9D,EA0BAK,EAAUS,QAzBV,WACI,YAAmB5mB,IAAZykB,CACX,EAwBO0B,CACX,C,iBC/Ge,SAASvV,EAAuBiW,GAC3C,MAAMC,EAKV,SAA2BC,GACvB,MAAMC,EAAqB,CAACD,EAAa,GAAIA,EAAa,IAAInQ,KAAKqQ,GAC7DC,EAAqB,CAACH,EAAa,GAAIA,EAAa,IAAInQ,KAAKuQ,GAC7DC,EAAQJ,EAAmBA,EAAmB1lB,OAAS,GACvDM,EAAMslB,EAAmB,GACzBG,EAASH,EAAmBA,EAAmB5lB,OAAS,GAC9D,MAAO,CACHM,MACAylB,SACAD,SAEJ,SAASH,EAAUpQ,EAAGC,GAClB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC9B,CACA,SAASqQ,EAAUtQ,EAAGC,GAClB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC9B,CACJ,CAtBoBwQ,CAAkBT,GAC5BU,GAAWT,EAAQllB,IAAI,GAAKklB,EAAQO,OAAO,IAAM,EAEvD,MADsB,CAACP,EAAQM,MAAM,GAAIG,EAE7C,C,kECJe,SAASC,EAAyB1e,GAC7C,MAAM2e,GAAY,OAA0B3e,GAC5C,OAAO2e,EAAUnmB,OAASmmB,EAAU,QAAKznB,CAC7C,C,mCCAA,QAJA,SAAkBmX,GACd,MAAMvT,SAAcuT,EACpB,OAAiB,OAAVA,IAA4B,WAATvT,GAA8B,aAATA,EACnD,C,kBCHe,SAAS8jB,EAAcC,EAAQnR,GAC1C,MAAM,OAAEpX,EAAM,OAAEC,GAAWsoB,EACrBC,EAAUD,EAAOC,SAAWvoB,EAASA,EAC3C,OAASmX,EAAS,GAAKpX,EAAO,KAAOoX,EAAS,GAAKpX,EAAO,KACrDoX,EAAS,GAAKpX,EAAO,KAAOoX,EAAS,GAAKpX,EAAO,KACjDoX,EAAS,GAAKpX,EAAO,KAAOoX,EAAS,GAAKpX,EAAO,KAClDwoB,CACR,C,kECSe,SAASC,EAAyBlb,EAAQmb,EAAUC,EAAUC,GACzE,MAAMC,EAAcF,EAAWD,EAAW,EACpCI,EAAgBxV,KAAKmC,MAAOmT,EAAuB,IAAOC,IAAgB,EAC1EE,EAAkBzV,KAAKmC,MAAMoT,EAAcC,IAAkB,EACnE,GAAIE,MAAMH,KAAiBA,IAAgBE,EACvC,OAAOxb,EAEX,GAAIsb,EAAcE,EAAkB,EAChC,OAAOxb,EAEX,MAAM0b,EAAwB3V,KAAK2B,IAAI,EAAGyT,GACpCQ,EAAwB5V,KAAK2C,IAAI1I,EAAOrL,OAAS,EAAGymB,GACpDQ,EAA4B5b,EAAO6b,MAAM,EAAGH,GAC5CI,EAA4B9b,EAAO6b,MAAMF,EAAwB,EAAG3b,EAAOrL,QAC3EonB,EA7BV,SAAgDC,EAAyBC,GACrE,MAAMlS,EAAS,IACRmS,EAAaC,GAAeF,EAC7BG,EAAeD,EAAcD,EAAc,EAC3CG,EAAYtW,KAAKmC,MAAMkU,EAAeJ,GAC5C,IAAIlnB,EAAI,EACJwnB,EAA6BvW,KAAK2O,OAAQ0H,EAAe,IAAMC,EAAY,GAAMvnB,GAAKonB,EAC1F,KAAOI,GAA8BH,GACjCpS,EAAOzD,KAAKgW,GACZxnB,IACAwnB,EACIvW,KAAK2O,OAAQ0H,EAAe,IAAMC,EAAY,GAAMvnB,GAAKonB,EAEjE,OAAOnS,CACX,CAeyBwS,CAAuCf,EAAiB,CACzEE,EACAC,IAGJ,MAAO,IACAC,MAFoB,OAAkB5b,EAAQ+b,MAI9CD,EAEX,C,4DCtCA,MAAM,QAAEU,GAAY,YAIdC,EAAW,CAHH,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,IAEpC,SAASC,EAAuBC,GAC5B,MAAMC,EAAgB,cAAc,cAAeD,EAAoB,GAAIA,EAAoB,IACzFE,EAAgB,cAAc,cAAeF,EAAoB,GAAIA,EAAoB,IAO/F,MAJkB,IAFCG,EAAwBF,EAAeH,MACvCK,EAAwBD,EAAeJ,IACTM,MAAOC,GAAUR,EAAQQ,EAAO,IAC7ER,EAAQQ,EAAO,KACfR,EAAQQ,EAAO,MACfR,EAAQQ,EAAO,KAEvB,CACA,SAASF,EAAwBG,EAAKC,GAClC,OAAOA,EAAK7b,IAAK8b,GAAkC,IAAxB,WAAWF,EAAKE,GAAepX,KAAKqX,GACnE,C,6DCFA,QAhBA,SAAkB3F,EAAMC,EAAM/kB,GAC1B,IAAIslB,GAAU,EACV3T,GAAW,EACf,GAAoB,mBAATmT,EACP,MAAM,IAAIa,UAAU,uBAMxB,OAJI,OAAS3lB,KACTslB,EAAU,YAAatlB,EAAUinB,QAAQjnB,EAAQslB,SAAWA,EAC5D3T,EAAW,aAAc3R,EAAUinB,QAAQjnB,EAAQ2R,UAAYA,IAE5D,OAASmT,EAAMC,EAAM,CACxBO,UACA3T,WACAuT,QAASH,GAEjB,C,kDChBA,SAAS2F,EAAoBtd,EAAUgB,GACnC,GAAIhB,aAAoB,EAAA2S,mBAAoB,CACxC,MAAMC,EAAW,EAAA7Y,UAAA,YAAsBiH,GACjCuS,EAAS,EAAAL,MAAMC,UAAUP,GAC/B,QAASW,GAAQgK,SAAWnsB,OAAOC,KAAKkiB,EAAOgK,SAAS3oB,OAAS,CACrE,CACK,GAAIoL,aAAoB,EAAA+S,cAAe,CACxC,MAAM,SAAEyK,GAAaxd,EAASiI,gBAAkB,CAAC,EACjD,QAASuV,GAAUC,MACvB,CAEI,OAAO,CAEf,C","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js"],"sourcesContent":["import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n","import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n","import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n","import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = {\n                ...currentStyles,\n                ...styles,\n            };\n        }\n        else {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided({\n                ...currentStyles,\n                ...styles,\n            }, type);\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;\n            contourStyles.renderFillInactive ??= contourStyles.renderFill;\n            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n        segmentIndex,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n","import { getSegmentation } from './getSegmentation';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nfunction internalAddRepresentationData({ segmentationId, type, data, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`Segmentation ${segmentationId} not found`);\n    }\n    if (segmentation.representationData[type]) {\n        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);\n    }\n    switch (type) {\n        case SegmentationRepresentations.Labelmap:\n            if (data) {\n                segmentation.representationData[type] =\n                    data;\n            }\n            break;\n        case SegmentationRepresentations.Contour:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        case SegmentationRepresentations.Surface:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        default:\n            throw new Error(`Invalid representation type ${type}`);\n    }\n}\nexport default internalAddRepresentationData;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nexport default PlanarFreehandContourSegmentationTool;\n","import { AnnotationTool } from '../base';\nimport { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, metaData, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'PlanarFreehandROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        deltaInX,\n                        deltaInY,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        canvasCoordinates,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        deltaInX,\n                        deltaInY,\n                    });\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n                annotationUID: annotation.annotationUID,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            if (!td.metadata.referencedImageId &&\n                !annotationViewPlaneNormal &&\n                td.metadata.FrameOfReferenceUID) {\n                for (const point of td.data.contour.polyline) {\n                    const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                    const dotProduct = vec3.dot(vector, camera.viewPlaneNormal);\n                    if (!csUtils.isEqual(dotProduct, 0)) {\n                        return false;\n                    }\n                }\n                td.metadata.viewPlaneNormal = camera.viewPlaneNormal;\n                td.metadata.cameraFocalPoint = camera.focalPoint;\n                return true;\n            }\n            if (!annotationViewPlaneNormal) {\n                const { referencedImageId } = td.metadata;\n                const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n                const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n                const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n                annotationViewPlaneNormal = vec3.create();\n                vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n                td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n            }\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId]?.unit) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                    unit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, deltaInX, deltaInY, }) {\n        const { scale, areaUnit, unit } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        let perimeter = calculatePerimeter(canvasCoordinates, closed) / scale;\n        perimeter *= Math.sqrt(Math.pow(deltaInX, 2) + Math.pow(deltaInY, 2));\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        let pointsInShape;\n        if (voxelManager) {\n            pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                imageData,\n                isInObject: (pointLPS, _pointIJK) => {\n                    let result = true;\n                    const point = viewport.worldToCanvas(pointLPS);\n                    if (point[1] != curRow) {\n                        intersectionCounter = 0;\n                        curRow = point[1];\n                        intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                        intersections.sort((function (index) {\n                            return function (a, b) {\n                                return a[index] === b[index]\n                                    ? 0\n                                    : a[index] < b[index]\n                                        ? -1\n                                        : 1;\n                            };\n                        })(0));\n                    }\n                    if (intersections.length && point[0] > intersections[0][0]) {\n                        intersections.shift();\n                        intersectionCounter++;\n                    }\n                    if (intersectionCounter % 2 === 0) {\n                        result = false;\n                    }\n                    return result;\n                },\n                boundsIJK,\n                returnPoints: this.configuration.storePointData,\n            });\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            min: stats.min?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, deltaInX, deltaInY, }) {\n        const { scale, unit } = calibratedScale;\n        let length = calculatePerimeter(canvasCoordinates, closed) / scale;\n        length *= Math.sqrt(Math.pow(deltaInX, 2) + Math.pow(deltaInY, 2));\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length,\n            modalityUnit,\n            unit,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, min, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(perimeter)) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (csUtils.isNumber(length)) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nexport default PlanarFreehandROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    static { this.toolName = 'RectangleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    cachedStats: {},\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    activeHandleIndex !== undefined) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    if (mean === undefined || mean === null) {\n        return;\n    }\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Max: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default RectangleROITool;\n","import { getEnabledElement, cache, utilities as csUtils, Enums, eventTarget, BaseVolumeViewport, StackViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { StrategyCallbacks } from '../../enums';\nimport * as LabelmapMemo from '../../utilities/segmentation/createLabelmapMemo';\nimport { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { isPointInsidePolyline3D } from '../../utilities/math/polyline';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { fillInsideCircle } from './strategies';\nexport default class LabelmapBaseTool extends BaseTool {\n    static { this.previewData = {\n        preview: null,\n        element: null,\n        timerStart: 0,\n        timer: null,\n        startPoint: [NaN, NaN],\n        isDrag: false,\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.memoMap = new Map();\n        this.acceptedMemoIds = new Map();\n        this.centerSegmentIndexInfo = {\n            segmentIndex: null,\n            hasSegmentIndex: false,\n            hasPreviewIndex: false,\n            changedIndices: [],\n        };\n    }\n    _historyRedoHandler(evt) {\n        const { id, operationType } = evt.detail;\n        if (operationType !== 'labelmap') {\n            return;\n        }\n        if (this.acceptedMemoIds.has(id)) {\n            this._hoverData = null;\n            const memoData = this.acceptedMemoIds.get(id);\n            const element = memoData?.element;\n            const operationData = this.getOperationData(element);\n            operationData.segmentIndex = memoData?.segmentIndex;\n            if (element) {\n                this.applyActiveStrategyCallback(getEnabledElement(element), operationData, StrategyCallbacks.AcceptPreview);\n            }\n        }\n        this._previewData.isDrag = true;\n    }\n    get _previewData() {\n        return LabelmapBaseTool.previewData;\n    }\n    createMemo(segmentationId, segmentationVoxelManager) {\n        const voxelManagerId = segmentationVoxelManager.id;\n        if (this.memo &&\n            this.memo.segmentationVoxelManager === segmentationVoxelManager) {\n            return this.memo;\n        }\n        let memo = this.memoMap.get(voxelManagerId);\n        if (!memo) {\n            memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n            this.memoMap.set(voxelManagerId, memo);\n        }\n        else {\n            if (memo.redoVoxelManager) {\n                memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n                this.memoMap.set(voxelManagerId, memo);\n            }\n        }\n        this.memo = memo;\n        return memo;\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        const editData = this.getEditData({\n            viewport,\n            representationData,\n            segmentsLocked,\n            segmentationId,\n        });\n        return editData;\n    }\n    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof StackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.threshold?.volumeId ??\n                    referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            return {\n                imageId: segmentationImageId,\n                segmentsLocked,\n            };\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];\n        const { viewport } = getEnabledElement(element);\n        const segmentColor = getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n        if (!configColor && !segmentColor) {\n            return;\n        }\n        let previewColor = null, previewSegmentIndex = null;\n        if (this.configuration.preview?.enabled) {\n            previewColor = configColor || lightenColor(...segmentColor);\n            previewSegmentIndex = 255;\n        }\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            viewPlaneNormal,\n            previewOnHover: !this._previewData.isDrag,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            centerSegmentIndexInfo: this.centerSegmentIndexInfo,\n            activeStrategy: this.configuration.activeStrategy,\n            configuration: this.configuration,\n            previewColor,\n            previewSegmentIndex,\n            createMemo: this.createMemo.bind(this),\n        };\n        return operationData;\n    }\n    addPreview(element = this._previewData.element, options) {\n        const { _previewData } = this;\n        const acceptReject = options?.acceptReject;\n        if (acceptReject === true) {\n            this.acceptPreview(element);\n        }\n        else if (acceptReject === false) {\n            this.rejectPreview(element);\n        }\n        const enabledElement = getEnabledElement(element);\n        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AddPreview);\n        _previewData.isDrag = true;\n        return results;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const operationData = this.getOperationData(element);\n        if (this.memo && this.memo.id) {\n            this.acceptedMemoIds.set(this.memo.id, {\n                element,\n                segmentIndex: operationData.segmentIndex,\n            });\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.AcceptPreview);\n        this.doneEditMemo();\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    static viewportContoursToLabelmap(viewport, options) {\n        const removeContours = options?.removeContours ?? true;\n        const annotations = getAllAnnotations();\n        const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);\n        if (!viewAnnotations?.length) {\n            return;\n        }\n        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);\n        if (!contourAnnotations.length) {\n            return;\n        }\n        const brushInstance = new LabelmapBaseTool({}, {\n            configuration: {\n                strategies: {\n                    FILL_INSIDE_CIRCLE: fillInsideCircle,\n                },\n                activeStrategy: 'FILL_INSIDE_CIRCLE',\n            },\n        });\n        const preview = brushInstance.addPreview(viewport.element);\n        const { memo, segmentationId } = preview;\n        const previewVoxels = memo?.voxelManager;\n        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;\n        const { dimensions } = previewVoxels;\n        const imageData = viewport\n            .getDefaultActor()\n            .actor.getMapper()\n            .getInputData();\n        for (const annotation of contourAnnotations) {\n            const boundsIJK = [\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n            ];\n            const { polyline } = annotation.data.contour;\n            for (const point of polyline) {\n                const indexPoint = imageData.worldToIndex(point);\n                indexPoint.forEach((v, idx) => {\n                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);\n                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);\n                });\n            }\n            boundsIJK.forEach((bound, idx) => {\n                bound[0] = Math.round(Math.max(0, bound[0]));\n                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));\n            });\n            const activeIndex = getActiveSegmentIndex(segmentationId);\n            const startPoint = annotation.data.handles?.[0] || polyline[0];\n            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);\n            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;\n            let hasZeroIndex = false;\n            let hasPositiveIndex = false;\n            for (const polyPoint of polyline) {\n                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);\n                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);\n                if (polyValue === startValue) {\n                    hasZeroIndex = true;\n                }\n                else if (polyValue >= 0) {\n                    hasPositiveIndex = true;\n                }\n            }\n            const hasBoth = hasZeroIndex && hasPositiveIndex;\n            const segmentIndex = hasBoth\n                ? startValue\n                : startValue === 0\n                    ? activeIndex\n                    : 0;\n            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n                        const worldPoint = imageData.indexToWorld([i, j, k]);\n                        const isContained = isPointInsidePolyline3D(worldPoint, polyline);\n                        if (isContained) {\n                            previewVoxels.setAtIJK(i, j, k, segmentIndex);\n                        }\n                    }\n                }\n            }\n            if (removeContours) {\n                removeAnnotation(annotation.annotationUID);\n            }\n        }\n        const slices = previewVoxels.getArrayOfModifiedSlices();\n        triggerSegmentationDataModified(segmentationId, slices);\n    }\n}\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n    return [\n        Math.round(r + (255 - r) * factor),\n        Math.round(g + (255 - g) * factor),\n        Math.round(b + (255 - b) * factor),\n        a,\n    ];\n}\n","import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n","export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n","import getViewportsForAnnotation from './getViewportsForAnnotation';\nexport default function getViewportForAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    return viewports.length ? viewports[0] : undefined;\n}\n","function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n","export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    const radius2 = sphere.radius2 || radius * radius;\n    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n        radius2);\n}\n","import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\nconst axisList = [iAxis, jAxis, kAxis];\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);\n    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);\n    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||\n        isEqual(angle, 90) ||\n        isEqual(angle, 180) ||\n        isEqual(angle, 270));\n    return isAligned;\n}\nfunction calculateAnglesWithAxes(vec, axes) {\n    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\nexport { isAxisAlignedRectangle };\n","import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n","import { cache, StackViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = utilities.getVolumeId(targetId);\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        return false;\n    }\n}\nexport { isViewportPreScaled };\n"],"names":["VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","state","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","Object","keys","forEach","cacheEntry","removeChild","element","enabledElement","getEnabledElement","viewportId","renderingEngineId","viewportElement","internalDivElement","querySelector","svgLayer","_getSvgLayer","svgNodeCacheForCanvas","bind","this","fn","svgDrawingHelper","annotationUID","circleUID","center","radius","options","dataId","color","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","assign","undefined","strokeWidth","svgNodeHash","existingCircleElement","attributes","cx","cy","r","stroke","newCircleElement","document","createElementNS","setAttribute","handleGroupUID","handlePoints","handle","i","linkUID","annotationAnchorPoints","refPoint","boundingBox","start","length","findClosestPoint","boundingBoxPoints","x","left","y","top","height","halfWidth","halfHeight","_boundingBoxPoints","end","mergedOptions","drawLine","textBoxUID","textLines","textBoxPosition","textBox","handleRadius","centering","canvasBoundingBox","drawTextBox","drawRect","rectangleUID","topLeft","topRight","bottomLeft","bottomRight","segmentationStyle","constructor","config","global","segmentations","viewportsStyle","setStyle","specifier","styles","segmentationId","type","segmentIndex","currentStyles","getStyle","updatedStyles","copyActiveToInactiveIfNotProvided","Error","renderInactiveSegmentations","representations","repConfig","perSegment","allSegments","ALL_SEGMENTATIONS_KEY","segConfig","processedStyles","Labelmap","labelmapStyles","renderOutlineInactive","renderOutline","outlineWidthInactive","outlineWidth","renderFillInactive","renderFill","fillAlphaInactive","fillAlpha","outlineOpacityInactive","outlineOpacity","Contour","contourStyles","outlineDashInactive","outlineDash","combinedStyle","getDefaultStyle","allSegmentationsKey","getRenderInactiveSegmentations","setRenderInactiveSegmentations","Surface","clearSegmentationStyle","clearAllSegmentationStyles","clearViewportStyle","clearAllViewportStyles","resetToGlobalStyle","hasCustomStyle","style","defaultStyle","utilities","triggerSegmentationDataModified","modifiedSlicesToUse","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_DATA_MODIFIED","getActiveSegmentation","getSegmentationRepresentationVisibility","data","segmentation","representationData","console","warn","getRenderingEngines","find","re","getViewports","vp","id","toolGroupFilteredByIds","toolGroups","filter","tg","viewportsInfo","some","PlanarFreehandContourSegmentationTool","toolName","toolProps","super","configuration","calculateStats","allowOpenContours","isContourSegmentationTool","renderAnnotationInstance","renderContext","annotation","invalidated","renderResult","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","defaultToolProps","supportedInteractionTypes","storePointData","shadow","preventHandleOutsideImage","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","enabled","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","displayOnePointAsCrosshairs","getTextLines","defaultGetTextLines","statsCalculator","BasicStatsCalculator","isDrawing","isEditingClosed","isEditingOpen","addNewAnnotation","evt","detail","createAnnotation","addAnnotation","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","activateDraw","preventDefault","handleSelectedCallback","activateOpenContourEndEdit","toolSelectedCallback","contour","closed","activateClosedContourEdit","activateOpenContourEdit","isPointNearTool","canvasCoords","proximity","viewport","points","previousPoint","worldToCanvas","p1","p2","pStart","pEnd","cancel","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","_calculateCachedStats","renderingEngine","cachedStats","targetIds","targetId","image","getTargetImageData","imageData","metadata","canvasCoordinates","map","p","modalityUnitOptions","isPreScaled","isSuvScaled","referencedImageId","modalityUnit","Modality","calibratedScale","numPoints","projectedPolyline","Array","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","canvasToWorld","topLeftBBIndex","bottomRightBBWorld","canvasPoint","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","updateClosedCachedStats","updateOpenCachedStats","triggerAnnotationModified","ChangeTypes","StatsUpdated","_renderStats","getTargetId","styleSpecifier","toolGroupId","getLinkedTextBoxStyle","visibility","handles","hasMoved","canvasTextBoxCoords","getTextBoxCoordsCanvas","worldPosition","drawLinkedTextBox","worldBoundingBox","_throttledCalculateCachedStats","trailing","filterInteractableAnnotationsForElement","annotations","annotationsToDisplay","VolumeViewport","camera","getCamera","spacingInNormalDirection","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","viewPlaneNormal","annotationsWithParallelNormals","td","annotationViewPlaneNormal","FrameOfReferenceUID","point","vector","focalPoint","dotProduct","cameraFocalPoint","imageOrientationPatient","metaData","rowCosineVec","colCosineVec","isParallel","Math","abs","halfSpacingInNormalDirection","annotationsWithinSlice","isVisible","dir","dot","push","worldPos","currentPoints","world","contourAnnotation","label","getAnnotationStyle","context","renderStatus","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","movingTextBox","unit","area","max","mean","stdDev","areaUnit","scale","voxelManager","getImageData","worldPosIndex","floor","iMin","iMax","jMin","jMax","kMin","kMax","j","min","worldPosIndex2","perimeter","sqrt","pow","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","indexToWorld","canvasPosEnd","pointsInShape","curRow","intersections","intersectionCounter","statsCallback","isInObject","pointLPS","_pointIJK","result","getLineSegmentIntersectionsCoordinates","sort","a","b","shift","returnPoints","stats","getStatistics","value","statsArray","array","cachedVolumeStats","isEmptyArea","areaLine","transformWorldToIndex","RectangleROITool","createAnnotationForViewport","editData","handleIndex","newAnnotation","_activateDraw","hideElementCursor","canvasPoint1","canvasPoint2","rect","_getRectangleImageCoordinates","highlighted","_activateModify","findIndex","_endCallback","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","doneEditMemo","isHandleOutsideImage","triggerAnnotationCompleted","_dragCallback","createMemo","deltaPoints","worldPosDelta","bottomLeftCanvas","bottomRightCanvas","topLeftCanvas","topRightCanvas","bottomLeftWorld","bottomRightWorld","topLeftWorld","topRightWorld","HandlesUpdated","isInteractingWithTool","addEventListener","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","removeEventListener","renderAnnotation","getRenderingEngine","viewUp","startsWith","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","getCurrentImageId","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","drawHandles","point0","point1","worldPos1","worldPos2","dimensions","pos1Index","pos2Index","_isInsideVolume","worldWidth","worldHeight","pixelUnitsOptions","index1","index2","hydrate","getEnabledElementByViewportId","instance","hydrateBase","toolInstance","serializableOptions","autoGenerated","isLocked","LabelmapBaseTool","previewData","preview","timerStart","timer","startPoint","NaN","isDrag","memoMap","Map","acceptedMemoIds","centerSegmentIndexInfo","hasSegmentIndex","hasPreviewIndex","changedIndices","_historyRedoHandler","operationType","has","_hoverData","memoData","get","operationData","getOperationData","applyActiveStrategyCallback","StrategyCallbacks","AcceptPreview","_previewData","segmentationVoxelManager","voxelManagerId","memo","redoVoxelManager","set","createEditData","activeSegmentation","event","CustomEvent","Enums","ERROR_EVENT","message","cancelable","dispatchEvent","segmentsLocked","getLockedSegmentIndices","getEditData","BaseVolumeViewport","volumeId","actors","getActors","StackViewport","volumes","actorEntry","cache","getVolume","referencedId","segmentationVolume","referencedVolumeIdToThreshold","volume","referencedVolumeId","threshold","segmentationImageId","imageId","createHoverData","centerCanvas","segmentColor","getActiveSegmentationData","brushCursor","getFrameOfReferenceUID","activeRepresentation","getSegmentIndexColor","_editData","configColor","previewColors","previewColor","previewSegmentIndex","g","factor","round","lightenColor","previewOnHover","activeStrategy","addPreview","acceptReject","acceptPreview","rejectPreview","results","AddPreview","RejectPreview","viewportContoursToLabelmap","removeContours","getAllAnnotations","viewAnnotations","contourAnnotations","strategies","FILL_INSIDE_CIRCLE","fillInsideCircle","previewVoxels","segmentationVoxels","sourceVoxelManager","getDefaultActor","actor","getMapper","getInputData","Infinity","worldToIndex","v","idx","bound","activeIndex","startIndex","startValue","getAtIJKPoint","hasZeroIndex","hasPositiveIndex","polyPoint","polyIndex","polyValue","k","worldPoint","isPointInsidePolyline3D","setAtIJK","removeAnnotation","slices","getArrayOfModifiedSlices","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","window","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","setTimeout","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","Number","Boolean","cancelAnimationFrame","clearTimeout","cancelTimer","flush","pending","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","bottom","_determineCorners","centerY","getViewportForAnnotation","viewports","pointInSphere","sphere","radius2","interpolateSegmentPoints","iniIndex","endIndex","knotsRatioPercentage","segmentSize","amountOfKnots","minKnotDistance","isNaN","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","slice","segmentPointsUnchangedEnd","knotsIndexes","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","getContinuousUniformDistributionValues","isEqual","axisList","isAxisAlignedRectangle","rectangleCornersIJK","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","every","angle","vec","axes","axis","PI","isViewportPreScaled","scaling","preScale","scaled"],"sourceRoot":""}