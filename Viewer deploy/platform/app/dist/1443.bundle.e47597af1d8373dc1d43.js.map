{"version":3,"file":"1443.bundle.e47597af1d8373dc1d43.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/toArray.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/codeMeaningEquals.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/CircleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/getDatasetsFromImages.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/compareArrays.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/checkOrientation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/checkIfPerpendicular.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/ParametricMap.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/copyStudyTags.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/copySeriesTags.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/constants/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/BaseAdapter3D.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CircleROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/EllipticalROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RectangleROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/PlanarFreehandROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Probe.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/UltrasoundDirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateLabelMaps2DFrom3D.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/compactMergeSegData.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/labelmapImagesFromBuffer.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateToolState.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/ParametricMap/generateToolState.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getReferencedFrameOfReferenceSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getReferencedSeriesSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getStructureSetModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/RTSS.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getRTROIObservationsSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getPatientModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getRTSeriesModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/KeyImage.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/VTKjs/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/VTKjs/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/downloadDICOMData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js","webpack:///../../../node_modules/iota-array/iota.js","webpack:///../../../node_modules/is-buffer/index.js","webpack:///../../../node_modules/ndarray/ndarray.js"],"sourcesContent":["const toArray = x => Array.isArray(x) ? x : [x];\n\nexport { toArray };\n","const codeMeaningEquals = codeMeaningName => {\n  return contentItem => {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n\nexport { codeMeaningEquals };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\n\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nconst codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\nfunction getTID300ContentItem(tool, ReferencedSOPSequence, adapterClass) {\n  const args = adapterClass.getTID300RepresentationArguments(tool);\n  args.ReferencedSOPSequence = ReferencedSOPSequence;\n  const TID300Measurement = new adapterClass.TID300Representation(args);\n  return TID300Measurement;\n}\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n  const toolTypeData = toolData[toolType];\n  const toolClass = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n  if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n    return;\n  }\n\n  // Loop through the array of tool instances\n  // for this tool\n  const Measurements = toolTypeData.data.map(tool => {\n    return getTID300ContentItem(tool, ReferencedSOPSequence, toolClass);\n  });\n  return new TID1501MeasurementGroup(Measurements);\n}\nclass MeasurementReport {\n  static getSetupMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const defaultState = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      complete: true,\n      finding: findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined,\n      findingSites: findingSiteGroups.map(fsg => {\n        return addAccessors(fsg.ConceptCodeSequence);\n      })\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    const findingSite = defaultState.findingSites && defaultState.findingSites[0];\n    if (findingSite) {\n      defaultState.location = findingSite[0] && findingSite[0].CodeMeaning || findingSite.CodeMeaning;\n    }\n    return {\n      defaultState,\n      findingGroup,\n      findingSiteGroups,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    };\n  }\n  static generateReport(toolState, metadataProvider, options) {\n    // ToolState for array of imageIDs to a Report\n    // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n    let allMeasurementGroups = [];\n    const firstImageId = Object.keys(toolState)[0];\n    if (!firstImageId) {\n      throw new Error(\"No measurements provided.\");\n    }\n\n    /* Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n     */\n    const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", firstImageId);\n\n    //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n    // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n    // which means that if the toolState is for multiple series, the report will have the incorrect\n    // SeriesInstanceUIDs\n    const {\n      studyInstanceUID,\n      seriesInstanceUID\n    } = generalSeriesModule;\n\n    // Loop through each image in the toolData\n    Object.keys(toolState).forEach(imageId => {\n      const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n      const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = {\n        ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n      };\n      if (Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)) {\n        ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n      }\n\n      // Loop through each tool type for the image\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = getMeasurementGroup(toolType, toolData, ReferencedSOPSequence);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n\n    // TODO: what is the correct metaheader\n    // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n    // TODO: move meta creation to happen in derivations.js\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const derivationSourceDataset = {\n      StudyInstanceUID: studyInstanceUID,\n      SeriesInstanceUID: seriesInstanceUID\n      //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n      //SOPClassUID: sopClassUID,\n    };\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      //MediaStorageSOPClassUID\n      //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        // TODO: could be git hash or other valid id\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    const _vrMap = {\n      PixelData: \"OW\"\n    };\n    derivationSourceDataset._meta = _meta;\n    derivationSourceDataset._vrMap = _vrMap;\n    const report = new StructuredReport([derivationSourceDataset]);\n    const contentItem = MeasurementReport.contentItem(derivationSourceDataset);\n\n    // Merge the derived dataset with the content from the Measurement Report\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    return report;\n  }\n\n  /**\n   * Generate Cornerstone tool state from dataset\n   * @param {object} dataset dataset\n   * @param {object} hooks\n   * @param {function} hooks.getToolClass Function to map dataset to a tool class\n   * @returns\n   */\n  static generateToolState(dataset) {\n    let hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // For now, bail out if the dataset is not a TID1500 SR with length measurements\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n    // Identify the Imaging Measurements\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n\n    // Retrieve the Measurements themselves\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n\n    // For each of the supported measurement types, compute the measurement data\n    const measurementData = {};\n    const cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n    const registeredToolClasses = [];\n    Object.keys(cornerstoneToolClasses).forEach(key => {\n      registeredToolClasses.push(cornerstoneToolClasses[key]);\n      measurementData[key] = [];\n    });\n    measurementGroups.forEach(measurementGroup => {\n      const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n      const TrackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n      const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n      const toolClass = hooks.getToolClass ? hooks.getToolClass(measurementGroup, dataset, registeredToolClasses) : registeredToolClasses.find(tc => tc.isValidCornerstoneTrackingIdentifier(TrackingIdentifierValue));\n      if (toolClass) {\n        const measurement = toolClass.getMeasurementData(measurementGroup);\n        console.log(`=== ${toolClass.toolType} ===`);\n        console.log(measurement);\n        measurementData[toolClass.toolType].push(measurement);\n      }\n    });\n\n    // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n    // That is up to the consumer to derive from the SOPInstanceUIDs.\n    return measurementData;\n  }\n  static registerTool(toolClass) {\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[toolClass.utilityToolType] = toolClass;\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolClass.toolType] = toolClass;\n    MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] = toolClass.utilityToolType;\n  }\n}\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\nexport { MeasurementReport as default };\n","var CORNERSTONE_4_TAG = \"cornerstoneTools@^4.0.0\";\n\nexport { CORNERSTONE_4_TAG as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      length: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Length.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const distance = tool.length;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === LENGTH;\n};\nMeasurementReport.registerTool(Length);\n\nexport { Length as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass FreehandRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: FreehandRoi.toolType,\n      handles: {\n        points: [],\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      state.handles.points.push({\n        x: GraphicData[i],\n        y: GraphicData[i + 1]\n      });\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites,\n      cachedStats = {}\n    } = tool;\n    const {\n      points\n    } = handles;\n    const {\n      area = 0,\n      perimeter = 0\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:FreehandRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === FreehandRoi.toolType;\n};\nMeasurementReport.registerTool(FreehandRoi);\n\nexport { FreehandRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\n\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\nclass Bidirectional {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const findingGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeValue === FINDING);\n    const findingSiteGroups = toArray(ContentSequence).filter(group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE);\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = longAxisSCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n\n    // Long axis\n\n    const longestDiameter = String(longAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const shortestDiameter = String(shortAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const bottomRight = {\n      x: Math.max(longAxisSCOORDGroup.GraphicData[0], longAxisSCOORDGroup.GraphicData[2], shortAxisSCOORDGroup.GraphicData[0], shortAxisSCOORDGroup.GraphicData[2]),\n      y: Math.max(longAxisSCOORDGroup.GraphicData[1], longAxisSCOORDGroup.GraphicData[3], shortAxisSCOORDGroup.GraphicData[1], shortAxisSCOORDGroup.GraphicData[3])\n    };\n    const state = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      toolType: Bidirectional.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: longAxisSCOORDGroup.GraphicData[0],\n          y: longAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 0\n        },\n        end: {\n          x: longAxisSCOORDGroup.GraphicData[2],\n          y: longAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 1\n        },\n        perpendicularStart: {\n          x: shortAxisSCOORDGroup.GraphicData[0],\n          y: shortAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 2\n        },\n        perpendicularEnd: {\n          x: shortAxisSCOORDGroup.GraphicData[2],\n          y: shortAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 3\n        },\n        textBox: {\n          highlight: false,\n          hasMoved: true,\n          active: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true,\n          x: bottomRight.x + 10,\n          y: bottomRight.y + 10\n        }\n      },\n      invalidated: false,\n      isCreating: false,\n      longestDiameter,\n      shortestDiameter,\n      toolName: \"Bidirectional\",\n      visible: true,\n      finding: findingGroup ? findingGroup.ConceptCodeSequence : undefined,\n      findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      start,\n      end,\n      perpendicularStart,\n      perpendicularEnd\n    } = tool.handles;\n    const {\n      shortestDiameter,\n      longestDiameter,\n      finding,\n      findingSites\n    } = tool;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Bidirectional\";\n    return {\n      longAxis: {\n        point1: start,\n        point2: end\n      },\n      shortAxis: {\n        point1: perpendicularStart,\n        point2: perpendicularEnd\n      },\n      longAxisLength: longestDiameter,\n      shortAxisLength: shortestDiameter,\n      trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === BIDIRECTIONAL;\n};\nMeasurementReport.registerTool(Bidirectional);\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst ELLIPTICALROI = \"EllipticalRoi\";\nclass EllipticalRoi {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const majorAxis = [{\n      x: GraphicData[0],\n      y: GraphicData[1]\n    }, {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    }];\n    const minorAxis = [{\n      x: GraphicData[4],\n      y: GraphicData[5]\n    }, {\n      x: GraphicData[6],\n      y: GraphicData[7]\n    }];\n\n    // Calculate two opposite corners of box defined by two axes.\n\n    const minorAxisLength = Math.sqrt(Math.pow(minorAxis[0].x - minorAxis[1].x, 2) + Math.pow(minorAxis[0].y - minorAxis[1].y, 2));\n    const minorAxisDirection = {\n      x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n      y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n    };\n    const halfMinorAxisLength = minorAxisLength / 2;\n\n    // First end point of major axis + half minor axis vector\n    const corner1 = {\n      x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n    };\n\n    // Second end point of major axis - half of minor axis vector\n    const corner2 = {\n      x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n    };\n    const state = {\n      ...defaultState,\n      toolType: EllipticalRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      handles: {\n        end: {\n          x: corner1.x,\n          y: corner1.y,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          x: corner2.x,\n          y: corner2.y,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const {\n      area\n    } = cachedStats;\n    const halfXLength = Math.abs(start.x - end.x) / 2;\n    const halfYLength = Math.abs(start.y - end.y) / 2;\n    const points = [];\n    const center = {\n      x: (start.x + end.x) / 2,\n      y: (start.y + end.y) / 2\n    };\n    if (halfXLength > halfYLength) {\n      // X-axis major\n      // Major axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n      // Minor axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n    } else {\n      // Y-axis major\n      // Major axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n      // Minor axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n    }\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ELLIPTICALROI;\n};\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport { EllipticalRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nconst CIRCLEROI = \"CircleRoi\";\nclass CircleRoi {\n  /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const center = {\n      x: GraphicData[0],\n      y: GraphicData[1]\n    };\n    const end = {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    };\n    const state = {\n      ...defaultState,\n      toolType: CircleRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n        // Dummy values to be updated by cornerstone\n        radius: 0,\n        perimeter: 0\n      },\n      handles: {\n        end: {\n          ...end,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          ...center,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n\n  /**\n   * Gets the TID 300 representation of a circle, given the cornerstone representation.\n   *\n   * @param {Object} tool\n   * @returns\n   */\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start: center,\n      end\n    } = handles;\n    const {\n      area,\n      radius\n    } = cachedStats;\n    const perimeter = 2 * Math.PI * radius;\n    const points = [];\n    points.push(center);\n    points.push(end);\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === CIRCLEROI;\n};\nMeasurementReport.registerTool(CircleRoi);\n\nexport { CircleRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\nclass ArrowAnnotate {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      findingGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const text = findingGroup.ConceptCodeSequence.CodeMeaning;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const state = {\n      ...defaultState,\n      toolType: ArrowAnnotate.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: GraphicData[0],\n          y: GraphicData[1],\n          highlight: true,\n          active: false\n        },\n        // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n        // use the actual endpoint.\n        end: {\n          x: GraphicData.length == 4 ? GraphicData[2] : GraphicData[0] + 20,\n          y: GraphicData.length == 4 ? GraphicData[3] : GraphicData[1] + 20,\n          highlight: true,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      text,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const points = [tool.handles.start, tool.handles.end];\n    const {\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const TID300RepresentationArguments = {\n      points,\n      trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n      findingSites: findingSites || []\n    };\n\n    // If freetext finding isn't present, add it from the tool text.\n    if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: \"CST4\",\n        CodeMeaning: tool.text\n      };\n    }\n    TID300RepresentationArguments.finding = finding;\n    return TID300RepresentationArguments;\n  }\n}\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ARROW_ANNOTATE;\n};\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nconst COBB_ANGLE = \"CobbAngle\";\nclass CobbAngle {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: CobbAngle.toolType,\n      handles: {\n        start: {},\n        end: {},\n        start2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        end2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y, state.handles.start2.x, state.handles.start2.y, state.handles.end2.x, state.handles.end2.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const point3 = handles.start2;\n    const point4 = handles.end2;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === COBB_ANGLE;\n};\nMeasurementReport.registerTool(CobbAngle);\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Angle: TID300Angle\n} = utilities.TID300;\nconst ANGLE = \"Angle\";\nclass Angle {\n  /**\n   * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n   */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Angle.toolType,\n      handles: {\n        start: {},\n        middle: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.middle.x, state.handles.middle.y, state.handles.middle.x, state.handles.middle.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.middle;\n    const point3 = handles.middle;\n    const point4 = handles.end;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ANGLE;\n};\nMeasurementReport.registerTool(Angle);\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: RectangleRoi.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        },\n        initialRotation: 0\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const intermediate = {};\n    [state.handles.start.x, state.handles.start.y, intermediate.x, intermediate.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      finding,\n      findingSites,\n      cachedStats = {},\n      handles\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const points = [start, {\n      x: start.x,\n      y: end.y\n    }, end, {\n      x: end.x,\n      y: start.y\n    }];\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:RectangleRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === RectangleRoi.toolType;\n};\nMeasurementReport.registerTool(RectangleRoi);\n\nexport { RectangleRoi as default };\n","import { data, normalizers } from 'dcmjs';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nfunction getDatasetsFromImages(images, isMultiframe, options) {\n  const datasets = [];\n  if (isMultiframe) {\n    const image = images[0];\n    const arrayBuffer = image.data.byteArray.buffer;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    datasets.push(dataset);\n  } else {\n    for (let i = 0; i < images.length; i++) {\n      const image = images[i];\n      const arrayBuffer = image.data.byteArray.buffer;\n      const dicomData = DicomMessage.readFile(arrayBuffer);\n      const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n      dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n      datasets.push(dataset);\n    }\n  }\n  if (options?.SpecificCharacterSet) {\n    datasets.forEach(dataset => dataset.SpecificCharacterSet = options.SpecificCharacterSet);\n  }\n  return Normalizer.normalizeToDataset(datasets);\n}\n\nexport { getDatasetsFromImages as default };\n","import { utilities, log, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  datasetToBlob,\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = utilities;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState\n};\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(images, brushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  const {\n    toolState,\n    segments\n  } = brushData;\n\n  // Calculate the dimensions of the data cube.\n  const image0 = images[0];\n  const dims = {\n    x: image0.columns,\n    y: image0.rows,\n    z: images.length\n  };\n  dims.xy = dims.x * dims.y;\n  const numSegments = _getSegCount(seg, segments);\n  if (!numSegments) {\n    throw new Error(\"No segments to export!\");\n  }\n  const isMultiframe = image0.imageId.includes(\"?frame\");\n  const seg = _createSegFromImages(images, isMultiframe, options);\n  const {\n    referencedFramesPerSegment,\n    segmentIndicies\n  } = _getNumberOfFramesPerSegment(toolState, images, segments);\n  let NumberOfFrames = 0;\n  for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n    NumberOfFrames += referencedFramesPerSegment[i].length;\n  }\n  seg.setNumberOfFrames(NumberOfFrames);\n  for (let i = 0; i < segmentIndicies.length; i++) {\n    const segmentIndex = segmentIndicies[i];\n    const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n    // Frame numbers start from 1.\n    const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n      return element + 1;\n    });\n    const segment = segments[segmentIndex];\n    seg.addSegment(segment, _extractCornerstoneToolsPixelData(segmentIndex, referencedFrameIndicies, toolState, images, dims), referencedFrameNumbers);\n  }\n  seg.bitPackPixelData();\n  const segBlob = datasetToBlob(seg.dataset);\n  return segBlob;\n}\nfunction _extractCornerstoneToolsPixelData(segmentIndex, referencedFrames, toolState, images, dims) {\n  const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n  let pixelDataIndex = 0;\n  for (let i = 0; i < referencedFrames.length; i++) {\n    const frame = referencedFrames[i];\n    const imageId = images[frame].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    const brushPixelData = imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n    for (let p = 0; p < brushPixelData.length; p++) {\n      pixelData[pixelDataIndex] = brushPixelData[p];\n      pixelDataIndex++;\n    }\n  }\n  return pixelData;\n}\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n  const segmentIndicies = [];\n  const referencedFramesPerSegment = [];\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      segmentIndicies.push(i);\n      referencedFramesPerSegment.push([]);\n    }\n  }\n  for (let z = 0; z < images.length; z++) {\n    const imageId = images[z].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    for (let i = 0; i < segmentIndicies.length; i++) {\n      const segIdx = segmentIndicies[i];\n      if (imageIdSpecificToolState && imageIdSpecificToolState.brush && imageIdSpecificToolState.brush.data && imageIdSpecificToolState.brush.data[segIdx] && imageIdSpecificToolState.brush.data[segIdx].pixelData) {\n        referencedFramesPerSegment[i].push(z);\n      }\n    }\n  }\n  return {\n    referencedFramesPerSegment,\n    segmentIndicies\n  };\n}\nfunction _getSegCount(seg, segments) {\n  let numSegments = 0;\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      numSegments++;\n    }\n  }\n  return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe);\n  const pixelData = unpackPixelData(multiframe);\n  const PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence;\n  const toolState = {};\n  let inPlane = true;\n  for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n    const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n    const pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength), [multiframe.Rows, multiframe.Columns]);\n    const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations);\n    if (!alignedPixelDataI) {\n      console.warn(\"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \");\n      inPlane = false;\n      break;\n    }\n    const segmentIndex = PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber - 1;\n    let SourceImageSequence;\n    if (SharedFunctionalGroupsSequence.DerivationImageSequence && SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence) {\n      SourceImageSequence = SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence[i];\n    } else {\n      SourceImageSequence = PerFrameFunctionalGroups.DerivationImageSequence.SourceImageSequence;\n    }\n    const imageId = getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider);\n    addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, alignedPixelDataI);\n  }\n  if (!inPlane) {\n    return;\n  }\n  return {\n    toolState,\n    segMetadata\n  };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n  const segType = multiframe.SegmentationType;\n  if (segType === \"BINARY\") {\n    return BitArray.unpack(multiframe.PixelData);\n  }\n  const pixelData = new Uint8Array(multiframe.PixelData);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    log.warn(\"This is a fractional segmentation, which is not currently supported.\");\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, pixelData2D) {\n  if (!toolState[imageId]) {\n    toolState[imageId] = {};\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush) {\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush.data) {\n    toolState[imageId].brush.data = [];\n  }\n  toolState[imageId].brush.data[segmentIndex] = {};\n  const brushDataI = toolState[imageId].brush.data[segmentIndex];\n  brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n  const cToolsPixelData = brushDataI.pixelData;\n  for (let p = 0; p < cToolsPixelData.length; p++) {\n    if (pixelData2D.data[p]) {\n      cToolsPixelData[p] = 1;\n    } else {\n      cToolsPixelData[p] = 0;\n    }\n  }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, imageIds, metadataProvider) : getImageIdOfReferencedSingleFramedSOPInstance(ReferencedSOPInstanceUID, imageIds, metadataProvider);\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(sopInstanceUid, imageIds, metadataProvider) {\n  return imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    return sopCommonModule.sopInstanceUID === sopInstanceUid;\n  });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, imageIds, metadataProvider) {\n  const imageId = imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n    return (\n      //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n      sopCommonModule.sopInstanceUID === sopInstanceUid && imageIdFrameNumber === frameNumber - 1\n    );\n  });\n  return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n  if (compareIOP(iop, orientations[0])) {\n    //Same orientation.\n    return pixelData2D;\n  } else if (compareIOP(iop, orientations[1])) {\n    //Flipped vertically.\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareIOP(iop, orientations[2])) {\n    //Flipped horizontally.\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareIOP(iop, orientations[3])) {\n    //Rotated 90 degrees.\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareIOP(iop, orientations[4])) {\n    //Rotated 90 degrees and fliped horizontally.\n    return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[5])) {\n    //Rotated 90 degrees and fliped vertically.\n    return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[6])) {\n    //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[7])) {\n    //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n  return Math.abs(iop1[0] - iop2[0]) < dx && Math.abs(iop1[1] - iop2[1]) < dx && Math.abs(iop1[2] - iop2[2]) < dx && Math.abs(iop1[3] - iop2[3]) < dx && Math.abs(iop1[4] - iop2[4]) < dx && Math.abs(iop1[5] - iop2[5]) < dx;\n}\nfunction getSegmentMetadata(multiframe) {\n  const data = [];\n  const segmentSequence = multiframe.SegmentSequence;\n  if (Array.isArray(segmentSequence)) {\n    for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n      data.push(segmentSequence[segIdx]);\n    }\n  } else {\n    // Only one segment, will be stored as an object.\n    data.push(segmentSequence);\n  }\n  return {\n    seriesInstanceUid: multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n    data\n  };\n}\n\nexport { Segmentation as default };\n","import { utilities } from 'dcmjs';\n\nconst {\n  nearlyEqual\n} = utilities.orientation;\nfunction compareArrays(array1, array2, tolerance) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; ++i) {\n    if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { compareArrays as default };\n","import checkIfPerpendicular from './checkIfPerpendicular.js';\nimport compareArrays from './compareArrays.js';\n\nfunction checkOrientation(multiframe, validOrientations, sourceDataDimensions, tolerance) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n  const iop = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const inPlane = validOrientations.some(operation => compareArrays(iop, operation, tolerance));\n  if (inPlane) {\n    return \"Planar\";\n  }\n  if (checkIfPerpendicular(iop, validOrientations[0], tolerance) && sourceDataDimensions.includes(multiframe.Rows) && sourceDataDimensions.includes(multiframe.Columns)) {\n    return \"Perpendicular\";\n  }\n  return \"Oblique\";\n}\n\nexport { checkOrientation as default };\n","function checkIfPerpendicular(iop1, iop2, tolerance) {\n  const absDotColumnCosines = Math.abs(iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]);\n  const absDotRowCosines = Math.abs(iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]);\n  return (absDotColumnCosines < tolerance || Math.abs(absDotColumnCosines - 1) < tolerance) && (absDotRowCosines < tolerance || Math.abs(absDotRowCosines - 1) < tolerance);\n}\n\nexport { checkIfPerpendicular as default };\n","var Events;\n(function (Events) {\n  Events[\"SEGMENTATION_LOAD_PROGRESS\"] = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\";\n})(Events || (Events = {}));\n\nexport { Events };\n","import { utilities, log, data, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport compareArrays from '../helpers/compareArrays.js';\nimport { Events } from '../enums/Events.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst {\n  encode,\n  decode\n} = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n  includeSliceSpacing: true,\n  rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const isMultiframe = isMultiframeImage(images[0]);\n  const segmentation = _createSegFromImages(images, isMultiframe, userOptions);\n  return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * Fills a given segmentation object with data from the input labelmaps3D\n *\n * @param segmentation - The segmentation object to be filled.\n * @param inputLabelmaps3D - An array of 3D labelmaps, or a single 3D labelmap.\n * @param userOptions - Optional configuration settings. Will override the default options.\n *\n * @returns {object} The filled segmentation object.\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = Object.assign({}, generateSegmentationDefaultOptions, userOptions);\n\n  // Use another variable so we don't redefine labelmaps3D.\n  const labelmaps3D = Array.isArray(inputLabelmaps3D) ? inputLabelmaps3D : [inputLabelmaps3D];\n  let numberOfFrames = 0;\n  const referencedFramesPerLabelmap = [];\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      labelmaps2D,\n      metadata\n    } = labelmap3D;\n    const referencedFramesPerSegment = [];\n    for (let i = 1; i < metadata.length; i++) {\n      if (metadata[i]) {\n        referencedFramesPerSegment[i] = [];\n      }\n    }\n    for (let i = 0; i < labelmaps2D.length; i++) {\n      const labelmap2D = labelmaps2D[i];\n      if (labelmaps2D[i]) {\n        const {\n          segmentsOnLabelmap\n        } = labelmap2D;\n        segmentsOnLabelmap.forEach(segmentIndex => {\n          if (segmentIndex !== 0) {\n            referencedFramesPerSegment[segmentIndex].push(i);\n            numberOfFrames++;\n          }\n        });\n      }\n    }\n    referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n  }\n  segmentation.setNumberOfFrames(numberOfFrames);\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const referencedFramesPerSegment = referencedFramesPerLabelmap[labelmapIndex];\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      metadata\n    } = labelmap3D;\n    for (let segmentIndex = 1; segmentIndex < referencedFramesPerSegment.length; segmentIndex++) {\n      const referencedFrameIndicies = referencedFramesPerSegment[segmentIndex];\n      if (referencedFrameIndicies) {\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n          return element + 1;\n        });\n        const segmentMetadata = metadata[segmentIndex];\n        const labelmaps = _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies);\n        segmentation.addSegmentFromLabelmap(segmentMetadata, labelmaps, segmentIndex, referencedFrameNumbers);\n      }\n    }\n  }\n  if (options.rleEncode) {\n    const rleEncodedFrames = encode(segmentation.dataset.PixelData, numberOfFrames, segmentation.dataset.Rows, segmentation.dataset.Columns);\n\n    // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n    // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n    // added to the standard.\n    segmentation.assignToDataset({\n      BitsAllocated: \"8\",\n      BitsStored: \"8\",\n      HighBit: \"7\",\n      SegmentationType: \"FRACTIONAL\",\n      SegmentationFractionalType: \"PROBABILITY\",\n      MaximumFractionalValue: \"255\"\n    });\n    segmentation.dataset._meta.TransferSyntaxUID = {\n      Value: [\"1.2.840.10008.1.2.5\"],\n      vr: \"UI\"\n    };\n    segmentation.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    segmentation.dataset._vrMap.PixelData = \"OB\";\n    segmentation.dataset.PixelData = rleEncodedFrames;\n  } else {\n    // If no rleEncoding, at least bitpack the data.\n    segmentation.bitPackPixelData();\n  }\n  return segmentation;\n}\nfunction _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies) {\n  const {\n    labelmaps2D\n  } = labelmap3D;\n  const labelmaps = [];\n  for (let i = 0; i < referencedFrameIndicies.length; i++) {\n    const frame = referencedFrameIndicies[i];\n    labelmaps.push(labelmaps2D[frame].pixelData);\n  }\n  return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} referencedImageIds - An array for referenced image imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000,\n    eventTarget = null,\n    triggerEvent = null\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bitbacking.\");\n      return;\n    }\n\n    // Todo: need to test this with rle data\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n\n  // Pre-compute the sop UID to imageId index map so that in the for loop\n  // we don't have to call metadataProvider.get() for each imageId over\n  // and over again.\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let overlapping = false;\n  if (!skipOverlapping) {\n    overlapping = checkSEGsOverlapping(pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap);\n  }\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      if (overlapping) {\n        insertFunction = insertOverlappingPixelDataPlanar;\n      } else {\n        insertFunction = insertPixelDataPlanar;\n      }\n      break;\n    case \"Perpendicular\":\n      //insertFunction = insertPixelDataPerpendicular;\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n\n  /* if SEGs are overlapping:\n  1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n  2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n  3) insertFunction will return the number of LabelMaps\n  4) generateToolState return is an array*/\n\n  const segmentsOnFrameArray = [];\n  segmentsOnFrameArray[0] = [];\n  const segmentsOnFrame = [];\n  const arrayBufferLength = sliceLength * referencedImageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  const labelmapBufferArray = [];\n  labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n  // Pre-compute the indices and metadata so that we don't have to call\n  // a function for each imageId in the for loop.\n  const imageIdMaps = referencedImageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n\n  // This is the centroid calculation for each segment Index, the data structure\n  // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n  // later on we will use this data structure to calculate the centroid of the\n  // segment in the labelmapBuffer\n  const segmentsPixelIndices = new Map();\n  const overlappingSegments = await insertFunction(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent);\n\n  // calculate the centroid of each segment\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelmapBufferArray,\n    segMetadata,\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    centroids: centroidXYZ,\n    overlappingSegments\n  };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    SegmentSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  let numberOfSegs = SegmentSequence.length;\n  if (numberOfSegs < 2) {\n    return false;\n  }\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n  /** sort groupsLen to have all the segments for each frame in an array\n   * frame 2 : 1, 2\n   * frame 4 : 1, 3\n   * frame 5 : 4\n   */\n\n  let frameSegmentsMapping = new Map();\n  for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n    const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n    if (segmentIndex === undefined) {\n      console.warn(\"Could not retrieve the segment index for frame segment \" + frameSegment + \", skipping this frame.\");\n      continue;\n    }\n    const imageId = findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + frameSegment + \".\");\n      continue;\n    }\n    const imageIdIndex = imageIds.findIndex(element => element === imageId);\n    if (frameSegmentsMapping.has(imageIdIndex)) {\n      let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n      if (!segmentArray.includes(frameSegment)) {\n        segmentArray.push(frameSegment);\n        frameSegmentsMapping.set(imageIdIndex, segmentArray);\n      }\n    } else {\n      frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n    }\n  }\n  for (let [, role] of frameSegmentsMapping.entries()) {\n    let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n    for (let i = 0; i < role.length; ++i) {\n      const frameSegment = role[i];\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frameSegment];\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n      const view = readFromUnpackedChunks(pixelData, frameSegment * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        console.warn(\"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\");\n        continue;\n      }\n      const data = alignedPixelDataI.data;\n      for (let j = 0, len = data.length; j < len; ++j) {\n        if (data[j] !== 0) {\n          temp2DArray[j]++;\n          if (temp2DArray[j] > 1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction insertOverlappingPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayBufferLength = sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  // indicate the number of labelMaps\n  let M = 1;\n\n  // indicate the current labelMap array index;\n  let m = 0;\n\n  // temp array for checking overlaps\n  let tempBuffer = labelmapBufferArray[m].slice(0);\n\n  // temp list for checking overlaps\n  let tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n\n  /** split overlapping SEGs algorithm for each segment:\n   *  A) copy the labelmapBuffer in the array with index 0\n   *  B) add the segment pixel per pixel on the copied buffer from (A)\n   *  C) if no overlap, copy the results back on the orignal array from (A)\n   *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n   */\n\n  let numberOfSegs = multiframe.SegmentSequence.length;\n  for (let segmentIndexToProcess = 1; segmentIndexToProcess <= numberOfSegs; ++segmentIndexToProcess) {\n    for (let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length; i < groupsLen; ++i) {\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n      const segmentIndex = getSegmentIndex(multiframe, i);\n      if (segmentIndex === undefined) {\n        throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n      }\n      if (segmentIndex !== segmentIndexToProcess) {\n        continue;\n      }\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n\n      // Since we moved to the chunks approach, we need to read the data\n      // and handle scenarios where the portion of data is in one chunk\n      // and the other portion is in another chunk\n      const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n      }\n      const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n      if (!imageId) {\n        console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n        continue;\n      }\n      const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n      if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n        throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n      }\n      const imageIdIndex = imageIds.findIndex(element => element === imageId);\n      const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n      const labelmap2DView = new TypedArrayConstructor(tempBuffer, byteOffset, sliceLength);\n      const data = alignedPixelDataI.data;\n      let segmentOnFrame = false;\n      for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n        if (data[j]) {\n          if (labelmap2DView[j] !== 0) {\n            m++;\n            if (m >= M) {\n              labelmapBufferArray[m] = new ArrayBuffer(arrayBufferLength);\n              segmentsOnFrameArray[m] = [];\n              M++;\n            }\n            tempBuffer = labelmapBufferArray[m].slice(0);\n            tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n            i = 0;\n            break;\n          } else {\n            labelmap2DView[j] = segmentIndex;\n            segmentOnFrame = true;\n          }\n        }\n      }\n      if (segmentOnFrame) {\n        if (!tempSegmentsOnFrame[imageIdIndex]) {\n          tempSegmentsOnFrame[imageIdIndex] = [];\n        }\n        tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n        if (!segmentsOnFrame[imageIdIndex]) {\n          segmentsOnFrame[imageIdIndex] = [];\n        }\n        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n      }\n    }\n    labelmapBufferArray[m] = tempBuffer.slice(0);\n    segmentsOnFrameArray[m] = structuredClone(tempSegmentsOnFrame);\n\n    // reset temp variables/buffers for new segment\n    m = 0;\n    tempBuffer = labelmapBufferArray[m].slice(0);\n    tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n  }\n}\nconst getSegmentIndex = (multiframe, frame) => {\n  const {\n    PerFrameFunctionalGroupsSequence,\n    SharedFunctionalGroupsSequence\n  } = multiframe;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n  return PerFrameFunctionalGroups && PerFrameFunctionalGroups.SegmentIdentificationSequence ? PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber : SharedFunctionalGroupsSequence.SegmentIdentificationSequence ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence.ReferencedSegmentNumber : undefined;\n};\nfunction insertPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  let i = 0;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n  const shouldTriggerEvent = triggerEvent && eventTarget;\n  let overlapping = false;\n  // Below, we chunk the processing of the frames to avoid blocking the main thread\n  // if the segmentation is large. We also use a promise to allow the caller to\n  // wait for the processing to finish.\n  return new Promise(resolve => {\n    function processInChunks() {\n      // process one chunk\n      for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          continue;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n        const labelmap2DView = new TypedArrayConstructor(labelmapBufferArray[0], byteOffset, sliceLength);\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n          if (data[j]) {\n            for (let x = j; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n\n      // trigger an event after each chunk\n      if (shouldTriggerEvent) {\n        const percentComplete = Math.round(i / groupsLen * 100);\n        triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n          percentComplete\n        });\n      }\n\n      // schedule next chunk\n      if (i < groupsLen) {\n        setTimeout(processInChunks, 0);\n      } else {\n        // resolve the Promise when all chunks have been processed\n        resolve(overlapping);\n      }\n    }\n    processInChunks();\n  });\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n  const segType = multiframe.SegmentationType;\n  let data;\n  if (Array.isArray(multiframe.PixelData)) {\n    data = multiframe.PixelData[0];\n  } else {\n    data = multiframe.PixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This segmentation pixelData is undefined.\");\n  }\n  if (segType === \"BINARY\") {\n    // For extreme big data, we can't unpack the data at once and we need to\n    // chunk it and unpack each chunk separately.\n    // MAX 2GB is the limit right now to allocate a buffer\n    return getUnpackedChunks(data, options.maxBytesPerChunk);\n  }\n  if (segType === \"LABELMAP\") {\n    // For LABELMAP, we can return the data as is, since it is already in a\n    // format that Cornerstone can handle. Also here we are returning the\n    // whole data at once, since the storage is more efficent than BINARY mode\n    if (multiframe.BitsStored === 8) {\n      return new Uint8Array(data);\n    } else if (multiframe.BitsStored === 16) {\n      return new Uint16Array(data);\n    } else {\n      return new Uint8Array(data);\n    }\n  }\n  const pixelData = new Uint8Array(data);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    // This is a fractional segmentation, which is not currently supported.\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n  var bitArray = new Uint8Array(data);\n  var chunks = [];\n  var maxBitsPerChunk = maxBytesPerChunk * 8;\n  var numberOfChunks = Math.ceil(bitArray.length * 8 / maxBitsPerChunk);\n  for (var i = 0; i < numberOfChunks; i++) {\n    var startBit = i * maxBitsPerChunk;\n    var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n    var startByte = Math.floor(startBit / 8);\n    var endByte = Math.ceil(endBit / 8);\n    var chunk = bitArray.slice(startByte, endByte);\n    var unpackedChunk = BitArray.unpack(chunk);\n    chunks.push(unpackedChunk);\n  }\n  return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  const baseImageId = sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n  if (!baseImageId) {\n    console.warn(`No imageId found for SOPInstanceUID: ${ReferencedSOPInstanceUID}`);\n    return undefined;\n  }\n  if (ReferencedFrameNumber !== undefined) {\n    if (baseImageId.includes(\"frames/\")) {\n      return baseImageId.replace(/frames\\/\\d+/, `frames/${ReferencedFrameNumber}`);\n    } else if (baseImageId.includes(\"frame=\")) {\n      return baseImageId.replace(/frame=\\d+/, `frame=${ReferencedFrameNumber - 1}`);\n    } else {\n      if (baseImageId.includes(\"wadors:\")) {\n        return `${baseImageId}/frames/${ReferencedFrameNumber}`;\n      } else {\n        return `${baseImageId}?frame=${ReferencedFrameNumber - 1}`;\n      }\n    }\n  }\n  return baseImageId;\n}\n\n/**\n * Determines if an image is a multiframe image based on its metadata.\n *\n * @param {Object} imageMetadata - The metadata object for the image\n * @param {number} [imageMetadata.NumberOfFrames] - The number of frames in the image\n * @returns {boolean} True if the image is a multiframe image (NumberOfFrames > 1)\n */\nfunction isMultiframeImage(imageMetadata) {\n  return imageMetadata && imageMetadata.NumberOfFrames > 1;\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (!ReferencedSeriesInstanceUID || !PerFrameFunctionalGroup.PlanePositionSequence?.[0]?.ImagePositionPatient) {\n    return undefined;\n  }\n  const segFramePosition = PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient;\n  for (let imageId of imageIds) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n    if (!sourceImageMetadata) {\n      continue;\n    }\n    const isMultiframe = isMultiframeImage(sourceImageMetadata);\n    if (!sourceImageMetadata.ImagePositionPatient || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n\n    // For multiframe images, check each frame's position\n    if (isMultiframe) {\n      const framePosition = metadataProvider.get(\"imagePlaneModule\", imageId)?.imagePositionPatient;\n      if (framePosition && compareArrays(segFramePosition, framePosition, tolerance)) {\n        return imageId;\n      }\n    } else if (compareArrays(segFramePosition, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageId;\n    }\n  }\n  return undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations, tolerance) {\n  if (compareArrays(iop, orientations[0], tolerance)) {\n    return pixelData2D;\n  } else if (compareArrays(iop, orientations[1], tolerance)) {\n    // Flipped vertically.\n\n    // Undo Flip\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareArrays(iop, orientations[2], tolerance)) {\n    // Flipped horizontally.\n\n    // Unfo flip\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareArrays(iop, orientations[3], tolerance)) {\n    //Rotated 90 degrees\n\n    // Rotate back\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareArrays(iop, orientations[4], tolerance)) {\n    //Rotated 90 degrees and fliped horizontally.\n\n    // Undo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n  } else if (compareArrays(iop, orientations[5], tolerance)) {\n    // Rotated 90 degrees and fliped vertically\n\n    // Unfo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n  } else if (compareArrays(iop, orientations[6], tolerance)) {\n    // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareArrays(iop, orientations[7], tolerance)) {\n    // Rotated 270 degrees\n\n    // Rotate back.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n  const segmentSequence = multiframe.SegmentSequence;\n  let data = [];\n  if (Array.isArray(segmentSequence)) {\n    data = [undefined, ...segmentSequence];\n  } else {\n    // Only one segment, will be stored as an object.\n    data = [undefined, segmentSequence];\n  }\n  return {\n    seriesInstanceUid,\n    data\n  };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n  const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n  // If all the data is in one chunk, we can just slice that chunk\n  if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n    return new Uint8Array(chunks[mapping.start.chunkIndex].buffer, mapping.start.offset, length);\n  } else {\n    // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n    let result = new Uint8Array(length);\n    let resultOffset = 0;\n    for (let i = mapping.start.chunkIndex; i <= mapping.end.chunkIndex; i++) {\n      let start = i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n      let end = i === mapping.end.chunkIndex ? mapping.end.offset : chunks[i].length;\n      result.set(new Uint8Array(chunks[i].buffer, start, end - start), resultOffset);\n      resultOffset += end - start;\n    }\n    return result;\n  }\n}\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n  var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n  if (offset < 0 || offset + length > totalBytes) {\n    throw new Error(\"Offset and length out of bounds\");\n  }\n  var startChunkIndex = 0;\n  var startOffsetInChunk = offset;\n  while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n    startOffsetInChunk -= chunks[startChunkIndex].length;\n    startChunkIndex++;\n  }\n  var endChunkIndex = startChunkIndex;\n  var endOffsetInChunk = startOffsetInChunk + length;\n  while (endOffsetInChunk > chunks[endChunkIndex].length) {\n    endOffsetInChunk -= chunks[endChunkIndex].length;\n    endChunkIndex++;\n  }\n  return {\n    start: {\n      chunkIndex: startChunkIndex,\n      offset: startOffsetInChunk\n    },\n    end: {\n      chunkIndex: endChunkIndex,\n      offset: endOffsetInChunk\n    }\n  };\n}\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, imageIds) {\n  let xAcc = 0;\n  let yAcc = 0;\n  let zAcc = 0;\n  let worldXAcc = 0;\n  let worldYAcc = 0;\n  let worldZAcc = 0;\n  let count = 0;\n  for (const [imageIdIndex, bufferIndices] of Object.entries(imageIdIndexBufferIndex)) {\n    const z = Number(imageIdIndex);\n    if (!bufferIndices || bufferIndices.length === 0) {\n      continue;\n    }\n\n    // Get metadata for this slice\n    const imageId = imageIds[z];\n    const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageId);\n    if (!imagePlaneModule) {\n      console.debug(\"Missing imagePlaneModule metadata for centroid calculation\");\n      continue;\n    }\n    const {\n      imagePositionPatient,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing\n    } = imagePlaneModule;\n    for (const bufferIndex of bufferIndices) {\n      const y = Math.floor(bufferIndex / multiframe.Rows);\n      const x = bufferIndex % multiframe.Rows;\n\n      // Image coordinates\n      xAcc += x;\n      yAcc += y;\n      zAcc += z;\n\n      // Calculate world coordinates\n      // P(world) = P(image) * IOP * spacing + IPP\n      const worldX = imagePositionPatient[0] + x * rowCosines[0] * columnPixelSpacing + y * columnCosines[0] * rowPixelSpacing;\n      const worldY = imagePositionPatient[1] + x * rowCosines[1] * columnPixelSpacing + y * columnCosines[1] * rowPixelSpacing;\n      const worldZ = imagePositionPatient[2] + x * rowCosines[2] * columnPixelSpacing + y * columnCosines[2] * rowPixelSpacing;\n      worldXAcc += worldX;\n      worldYAcc += worldY;\n      worldZAcc += worldZ;\n      count++;\n    }\n  }\n  return {\n    image: {\n      x: Math.floor(xAcc / count),\n      y: Math.floor(yAcc / count),\n      z: Math.floor(zAcc / count)\n    },\n    world: {\n      x: worldXAcc / count,\n      y: worldYAcc / count,\n      z: worldZAcc / count\n    },\n    count\n  };\n}\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState,\n  fillSegmentation\n};\n\nexport { _createSegFromImages, _getLabelmapsFromReferencedFrameIndicies, alignPixelDataWithSourceData, calculateCentroid, checkSEGsOverlapping, Segmentation as default, fillSegmentation, findReferenceSourceImageId, generateSegmentation, generateToolState, getImageIdOfSourceImageBySourceImageSequence, getImageIdOfSourceImagebyGeometry, getSegmentIndex, getSegmentMetadata, getUnpackedChunks, getUnpackedOffsetAndLength, getValidOrientations, insertOverlappingPixelDataPlanar, insertPixelDataPlanar, readFromUnpackedChunks, unpackPixelData };\n","import Segmentation$1 from './Segmentation_3X.js';\nimport Segmentation from './Segmentation_4X.js';\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(images, labelmaps3DorBrushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {boolean} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cornerstoneToolsVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateToolState(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateToolState(imageIds, arrayBuffer, metadataProvider);\n  }\n  console.warn(`No generateToolState adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.fillSegmentation(segmentation, inputLabelmaps3D, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import { log, data, normalizers } from 'dcmjs';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport compareArrays from '../helpers/compareArrays.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nasync function generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-3;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = [ImageOrientationPatient];\n  const pixelData = getPixelData(multiframe);\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  if (orientation !== \"Planar\") {\n    const orientationText = {\n      Perpendicular: \"orthogonal\",\n      Oblique: \"oblique\"\n    };\n    throw new Error(`Parametric maps ${orientationText[orientation]} to the acquisition plane of the source data are not yet supported.`);\n  }\n  const imageIdMaps = imageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n  await insertPixelDataPlanar(pixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps);\n  return {\n    pixelData\n  };\n}\nfunction insertPixelDataPlanar(sourcePixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps) {\n  const targetPixelData = new sourcePixelData.constructor(sourcePixelData.length);\n  const {\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sliceLength = Columns * Rows;\n  const numSlices = PerFrameFunctionalGroupsSequence.length;\n  for (let i = 0; i < numSlices; i++) {\n    const sourceSliceDataView = new sourcePixelData.constructor(sourcePixelData.buffer, i * sliceLength, sliceLength);\n    const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n      continue;\n    }\n    const sourceImageMetadata = imageIdMaps.metadata[imageId];\n    if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n      throw new Error(\"Parametric map have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported.\");\n    }\n    const imageIdIndex = imageIdMaps.indices[imageId];\n    const byteOffset = sliceLength * imageIdIndex * targetPixelData.BYTES_PER_ELEMENT;\n    const targetSliceDataView = new targetPixelData.constructor(targetPixelData.buffer, byteOffset, sliceLength);\n    targetSliceDataView.set(sourceSliceDataView);\n  }\n  return targetPixelData;\n}\nfunction getPixelData(multiframe) {\n  let TypedArrayClass;\n  let data;\n  if (multiframe.PixelData) {\n    const validTypedArrays = multiframe.BitsAllocated === 16 ? [Uint16Array, Int16Array] : [Uint32Array, Int32Array];\n    TypedArrayClass = validTypedArrays[multiframe.PixelRepresentation ?? 0];\n    data = multiframe.PixelData;\n  } else if (multiframe.FloatPixelData) {\n    TypedArrayClass = Float32Array;\n    data = multiframe.FloatPixelData;\n  } else if (multiframe.DoubleFloatPixelData) {\n    TypedArrayClass = Float64Array;\n    data = multiframe.DoubleFloatPixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This parametric map pixel data is undefined.\");\n  }\n  if (Array.isArray(data)) {\n    data = data[0];\n  }\n  return new TypedArrayClass(data);\n}\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, sopUIDImageIdIndexMap) : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (ReferencedSeriesInstanceUID === undefined || PerFrameFunctionalGroup.PlanePositionSequence === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient === undefined) {\n    return undefined;\n  }\n  for (let imageIdsIndex = 0; imageIdsIndex < imageIds.length; ++imageIdsIndex) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageIds[imageIdsIndex]);\n    if (sourceImageMetadata === undefined || sourceImageMetadata.ImagePositionPatient === undefined || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n    if (compareArrays(PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageIds[imageIdsIndex];\n    }\n  }\n}\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, sopUIDImageIdIndexMap) {\n  const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n  if (!imageId) {\n    return;\n  }\n  const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n  return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\nconst ParametricMapObj = {\n  generateToolState\n};\n\nexport { ParametricMapObj as ParametricMap, ParametricMapObj as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport Length from './Length.js';\nimport FreehandRoi from './FreehandRoi.js';\nimport Bidirectional from './Bidirectional.js';\nimport EllipticalRoi from './EllipticalRoi.js';\nimport CircleRoi from './CircleRoi.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport CobbAngle from './CobbAngle.js';\nimport Angle from './Angle.js';\nimport RectangleRoi from './RectangleRoi.js';\nimport * as Segmentation from './Segmentation.js';\nimport ParametricMapObj from './ParametricMap.js';\n\nconst CornerstoneSR = {\n  Length,\n  FreehandRoi,\n  Bidirectional,\n  EllipticalRoi,\n  CircleRoi,\n  ArrowAnnotate,\n  MeasurementReport,\n  CobbAngle,\n  Angle,\n  RectangleRoi\n};\nconst CornerstoneSEG = {\n  Segmentation\n};\nconst CornerstonePMAP = {\n  ParametricMap: ParametricMapObj\n};\n\nexport { CornerstonePMAP, CornerstoneSEG, CornerstoneSR };\n","var CORNERSTONE_3D_TAG = \"Cornerstone3DTools@^0.1.0\";\n\nexport { CORNERSTONE_3D_TAG as default };\n","const patientTags = [\"PatientName\", \"PatientID\", \"PatientBirthDate\", \"PatientBirthTime\", \"PatientID\", \"IssuerOfPatientID\", \"OtherPatientIDs\", \"OtherPatientIDsSequence\", \"PatientSex\", \"PatientIdentityRemoved\", \"DeidentificationMethodCodeSequence\"];\nconst studyTags = [\"StudyDate\", \"StudyTime\", \"StudyStatusID\", \"StudyPriorityID\", \"StudyInstanceUID\", \"StudyDescription\", \"AccessionNumber\", \"StudyID\", \"ReferringPhysicianName\", \"BodyPartExamined\", \"TimezoneOffsetFromUTC\"];\nconst patientStudyTags = [...patientTags, ...studyTags];\nfunction copyStudyTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of patientStudyTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copyStudyTags, patientStudyTags, patientTags, studyTags };\n","const seriesTags = [\"SeriesInstanceUID\", \"SeriesNumber\", \"SeriesDescription\", \"Modality\", \"SeriesDate\", \"SeriesTime\"];\nfunction copySeriesTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of seriesTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copySeriesTags, seriesTags };\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\nconst CodingScheme = {\n  CodingSchemeDesignator,\n  codeValues: {\n    CORNERSTONEFREETEXT\n  }\n};\n\nexport { CodingScheme as default };\n","const NO_IMAGE_ID = \"none\";\n\nexport { NO_IMAGE_ID };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport { cache } from '@cornerstonejs/core';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\nimport { copyStudyTags } from '../helpers/copyStudyTags.js';\nimport { copySeriesTags } from '../helpers/copySeriesTags.js';\nimport CodingScheme from './CodingScheme.js';\nimport { NO_IMAGE_ID } from './constants/index.js';\n\nvar _MeasurementReport;\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nclass MeasurementReport {\n  static getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, worldToImageCoords) {\n    const args = toolClass.getTID300RepresentationArguments(tool, worldToImageCoords);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n    const TID300Measurement = new toolClass.TID300Representation(args);\n    return TID300Measurement;\n  }\n  static getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords) {\n    const toolTypeData = toolData[toolType];\n    const toolClass = this.measurementAdapterByToolType.get(toolType);\n    if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n      return;\n    }\n    const Measurements = toolTypeData.data.map(tool => {\n      return this.getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, worldToImageCoords);\n    });\n    return new TID1501MeasurementGroup(Measurements);\n  }\n  static getCornerstoneLabelFromDefaultState(defaultState) {\n    const {\n      findingSites = [],\n      finding\n    } = defaultState;\n    const cornersoneFreeTextCodingValue = CodingScheme.codeValues.CORNERSTONEFREETEXT;\n    const freeTextLabel = findingSites.find(fs => fs.CodeValue === cornersoneFreeTextCodingValue);\n    if (freeTextLabel) {\n      return freeTextLabel.CodeMeaning;\n    }\n    if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n      return finding.CodeMeaning;\n    }\n  }\n  static generateDatasetMeta() {\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    return _meta;\n  }\n  static processSCOORDGroup(_ref) {\n    let {\n      SCOORDGroup,\n      toolType,\n      sopInstanceUIDToImageIdMap,\n      metadata\n    } = _ref;\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const referencedImageId = sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    return {\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      state: {\n        description: undefined,\n        sopInstanceUid: ReferencedSOPInstanceUID,\n        annotation: {\n          annotationUID: DicomMetaDictionary.uid(),\n          metadata: {\n            toolName: toolType,\n            referencedImageId,\n            FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n            label: \"\"\n          }\n        }\n      }\n    };\n  }\n  static processSCOORD3DGroup(_ref2) {\n    let {\n      SCOORD3DGroup,\n      toolType\n    } = _ref2;\n    return {\n      SCOORD3DGroup,\n      FrameOfReferenceUID: SCOORD3DGroup.ReferencedFrameOfReferenceUID,\n      state: {\n        description: undefined,\n        annotation: {\n          annotationUID: DicomMetaDictionary.uid(),\n          metadata: {\n            toolName: toolType,\n            FrameOfReferenceUID: SCOORD3DGroup.ReferencedFrameOfReferenceUID,\n            label: \"\"\n          }\n        }\n      }\n    };\n  }\n  static getSpatialCoordinatesState(_ref3) {\n    let {\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      toolType\n    } = _ref3;\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const SCOORD3DGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\");\n    if (SCOORDGroup) {\n      return this.processSCOORDGroup({\n        SCOORDGroup,\n        toolType,\n        metadata,\n        sopInstanceUIDToImageIdMap\n      });\n    } else if (SCOORD3DGroup) {\n      return this.processSCOORD3DGroup({\n        SCOORD3DGroup,\n        toolType\n      });\n    } else {\n      throw new Error(\"No spatial coordinates group found.\");\n    }\n  }\n  static processSpatialCoordinatesGroup(_ref4) {\n    let {\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      findingGroup,\n      findingSiteGroups,\n      toolType\n    } = _ref4;\n    const {\n      state,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      SCOORD3DGroup,\n      FrameOfReferenceUID\n    } = this.getSpatialCoordinatesState({\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      toolType\n    });\n    const finding = findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined;\n    const findingSites = findingSiteGroups.map(fsg => {\n      return addAccessors(fsg.ConceptCodeSequence);\n    });\n    const defaultState = {\n      ...state,\n      finding,\n      findingSites\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    defaultState.annotation.metadata.label = MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n    return {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      SCOORD3DGroup,\n      FrameOfReferenceUID\n    };\n  }\n  static getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, toolType) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => this.codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => this.codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    return this.processSpatialCoordinatesGroup({\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      findingGroup,\n      findingSiteGroups,\n      toolType\n    });\n  }\n  static generateReferencedSOPSequence(_ref5) {\n    let {\n      toolData,\n      toolTypes,\n      metadataProvider,\n      imageId,\n      sopInstanceUIDsToSeriesInstanceUIDMap,\n      derivationSourceDatasets\n    } = _ref5;\n    const effectiveImageId = imageId === NO_IMAGE_ID ? this.getImageIdFromVolume({\n      toolData,\n      toolTypes\n    }) : imageId;\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", effectiveImageId);\n    const instance = metadataProvider.get(\"instance\", effectiveImageId);\n    const {\n      sopInstanceUID,\n      sopClassUID\n    } = sopCommonModule;\n    const {\n      SeriesInstanceUID: seriesInstanceUID\n    } = instance;\n    sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] = seriesInstanceUID;\n    if (!derivationSourceDatasets.find(dsd => dsd.SeriesInstanceUID === seriesInstanceUID)) {\n      const derivationSourceDataset = MeasurementReport.generateDerivationSourceDataset(instance);\n      derivationSourceDatasets.push(derivationSourceDataset);\n    }\n    const frameNumber = metadataProvider.get(\"frameNumber\", effectiveImageId);\n    const ReferencedSOPSequence = {\n      ReferencedSOPClassUID: sopClassUID,\n      ReferencedSOPInstanceUID: sopInstanceUID,\n      ReferencedFrameNumber: undefined\n    };\n    if (instance && instance.NumberOfFrames && instance.NumberOfFrames > 1 || Normalizer.isMultiframeSOPClassUID(sopClassUID)) {\n      ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n    }\n    return ReferencedSOPSequence;\n  }\n  static getImageIdFromVolume(_ref6) {\n    let {\n      toolData,\n      toolTypes\n    } = _ref6;\n    const referenceToolData = toolData?.[toolTypes?.[0]]?.data?.[0];\n    const volumeId = referenceToolData?.metadata?.volumeId;\n    const volume = cache.getVolume(volumeId);\n    const imageId = volume.imageIds[0];\n    return imageId;\n  }\n  static generateReport(toolState, metadataProvider, worldToImageCoords, options) {\n    let allMeasurementGroups = [];\n    const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n    const derivationSourceDatasets = [];\n    const _meta = MeasurementReport.generateDatasetMeta();\n    let is3DSR = false;\n    Object.keys(toolState).forEach(imageId => {\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = this.generateReferencedSOPSequence({\n        toolData,\n        toolTypes,\n        metadataProvider,\n        imageId,\n        sopInstanceUIDsToSeriesInstanceUIDMap,\n        derivationSourceDatasets\n      });\n      if (imageId === NO_IMAGE_ID) {\n        is3DSR = true;\n      }\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = this.getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const tid1500MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n    const report = new StructuredReport(derivationSourceDatasets, options);\n    const contentItem = tid1500MeasurementReport.contentItem(derivationSourceDatasets, {\n      ...options,\n      sopInstanceUIDsToSeriesInstanceUIDMap\n    });\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.SpecificCharacterSet = \"ISO_IR 192\";\n    if (is3DSR) {\n      report.dataset.SOPClassUID = DicomMetaDictionary.sopClassUIDsByName.Comprehensive3DSR;\n    }\n    return report;\n  }\n  static generateToolState(dataset, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, hooks) {\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n    const TRACKING_UNIQUE_IDENTIFIER = \"Tracking Unique Identifier\";\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n    const measurementData = {};\n    measurementGroups.forEach(measurementGroup => {\n      try {\n        const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n        const trackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n        const {\n          TextValue: trackingIdentifierValue\n        } = trackingIdentifierGroup;\n        const trackingUniqueIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_UNIQUE_IDENTIFIER);\n        const trackingUniqueIdentifierValue = trackingUniqueIdentifierGroup?.UID;\n        const toolAdapter = hooks?.getToolClass?.(measurementGroup, dataset, this.measurementAdapterByToolType) || this.getAdapterForTrackingIdentifier(trackingIdentifierValue);\n        if (toolAdapter) {\n          const measurement = toolAdapter.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifierValue);\n          measurement.TrackingUniqueIdentifier = trackingUniqueIdentifierValue;\n          console.log(`=== ${toolAdapter.toolType} ===`);\n          console.log(measurement);\n          measurementData[toolAdapter.toolType] ||= [];\n          measurementData[toolAdapter.toolType].push(measurement);\n        }\n      } catch (e) {\n        console.warn(\"Unable to generate tool state for\", measurementGroup, e);\n      }\n    });\n    return measurementData;\n  }\n  static registerTool(toolAdapter) {\n    let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const registerName = toolAdapter.toolType;\n    if (this.measurementAdapterByToolType.has(registerName)) {\n      if (!replace) {\n        throw new Error(`The registered tool name ${registerName} already exists in adapters, use a different toolType or use replace`);\n      }\n      if (typeof replace === \"function\") {\n        replace(this.measurementAdapterByToolType.get(registerName));\n      }\n    }\n    this.measurementAdapterByToolType.set(toolAdapter.toolType, toolAdapter);\n    this.measurementAdapterByTrackingIdentifier.set(toolAdapter.trackingIdentifierTextValue, toolAdapter);\n  }\n  static registerTrackingIdentifier(toolClass) {\n    for (var _len = arguments.length, trackingIdentifiers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      trackingIdentifiers[_key - 1] = arguments[_key];\n    }\n    for (const identifier of trackingIdentifiers) {\n      this.measurementAdapterByTrackingIdentifier.set(identifier, toolClass);\n    }\n  }\n  static getAdapterForTrackingIdentifier(trackingIdentifier) {\n    const adapter = this.measurementAdapterByTrackingIdentifier.get(trackingIdentifier);\n    if (adapter) {\n      return adapter;\n    }\n    for (const adapterTest of [...this.measurementAdapterByToolType.values()]) {\n      if (adapterTest.isValidCornerstoneTrackingIdentifier(trackingIdentifier)) {\n        this.measurementAdapterByTrackingIdentifier.set(trackingIdentifier, adapterTest);\n        return adapterTest;\n      }\n    }\n  }\n}\n_MeasurementReport = MeasurementReport;\n_MeasurementReport.CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n_MeasurementReport.measurementAdapterByToolType = new Map();\n_MeasurementReport.measurementAdapterByTrackingIdentifier = new Map();\n_MeasurementReport.codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\n_MeasurementReport.generateDerivationSourceDataset = instance => {\n  const studyTags = copyStudyTags(instance);\n  const seriesTags = copySeriesTags(instance);\n  return {\n    ...studyTags,\n    ...seriesTags\n  };\n};\n\nexport { MeasurementReport as default };\n","import CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport MeasurementReport from './MeasurementReport.js';\n\nclass BaseAdapter3D {\n  static init(toolType, representation, options) {\n    this.toolType = toolType;\n    if (BaseAdapter3D.toolType) {\n      throw new Error(`Base adapter tool type set to ${this.toolType} while setting ${toolType}`);\n    }\n    this.parentType = options?.parentType;\n    this.trackingIdentifiers = new Set();\n    this.TID300Representation = representation;\n    if (this.parentType) {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${this.parentType}:${this.toolType}`;\n      const alternateTrackingIdentifier = `${CORNERSTONE_3D_TAG}:${this.toolType}`;\n      this.trackingIdentifiers.add(alternateTrackingIdentifier);\n    } else {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${toolType}`;\n    }\n    this.trackingIdentifiers.add(this.trackingIdentifierTextValue);\n    MeasurementReport.registerTool(this);\n  }\n  static registerLegacy() {\n    this.trackingIdentifiers.add(`cornerstoneTools@^4.0.0:${this.toolType}`);\n  }\n  static registerSubType(adapter, toolType, replace) {\n    const subAdapter = Object.create(adapter);\n    subAdapter.init(toolType, adapter.TID300Representation, {\n      parentType: adapter.parentType || adapter.toolType,\n      replace\n    });\n    return subAdapter;\n  }\n  static isValidCornerstoneTrackingIdentifier(trackingIdentifier) {\n    if (this.trackingIdentifiers.has(trackingIdentifier)) {\n      return true;\n    }\n    if (!trackingIdentifier.includes(\":\")) {\n      return false;\n    }\n    return trackingIdentifier.startsWith(this.trackingIdentifierTextValue);\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, _imageToWorldCoords, metadata, trackingIdentifier) {\n    const {\n      defaultState: state,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    state.annotation.data = {\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber,\n      seriesLevel: trackingIdentifier?.indexOf(\":Series\") > 0\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const pointsImage = points.map(point => {\n      const pointImage = worldToImageCoords(referencedImageId, point);\n      return {\n        x: pointImage[0],\n        y: pointImage[1]\n      };\n    });\n    const tidArguments = {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding\n    };\n    return tidArguments;\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const point = points[0];\n    const pointXYZ = {\n      x: point[0],\n      y: point[1],\n      z: point[2]\n    };\n    return {\n      points: [pointXYZ],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding\n    };\n  }\n}\n\nexport { BaseAdapter3D as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport CodingScheme from './CodingScheme.js';\n\nvar _ArrowAnnotate;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst {\n  codeValues\n} = CodingScheme;\nclass ArrowAnnotate extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, _trackingIdentifier) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, ArrowAnnotate.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const text = defaultState.annotation.metadata.label;\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        SCOORDGroup,\n        referencedImageId,\n        metadata,\n        imageToWorldCoords,\n        defaultState,\n        text,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        SCOORD3DGroup,\n        defaultState,\n        text\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord3D(_ref) {\n    let {\n      SCOORD3DGroup,\n      defaultState,\n      text\n    } = _ref;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      text,\n      handles: {\n        arrowFirst: true,\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord(_ref2) {\n    let {\n      SCOORDGroup,\n      referencedImageId,\n      metadata,\n      imageToWorldCoords,\n      defaultState,\n      text,\n      ReferencedFrameNumber\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    if (worldCoords.length === 1) {\n      const imagePixelModule = metadata.get(\"imagePixelModule\", referencedImageId);\n      let xOffset = 10;\n      let yOffset = 10;\n      if (imagePixelModule) {\n        const {\n          columns,\n          rows\n        } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n      const secondPoint = imageToWorldCoords(referencedImageId, [GraphicData[0] + xOffset, GraphicData[1] + yOffset]);\n      worldCoords.push(secondPoint);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      text,\n      handles: {\n        arrowFirst: true,\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata,\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const {\n      points,\n      arrowFirst\n    } = data.handles;\n    let point;\n    let point2;\n    if (arrowFirst) {\n      point = points[0];\n      point2 = points[1];\n    } else {\n      point = points[1];\n      point2 = points[0];\n    }\n    const pointImage = worldToImageCoords(referencedImageId, point);\n    const pointImage2 = worldToImageCoords(referencedImageId, point2);\n    const TID300RepresentationArguments = {\n      points: [{\n        x: pointImage[0],\n        y: pointImage[1]\n      }, {\n        x: pointImage2[0],\n        y: pointImage2[1]\n      }],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      use3DSpatialCoordinates: false\n    };\n    if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: codeValues.CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: CodingScheme.CodingSchemeDesignator,\n        CodeMeaning: data.text\n      };\n    }\n    return TID300RepresentationArguments;\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      findingSites,\n      metadata\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const {\n      points,\n      arrowFirst\n    } = data.handles;\n    let point;\n    let point2;\n    if (arrowFirst) {\n      point = points[0];\n      point2 = points[1];\n    } else {\n      point = points[1];\n      point2 = points[0];\n    }\n    const pointImage = point;\n    const pointImage2 = point2;\n    const TID300RepresentationArguments = {\n      points: [{\n        x: pointImage[0],\n        y: pointImage[1],\n        z: pointImage[2]\n      }, {\n        x: pointImage2[0],\n        y: pointImage2[1],\n        z: pointImage2[2]\n      }],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n    if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: codeValues.CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: CodingScheme.CodingSchemeDesignator,\n        CodeMeaning: data.text\n      };\n    }\n    return TID300RepresentationArguments;\n  }\n}\n_ArrowAnnotate = ArrowAnnotate;\n(() => {\n  _ArrowAnnotate.init(\"ArrowAnnotate\", TID300Point);\n  _ArrowAnnotate.registerLegacy();\n})();\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Bidirectional;\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nclass Bidirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Bidirectional.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    if (longAxisSCOORDGroup && shortAxisSCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        longAxisNUMGroup,\n        shortAxisNUMGroup,\n        longAxisSCOORDGroup,\n        shortAxisSCOORDGroup,\n        referencedImageId,\n        imageToWorldCoords,\n        ReferencedFrameNumber,\n        defaultState\n      });\n    } else {\n      return this.getMeasurementDataFromScoord3d({\n        longAxisNUMGroup,\n        shortAxisNUMGroup,\n        defaultState\n      });\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      longAxisNUMGroup,\n      shortAxisNUMGroup,\n      longAxisSCOORDGroup,\n      shortAxisSCOORDGroup,\n      referencedImageId,\n      imageToWorldCoords,\n      ReferencedFrameNumber,\n      defaultState\n    } = _ref;\n    const worldCoords = [];\n    [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\n      const {\n        GraphicData\n      } = group;\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n        worldCoords.push(point);\n      }\n    });\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n          width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3d(_ref2) {\n    let {\n      longAxisNUMGroup,\n      shortAxisNUMGroup,\n      defaultState\n    } = _ref2;\n    const worldCoords = [];\n    const longAxisSCOORD3DGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\");\n    const shortAxisSCOORD3DGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\");\n    [longAxisSCOORD3DGroup, shortAxisSCOORD3DGroup].forEach(group => {\n      const {\n        GraphicData\n      } = group;\n      for (let i = 0; i < GraphicData.length; i += 3) {\n        const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n        worldCoords.push(point);\n      }\n    });\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const {\n      points\n    } = handles;\n    const firstPointPairs = [points[0], points[1]];\n    const secondPointPairs = [points[2], points[3]];\n    const firstPointPairsDistance = Math.sqrt(Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) + Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) + Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2));\n    const secondPointPairsDistance = Math.sqrt(Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) + Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) + Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2));\n    let shortAxisPoints;\n    let longAxisPoints;\n    if (firstPointPairsDistance > secondPointPairsDistance) {\n      shortAxisPoints = firstPointPairs;\n      longAxisPoints = secondPointPairs;\n    } else {\n      shortAxisPoints = secondPointPairs;\n      longAxisPoints = firstPointPairs;\n    }\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D({\n        tool,\n        shortAxisPoints,\n        longAxisPoints\n      });\n    }\n    const longAxisStartImage = worldToImageCoords(referencedImageId, shortAxisPoints[0]);\n    const longAxisEndImage = worldToImageCoords(referencedImageId, shortAxisPoints[1]);\n    const shortAxisStartImage = worldToImageCoords(referencedImageId, longAxisPoints[0]);\n    const shortAxisEndImage = worldToImageCoords(referencedImageId, longAxisPoints[1]);\n    const {\n      length,\n      width\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      longAxis: {\n        point1: {\n          x: longAxisStartImage[0],\n          y: longAxisStartImage[1]\n        },\n        point2: {\n          x: longAxisEndImage[0],\n          y: longAxisEndImage[1]\n        }\n      },\n      shortAxis: {\n        point1: {\n          x: shortAxisStartImage[0],\n          y: shortAxisStartImage[1]\n        },\n        point2: {\n          x: shortAxisEndImage[0],\n          y: shortAxisEndImage[1]\n        }\n      },\n      longAxisLength: length,\n      shortAxisLength: width,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(_ref3) {\n    let {\n      tool,\n      shortAxisPoints,\n      longAxisPoints\n    } = _ref3;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {}\n    } = data;\n    const longAxisStart = shortAxisPoints[0];\n    const longAxisEnd = shortAxisPoints[1];\n    const shortAxisStart = longAxisPoints[0];\n    const shortAxisEnd = longAxisPoints[1];\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      length,\n      width\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      longAxis: {\n        point1: {\n          x: longAxisStart[0],\n          y: longAxisStart[1],\n          z: longAxisStart[2]\n        },\n        point2: {\n          x: longAxisEnd[0],\n          y: longAxisEnd[1],\n          z: longAxisEnd[2]\n        }\n      },\n      shortAxis: {\n        point1: {\n          x: shortAxisStart[0],\n          y: shortAxisStart[1],\n          z: shortAxisStart[2]\n        },\n        point2: {\n          x: shortAxisEnd[0],\n          y: shortAxisEnd[1],\n          z: shortAxisEnd[2]\n        }\n      },\n      longAxisLength: length,\n      shortAxisLength: width,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Bidirectional = Bidirectional;\n(() => {\n  _Bidirectional.init(\"Bidirectional\", TID300Bidirectional);\n  _Bidirectional.registerLegacy();\n})();\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Angle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass Angle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Angle.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n    const middle = worldToImageCoords(referencedImageId, handles.points[1]);\n    const end = worldToImageCoords(referencedImageId, handles.points[2]);\n    const point1 = {\n      x: start1[0],\n      y: start1[1]\n    };\n    const point2 = {\n      x: middle[0],\n      y: middle[1]\n    };\n    const point3 = point2;\n    const point4 = {\n      x: end[0],\n      y: end[1]\n    };\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const start = handles.points[0];\n    const middle = handles.points[1];\n    const end = handles.points[2];\n    const point1 = {\n      x: start[0],\n      y: start[1],\n      z: start[2]\n    };\n    const point2 = {\n      x: middle[0],\n      y: middle[1],\n      z: middle[2]\n    };\n    const point3 = point2;\n    const point4 = {\n      x: end[0],\n      y: end[1],\n      z: end[2]\n    };\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      angle\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Angle = Angle;\n(() => {\n  _Angle.init(\"Angle\", TID300CobbAngle);\n  _Angle.registerLegacy();\n})();\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _CobbAngle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass CobbAngle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CobbAngle.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n    const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n    const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n    const point1 = {\n      x: start1[0],\n      y: start1[1]\n    };\n    const point2 = {\n      x: end1[0],\n      y: end1[1]\n    };\n    const point3 = {\n      x: start2[0],\n      y: start2[1]\n    };\n    const point4 = {\n      x: end2[0],\n      y: end2[1]\n    };\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const start1 = handles.points[0];\n    const end1 = handles.points[1];\n    const start2 = handles.points[2];\n    const end2 = handles.points[3];\n    const point1 = {\n      x: start1[0],\n      y: start1[1],\n      z: start1[2]\n    };\n    const point2 = {\n      x: end1[0],\n      y: end1[1],\n      z: end1[2]\n    };\n    const point3 = {\n      x: start2[0],\n      y: start2[1],\n      z: start2[2]\n    };\n    const point4 = {\n      x: end2[0],\n      y: end2[1],\n      z: end2[2]\n    };\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      angle\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_CobbAngle = CobbAngle;\n(() => {\n  _CobbAngle.init(\"CobbAngle\", TID300CobbAngle);\n  _CobbAngle.registerLegacy();\n})();\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _CircleROI;\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nclass CircleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CircleROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      pointsWorld.push(worldPos);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...pointsWorld],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n          radius: 0,\n          perimeter: 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const worldPos = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      pointsWorld.push(worldPos);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...pointsWorld],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const center = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const points = [];\n    points.push({\n      x: center[0],\n      y: center[1]\n    });\n    points.push({\n      x: end[0],\n      y: end[1]\n    });\n    const {\n      area,\n      radius\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    const perimeter = 2 * Math.PI * radius;\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const center = handles.points[0];\n    const end = handles.points[1];\n    const points = [];\n    points.push({\n      x: center[0],\n      y: center[1],\n      z: center[2]\n    });\n    points.push({\n      x: end[0],\n      y: end[1],\n      z: center[2]\n    });\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      area,\n      radius\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    const perimeter = 2 * Math.PI * radius;\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_CircleROI = CircleROI;\n(() => {\n  _CircleROI.init(\"CircleROI\", TID300Circle);\n  _CircleROI.registerLegacy();\n})();\n\nexport { CircleROI as default };\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _EllipticalROI;\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst EPSILON = 1e-4;\nclass EllipticalROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, EllipticalROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        metadata,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      metadata,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      pointsWorld.push(worldPos);\n    }\n    const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n    const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n    const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n    const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n    const majorAxisVec = vec3.create();\n    vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    if (!imagePlaneModule) {\n      throw new Error(\"imageId does not have imagePlaneModule metadata\");\n    }\n    const {\n      columnCosines\n    } = imagePlaneModule;\n    const columnCosinesVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n    const projectedMajorAxisOnColVec = vec3.dot(columnCosinesVec, majorAxisVec);\n    const projectedMinorAxisOnColVec = vec3.dot(columnCosinesVec, minorAxisVec);\n    const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n    const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n    let ellipsePoints = [];\n    if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n      ellipsePoints = [pointsWorld[0], pointsWorld[1], pointsWorld[2], pointsWorld[3]];\n    } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n      ellipsePoints = [pointsWorld[2], pointsWorld[3], pointsWorld[0], pointsWorld[1]];\n    } else {\n      console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...ellipsePoints],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const worldPos = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      pointsWorld.push(worldPos);\n    }\n    const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n    const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n    const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n    const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n    const majorAxisVec = vec3.create();\n    vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [majorAxisStart, majorAxisEnd, minorAxisStart, minorAxisEnd],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const rotation = data.initialRotation || 0;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    let top, bottom, left, right;\n    if (rotation == 90 || rotation == 270) {\n      bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n      top = worldToImageCoords(referencedImageId, handles.points[3]);\n      left = worldToImageCoords(referencedImageId, handles.points[0]);\n      right = worldToImageCoords(referencedImageId, handles.points[1]);\n    } else {\n      top = worldToImageCoords(referencedImageId, handles.points[0]);\n      bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n      left = worldToImageCoords(referencedImageId, handles.points[2]);\n      right = worldToImageCoords(referencedImageId, handles.points[3]);\n    }\n    const topBottomLength = Math.abs(top[1] - bottom[1]);\n    const leftRightLength = Math.abs(left[0] - right[0]);\n    const points = [];\n    if (topBottomLength > leftRightLength) {\n      points.push({\n        x: top[0],\n        y: top[1]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1]\n      });\n      points.push({\n        x: left[0],\n        y: left[1]\n      });\n      points.push({\n        x: right[0],\n        y: right[1]\n      });\n    } else {\n      points.push({\n        x: left[0],\n        y: left[1]\n      });\n      points.push({\n        x: right[0],\n        y: right[1]\n      });\n      points.push({\n        x: top[0],\n        y: top[1]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1]\n      });\n    }\n    const {\n      area\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats,\n      handles\n    } = data;\n    const rotation = data.initialRotation || 0;\n    let top, bottom, left, right;\n    if (rotation == 90 || rotation == 270) {\n      bottom = handles.points[2];\n      top = handles.points[3];\n      left = handles.points[0];\n      right = handles.points[1];\n    } else {\n      top = handles.points[0];\n      bottom = handles.points[1];\n      left = handles.points[2];\n      right = handles.points[3];\n    }\n    const topBottomLength = Math.sqrt((top[0] - bottom[0]) ** 2 + (top[1] - bottom[1]) ** 2 + (top[2] - bottom[2]) ** 2);\n    const leftRightLength = Math.sqrt((left[0] - right[0]) ** 2 + (left[1] - right[1]) ** 2 + (left[2] - right[2]) ** 2);\n    const points = [];\n    if (topBottomLength > leftRightLength) {\n      points.push({\n        x: top[0],\n        y: top[1],\n        z: top[2]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1],\n        z: bottom[2]\n      });\n      points.push({\n        x: left[0],\n        y: left[1],\n        z: left[2]\n      });\n      points.push({\n        x: right[0],\n        y: right[1],\n        z: right[2]\n      });\n    } else {\n      points.push({\n        x: left[0],\n        y: left[1],\n        z: left[2]\n      });\n      points.push({\n        x: right[0],\n        y: right[1],\n        z: right[2]\n      });\n      points.push({\n        x: top[0],\n        y: top[1],\n        z: top[2]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1],\n        z: bottom[2]\n      });\n    }\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      area\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_EllipticalROI = EllipticalROI;\n_EllipticalROI.init(\"EllipticalROI\", TID300Ellipse);\n\nexport { EllipticalROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _RectangleROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, RectangleROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        SCOORD3DGroup,\n        defaultState\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3], worldCoords[2]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      SCOORD3DGroup,\n      defaultState\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3], worldCoords[2]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const corners = handles.points.map(point => worldToImageCoords(referencedImageId, point));\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    return {\n      points: [corners[0], corners[1], corners[3], corners[2], corners[0]],\n      area,\n      perimeter,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const corners = handles.points;\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    return {\n      points: [corners[0], corners[1], corners[3], corners[2], corners[0]],\n      area,\n      perimeter,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_RectangleROI = RectangleROI;\n(() => {\n  _RectangleROI.init(\"RectangleROI\", TID300Polyline);\n  _RectangleROI.registerLegacy();\n})();\n\nexport { RectangleROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Length;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length extends BaseAdapter3D {\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber,\n      imageToWorldCoords\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          length: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3d(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = GraphicData;\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords.slice(0, 3), worldCoords.slice(3, 6)],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        NUMGroup,\n        SCOORDGroup,\n        ReferencedFrameNumber,\n        imageToWorldCoords\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3d({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    const {\n      length: distance\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const start = handles.points[0];\n    const end = handles.points[1];\n    const point1 = {\n      x: start[0],\n      y: start[1],\n      z: start[2]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1],\n      z: end[2]\n    };\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      length: distance\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Length = Length;\n(() => {\n  _Length.init(LENGTH, TID300Length);\n  _Length.registerLegacy();\n})();\n\nexport { Length as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport { vec3 } from 'gl-matrix';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _PlanarFreehandROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass PlanarFreehandROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, PlanarFreehandROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n    let isOpenContour = true;\n    if (distanceBetweenFirstAndLastPoint < this.closedContourThreshold) {\n      worldCoords.pop();\n      isOpenContour = false;\n    }\n    const points = [];\n    if (isOpenContour) {\n      points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      contour: {\n        polyline: worldCoords,\n        closed: !isOpenContour\n      },\n      handles: {\n        points,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n    let isOpenContour = true;\n    if (distanceBetweenFirstAndLastPoint < this.closedContourThreshold) {\n      worldCoords.pop();\n      isOpenContour = false;\n    }\n    const points = [];\n    if (isOpenContour) {\n      points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      contour: {\n        polyline: worldCoords,\n        closed: !isOpenContour\n      },\n      handles: {\n        points,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      polyline,\n      closed\n    } = data.contour;\n    const isOpenContour = closed !== true;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const points = polyline.map(worldPos => worldToImageCoords(referencedImageId, worldPos));\n    if (!isOpenContour) {\n      const firstPoint = points[0];\n      points.push([firstPoint[0], firstPoint[1]]);\n    }\n    const {\n      area,\n      areaUnit,\n      modalityUnit,\n      perimeter,\n      mean,\n      max,\n      stdDev\n    } = data.cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      points,\n      area,\n      areaUnit,\n      perimeter,\n      modalityUnit,\n      mean,\n      max,\n      stdDev,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      polyline,\n      closed\n    } = data.contour;\n    const isOpenContour = closed !== true;\n    const points = polyline;\n    if (!isOpenContour) {\n      const firstPoint = points[0];\n      points.push([firstPoint[0], firstPoint[1], firstPoint[2]]);\n    }\n    const cachedStatsKeys = Object.keys(data.cachedStats)[0];\n    const {\n      area,\n      areaUnit,\n      modalityUnit,\n      perimeter,\n      mean,\n      max,\n      stdDev\n    } = cachedStatsKeys ? data.cachedStats[cachedStatsKeys] : {};\n    return {\n      points,\n      area,\n      areaUnit,\n      perimeter,\n      modalityUnit,\n      mean,\n      max,\n      stdDev,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_PlanarFreehandROI = PlanarFreehandROI;\n_PlanarFreehandROI.closedContourThreshold = 1e-5;\n_PlanarFreehandROI.init(\"PlanarFreehandROI\", TID300Polyline);\n\nexport { PlanarFreehandROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Probe;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass Probe extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier) {\n    const state = super.getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier);\n    const {\n      defaultState,\n      SCOORDGroup,\n      SCOORD3DGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Probe.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        state,\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        state,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      state,\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        points: worldCoords,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      state,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        points: worldCoords,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const pointsImage = points.map(point => {\n      const pointImage = worldToImageCoords(referencedImageId, point);\n      return {\n        x: pointImage[0],\n        y: pointImage[1]\n      };\n    });\n    return {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const point = points[0];\n    const pointXYZ = {\n      x: point[0],\n      y: point[1],\n      z: point[2]\n    };\n    return {\n      points: [pointXYZ],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      findingSites: findingSites || [],\n      finding,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Probe = Probe;\n(() => {\n  _Probe.init(\"Probe\", TID300Point);\n  _Probe.registerLegacy();\n})();\n\nexport { Probe as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _UltrasoundDirectional;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nclass UltrasoundDirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, UltrasoundDirectional.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"UltrasoundDirectionalTool.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    return {\n      point1,\n      point2,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_UltrasoundDirectional = UltrasoundDirectional;\n_UltrasoundDirectional.init(\"UltrasoundDirectionalTool\", TID300Length);\n\nexport { UltrasoundDirectional as default };\n","import { normalizers, derivations } from 'dcmjs';\nimport { fillSegmentation } from '../../Cornerstone/Segmentation_4X.js';\n\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nfunction generateSegmentation(images, labelmaps, metadata) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const segmentation = _createMultiframeSegmentationFromReferencedImages(images, metadata, options);\n  return fillSegmentation(segmentation, labelmaps, options);\n}\nfunction _createMultiframeSegmentationFromReferencedImages(images, metadata, options) {\n  const datasets = images.map(image => {\n    const instance = metadata.get(\"instance\", image.imageId);\n    return {\n      ...image,\n      ...instance,\n      SOPClassUID: instance.SopClassUID || instance.SOPClassUID,\n      SOPInstanceUID: instance.SopInstanceUID || instance.SOPInstanceUID,\n      PixelData: image.voxelManager.getScalarData(),\n      _vrMap: {\n        PixelData: \"OW\"\n      },\n      _meta: {}\n    };\n  });\n  const multiframe = Normalizer.normalizeToDataset(datasets);\n  if (!multiframe) {\n    throw new Error(\"Failed to normalize the multiframe dataset, the data is not multi-frame.\");\n  }\n  return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","function generateLabelMaps2DFrom3D(labelmap3D) {\n  const {\n    scalarData,\n    dimensions\n  } = labelmap3D;\n  const labelmaps2D = [];\n  const segmentsOnLabelmap3D = new Set();\n  for (let z = 0; z < dimensions[2]; z++) {\n    const pixelData = scalarData.slice(z * dimensions[0] * dimensions[1], (z + 1) * dimensions[0] * dimensions[1]);\n    const segmentsOnLabelmap = [];\n    for (let i = 0; i < pixelData.length; i++) {\n      const segment = pixelData[i];\n      if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n        segmentsOnLabelmap.push(segment);\n      }\n    }\n    const labelmap2D = {\n      segmentsOnLabelmap,\n      pixelData,\n      rows: dimensions[1],\n      columns: dimensions[0]\n    };\n    if (segmentsOnLabelmap.length === 0) {\n      continue;\n    }\n    segmentsOnLabelmap.forEach(segmentIndex => {\n      segmentsOnLabelmap3D.add(segmentIndex);\n    });\n    labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\n  }\n  labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\n  labelmap3D.labelmaps2D = labelmaps2D;\n  return labelmap3D;\n}\n\nexport { generateLabelMaps2DFrom3D };\n","const checkHasOverlapping = _ref => {\n  let {\n    largerArray,\n    currentTestedArray,\n    newArray\n  } = _ref;\n  return largerArray.some((_, currentImageIndex) => {\n    const originalImagePixelData = currentTestedArray[currentImageIndex];\n    const newImagePixelData = newArray[currentImageIndex];\n    if (!originalImagePixelData || !newImagePixelData) {\n      return false;\n    }\n    return originalImagePixelData.some((originalPixel, currentPixelIndex) => {\n      const newPixel = newImagePixelData[currentPixelIndex];\n      return originalPixel && newPixel;\n    });\n  });\n};\nconst compactMergeSegmentDataWithoutInformationLoss = _ref2 => {\n  let {\n    arrayOfSegmentData,\n    newSegmentData\n  } = _ref2;\n  if (arrayOfSegmentData.length === 0) {\n    arrayOfSegmentData.push(newSegmentData);\n    return;\n  }\n  for (let currentTestedIndex = 0; currentTestedIndex < arrayOfSegmentData.length; currentTestedIndex++) {\n    const currentTestedArray = arrayOfSegmentData[currentTestedIndex];\n    const originalArrayIsLarger = currentTestedArray.length > newSegmentData.length;\n    const largerArray = originalArrayIsLarger ? currentTestedArray : newSegmentData;\n    const hasOverlapping = checkHasOverlapping({\n      currentTestedArray,\n      largerArray,\n      newArray: newSegmentData\n    });\n    if (hasOverlapping) {\n      continue;\n    }\n    largerArray.forEach((_, currentImageIndex) => {\n      const originalImagePixelData = currentTestedArray[currentImageIndex];\n      const newImagePixelData = newSegmentData[currentImageIndex];\n      if (!originalImagePixelData && !newImagePixelData || !newImagePixelData) {\n        return;\n      }\n      if (!originalImagePixelData) {\n        currentTestedArray[currentImageIndex] = newImagePixelData;\n        return;\n      }\n      const mergedPixelData = originalImagePixelData.map((originalPixel, currentPixelIndex) => {\n        const newPixel = newImagePixelData[currentPixelIndex];\n        return originalPixel || newPixel;\n      });\n      currentTestedArray[currentImageIndex] = mergedPixelData;\n    });\n    return;\n  }\n  arrayOfSegmentData.push(newSegmentData);\n};\n\nexport { compactMergeSegmentDataWithoutInformationLoss };\n","import { triggerEvent, eventTarget, imageLoader } from '@cornerstonejs/core';\nimport { utilities as utilities$1 } from '@cornerstonejs/tools';\nimport { utilities, data, normalizers } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport checkOrientation from '../../helpers/checkOrientation.js';\nimport { getValidOrientations, getSegmentMetadata, unpackPixelData, calculateCentroid, readFromUnpackedChunks, alignPixelDataWithSourceData, getSegmentIndex, findReferenceSourceImageId } from '../../Cornerstone/Segmentation_4X.js';\nimport { compactMergeSegmentDataWithoutInformationLoss } from './compactMergeSegData.js';\nimport { Events } from '../../enums/Events.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  decode\n} = utilities.compression;\nconst updateSegmentsOnFrame = _ref => {\n  let {\n    segmentsOnFrame,\n    imageIdIndex,\n    segmentIndex\n  } = _ref;\n  if (!segmentsOnFrame[imageIdIndex]) {\n    segmentsOnFrame[imageIdIndex] = [];\n  }\n  segmentsOnFrame[imageIdIndex].push(segmentIndex);\n};\nconst updateSegmentsPixelIndices = _ref2 => {\n  let {\n    segmentsPixelIndices,\n    segmentIndex,\n    imageIdIndex,\n    indexCache\n  } = _ref2;\n  if (!segmentsPixelIndices.has(segmentIndex)) {\n    segmentsPixelIndices.set(segmentIndex, {});\n  }\n  const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n  segmentIndexObject[imageIdIndex] = indexCache;\n  segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n};\nconst extractInfoFromPerFrameFunctionalGroups = _ref3 => {\n  let {\n    PerFrameFunctionalGroups,\n    sequenceIndex,\n    sopUIDImageIdIndexMap,\n    multiframe\n  } = _ref3;\n  const referencedSOPInstanceUid = PerFrameFunctionalGroups.DerivationImageSequence[0].SourceImageSequence[0].ReferencedSOPInstanceUID;\n  const referencedImageId = sopUIDImageIdIndexMap[referencedSOPInstanceUid];\n  const segmentIndex = getSegmentIndex(multiframe, sequenceIndex);\n  return {\n    referencedSOPInstanceUid,\n    referencedImageId,\n    segmentIndex\n  };\n};\nasync function createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bit packing.\");\n      return;\n    }\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      insertFunction = insertPixelDataPlanar;\n      break;\n    case \"Perpendicular\":\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n  const segmentsOnFrame = [];\n  const imageIdMaps = {\n    indices: {},\n    metadata: {}\n  };\n  const labelMapImages = [];\n  for (let i = 0; i < referencedImageIds.length; i++) {\n    const referenceImageId = referencedImageIds[i];\n    imageIdMaps.indices[referenceImageId] = i;\n    imageIdMaps.metadata[referenceImageId] = metadataProvider.get(\"instance\", referenceImageId);\n    const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referenceImageId);\n    labelMapImages.push(labelMapImage);\n  }\n  const segmentsPixelIndices = new Map();\n  const {\n    hasOverlappingSegments,\n    arrayOfLabelMapImages\n  } = await insertFunction({\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    TypedArrayConstructor\n  });\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelMapImages: arrayOfLabelMapImages,\n    segMetadata,\n    segmentsOnFrame,\n    centroids: centroidXYZ,\n    overlappingSegments: hasOverlappingSegments\n  };\n}\nconst throttledTriggerLoadProgressEvent = utilities$1.throttle(percentComplete => {\n  triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n    percentComplete\n  });\n}, 200);\nfunction insertPixelDataPlanar(_ref4) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref4;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  let overlapping = false;\n  return new Promise(resolve => {\n    const percentImagesPerChunk = 0.1;\n    const imagesPerChunk = Math.ceil(groupsLen * percentImagesPerChunk);\n    const processChunk = firstIndex => {\n      for (let i = firstIndex; i < firstIndex + imagesPerChunk && i < groupsLen; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelDataChunks, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, referencedImageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          return;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const labelmapImage = labelMapImages[imageIdIndex];\n        const labelmap2DView = labelmapImage.getPixelData();\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let k = 0, len = alignedPixelDataI.data.length; k < len; ++k) {\n          if (data[k]) {\n            for (let x = k; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                  return resolve(insertOverlappingPixelDataPlanar({\n                    segmentsOnFrame,\n                    labelMapImages,\n                    pixelDataChunks,\n                    multiframe,\n                    referencedImageIds,\n                    validOrientations,\n                    metadataProvider,\n                    tolerance,\n                    segmentsPixelIndices,\n                    sopUIDImageIdIndexMap,\n                    imageIdMaps\n                  }));\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n      const percentComplete = Math.round(firstIndex / groupsLen * 100);\n      throttledTriggerLoadProgressEvent(percentComplete);\n      if (firstIndex < groupsLen) {\n        setTimeout(() => processChunk(firstIndex + imagesPerChunk), 0);\n      } else {\n        resolve({\n          hasOverlappingSegments: false,\n          arrayOfLabelMapImages: [labelMapImages]\n        });\n      }\n    };\n    const processLabelmapChunk = firstIndex => {\n      const pfSeq = multiframe.PerFrameFunctionalGroupsSequence;\n      const sharedPlaneOrientation = multiframe.SharedFunctionalGroupsSequence.PlaneOrientationSequence?.ImageOrientationPatient;\n      for (let i = firstIndex; i < firstIndex + imagesPerChunk && i < groupsLen; i++) {\n        const PerFrameFunctionalGroups = pfSeq[i];\n        const ImageOrientationPatientI = sharedPlaneOrientation || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = pixelDataChunks.subarray(i * sliceLength, (i + 1) * sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual Labelmap SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, referencedImageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(`Image not present in stack, can't import frame : ${i}.`);\n          continue;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual Labelmap SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const labelmapImage = labelMapImages[imageIdIndex];\n        const labelmap2DView = labelmapImage.getPixelData();\n        const data = alignedPixelDataI.data;\n        let segmentsOnFrameArr = segmentsOnFrame[imageIdIndex];\n        if (!segmentsOnFrameArr) {\n          segmentsOnFrameArr = [];\n          segmentsOnFrame[imageIdIndex] = segmentsOnFrameArr;\n        }\n        const segSet = new Set(segmentsOnFrameArr);\n        for (let k = 0, len = data.length; k < len; ++k) {\n          const segIdx = data[k];\n          if (segIdx !== 0) {\n            labelmap2DView[k] = segIdx;\n            if (!segSet.has(segIdx)) {\n              segmentsOnFrameArr.push(segIdx);\n              segSet.add(segIdx);\n            }\n            if (!segmentsPixelIndices.has(segIdx)) {\n              segmentsPixelIndices.set(segIdx, {});\n            }\n            const segmentPixelInfo = segmentsPixelIndices.get(segIdx);\n            if (!segmentPixelInfo[imageIdIndex]) {\n              segmentPixelInfo[imageIdIndex] = [];\n            }\n            segmentPixelInfo[imageIdIndex].push(k);\n          }\n        }\n      }\n      const percentComplete = Math.round(firstIndex / groupsLen * 100);\n      throttledTriggerLoadProgressEvent(percentComplete);\n      if (firstIndex < groupsLen) {\n        setTimeout(() => processLabelmapChunk(firstIndex + imagesPerChunk), 0);\n      } else {\n        resolve({\n          hasOverlappingSegments: false,\n          arrayOfLabelMapImages: [labelMapImages]\n        });\n      }\n    };\n    if (multiframe.SegmentationType === \"LABELMAP\") {\n      processLabelmapChunk(0);\n    } else {\n      processChunk(0);\n    }\n  });\n}\nconst getAlignedPixelData = _ref5 => {\n  let {\n    sharedImageOrientationPatient,\n    PerFrameFunctionalGroups,\n    pixelDataChunks,\n    sequenceIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance\n  } = _ref5;\n  const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const view = readFromUnpackedChunks(pixelDataChunks, sequenceIndex * sliceLength, sliceLength);\n  const pixelDataI2D = ndarray(view, [Rows, Columns]);\n  const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n  if (!alignedPixelDataI) {\n    throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n  }\n  return alignedPixelDataI;\n};\nconst checkImageDimensions = _ref6 => {\n  let {\n    metadataProvider,\n    imageId,\n    Rows,\n    Columns\n  } = _ref6;\n  const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n  if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n    throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n  }\n};\nconst getArrayOfLabelMapImagesWithSegmentData = _ref7 => {\n  let {\n    arrayOfSegmentData,\n    referencedImageIds\n  } = _ref7;\n  let largestArray = [];\n  for (let i = 0; i < arrayOfSegmentData.length; i++) {\n    const segmentData = arrayOfSegmentData[i];\n    if (segmentData.length > largestArray.length) {\n      largestArray = segmentData;\n    }\n  }\n  return arrayOfSegmentData.map(arr => {\n    const labelMapImages = referencedImageIds.map((referencedImageId, i) => {\n      const hasEmptySegmentData = !arr[i];\n      const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referencedImageId);\n      const pixelData = labelMapImage.getPixelData();\n      if (!hasEmptySegmentData) {\n        for (let j = 0; j < pixelData.length; j++) {\n          pixelData[j] = arr[i][j];\n        }\n      }\n      return labelMapImage;\n    }).filter(Boolean);\n    return labelMapImages;\n  });\n};\nfunction insertOverlappingPixelDataPlanar(_ref8) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref8;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayOfSegmentData = getArrayOfSegmentData({\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  });\n  const arrayOfLabelMapImagesWithSegmentData = getArrayOfLabelMapImagesWithSegmentData({\n    arrayOfSegmentData,\n    referencedImageIds\n  });\n  return {\n    arrayOfLabelMapImages: arrayOfLabelMapImagesWithSegmentData,\n    hasOverlappingSegments: true\n  };\n}\nconst getArrayOfSegmentData = _ref9 => {\n  let {\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  } = _ref9;\n  const arrayOfSegmentData = [];\n  const numberOfSegments = multiframe.SegmentSequence.length;\n  for (let currentSegmentIndex = 1; currentSegmentIndex <= numberOfSegments; ++currentSegmentIndex) {\n    const segmentData = getSegmentData({\n      PerFrameFunctionalGroupsSequence,\n      labelMapImages,\n      sopUIDImageIdIndexMap,\n      multiframe,\n      segmentIndex: currentSegmentIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance,\n      pixelDataChunks,\n      sharedImageOrientationPatient,\n      metadataProvider,\n      imageIdMaps,\n      segmentsOnFrame,\n      segmentsPixelIndices\n    });\n    compactMergeSegmentDataWithoutInformationLoss({\n      arrayOfSegmentData,\n      newSegmentData: segmentData\n    });\n  }\n  return arrayOfSegmentData;\n};\nconst getSegmentData = _ref10 => {\n  let {\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    segmentIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance,\n    pixelDataChunks,\n    sharedImageOrientationPatient,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    segmentsPixelIndices\n  } = _ref10;\n  const segmentData = [];\n  for (let currentLabelMapImageIndex = 0; currentLabelMapImageIndex < labelMapImages.length; currentLabelMapImageIndex++) {\n    const currentLabelMapImage = labelMapImages[currentLabelMapImageIndex];\n    const referencedImageId = currentLabelMapImage.referencedImageId;\n    const PerFrameFunctionalGroupsIndex = PerFrameFunctionalGroupsSequence.findIndex((PerFrameFunctionalGroups, currentSequenceIndex) => {\n      const {\n        segmentIndex: groupsSegmentIndex,\n        referencedImageId: groupsReferenceImageId\n      } = extractInfoFromPerFrameFunctionalGroups({\n        PerFrameFunctionalGroups,\n        sequenceIndex: currentSequenceIndex,\n        sopUIDImageIdIndexMap,\n        multiframe\n      });\n      const isCorrectPerFrameFunctionalGroup = groupsSegmentIndex === segmentIndex && groupsReferenceImageId === currentLabelMapImage.referencedImageId;\n      return isCorrectPerFrameFunctionalGroup;\n    });\n    if (PerFrameFunctionalGroupsIndex === -1) {\n      continue;\n    }\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[PerFrameFunctionalGroupsIndex];\n    const alignedPixelDataI = getAlignedPixelData({\n      sharedImageOrientationPatient,\n      PerFrameFunctionalGroups,\n      pixelDataChunks,\n      sequenceIndex: PerFrameFunctionalGroupsIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance\n    });\n    checkImageDimensions({\n      metadataProvider,\n      Rows,\n      Columns,\n      imageId: referencedImageId\n    });\n    const indexCache = [];\n    const segmentationDataForImageId = alignedPixelDataI.data.map((pixel, pixelIndex) => {\n      const pixelValue = pixel ? segmentIndex : 0;\n      if (pixelValue) {\n        indexCache.push(pixelIndex);\n      }\n      return pixel ? segmentIndex : 0;\n    });\n    const hasWrittenSegmentationData = indexCache.length > 0;\n    if (hasWrittenSegmentationData) {\n      segmentData[currentLabelMapImageIndex] = segmentationDataForImageId;\n    }\n    const imageIdIndex = imageIdMaps.indices[referencedImageId];\n    updateSegmentsOnFrame({\n      imageIdIndex,\n      segmentIndex,\n      segmentsOnFrame\n    });\n    updateSegmentsPixelIndices({\n      imageIdIndex,\n      segmentIndex,\n      segmentsPixelIndices,\n      indexCache\n    });\n  }\n  return segmentData;\n};\n\nexport { createLabelmapsFromBufferInternal, insertOverlappingPixelDataPlanar, insertPixelDataPlanar };\n","import { generateToolState as generateToolState$1 } from '../../Cornerstone/Segmentation.js';\nimport { createLabelmapsFromBufferInternal } from './labelmapImagesFromBuffer.js';\n\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cs3dVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  return generateToolState$1(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance, cs3dVersion);\n}\nfunction createFromDICOMSegBuffer(referencedImageIds, arrayBuffer, _ref) {\n  let {\n    metadataProvider,\n    tolerance = 1e-3\n  } = _ref;\n  return createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, {\n    tolerance\n  });\n}\n\nexport { createFromDICOMSegBuffer, generateToolState };\n","import { CornerstonePMAP } from '../../Cornerstone/index.js';\n\nconst {\n  ParametricMap\n} = CornerstonePMAP;\nconst {\n  generateToolState: generateToolStateCornerstone\n} = ParametricMap;\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  return generateToolStateCornerstone(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n}\n\nexport { generateToolState };\n","function getReferencedFrameOfReferenceSequence(metadata, metadataProvider, dataset) {\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID\n  } = instance;\n  const {\n    ReferencedSeriesSequence\n  } = dataset;\n  return [{\n    FrameOfReferenceUID,\n    RTReferencedStudySequence: [{\n      ReferencedSOPClassUID: dataset.SOPClassUID,\n      ReferencedSOPInstanceUID: dataset.SOPInstanceUID,\n      RTReferencedSeriesSequence: [{\n        SeriesInstanceUID,\n        ContourImageSequence: [...ReferencedSeriesSequence[0].ReferencedInstanceSequence]\n      }]\n    }]\n  }];\n}\n\nexport { getReferencedFrameOfReferenceSequence as default };\n","function getReferencedSeriesSequence(metadata, _index, metadataProvider, DicomMetadataStore) {\n  // grab imageId from toolData\n  const {\n    referencedImageId: imageId\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID,\n    StudyInstanceUID\n  } = instance;\n  const ReferencedSeriesSequence = [];\n  if (SeriesInstanceUID) {\n    const series = DicomMetadataStore.getSeries(StudyInstanceUID, SeriesInstanceUID);\n    const ReferencedSeries = {\n      SeriesInstanceUID,\n      ReferencedInstanceSequence: []\n    };\n    series.instances.forEach(instance => {\n      const {\n        SOPInstanceUID,\n        SOPClassUID\n      } = instance;\n      ReferencedSeries.ReferencedInstanceSequence.push({\n        ReferencedSOPClassUID: SOPClassUID,\n        ReferencedSOPInstanceUID: SOPInstanceUID\n      });\n    });\n    ReferencedSeriesSequence.push(ReferencedSeries);\n  }\n  return ReferencedSeriesSequence;\n}\n\nexport { getReferencedSeriesSequence as default };\n","function getStructureSetModule(contour, index) {\n  const {\n    FrameOfReferenceUID\n  } = contour.metadata;\n  return {\n    ROINumber: index + 1,\n    ROIName: contour.name || `Todo: name ${index + 1}`,\n    ROIDescription: `Todo: description ${index + 1}`,\n    ROIGenerationAlgorithm: \"Todo: algorithm\",\n    ReferencedFrameOfReferenceUID: FrameOfReferenceUID\n  };\n}\n\nexport { getStructureSetModule as default };\n","import { utilities } from '@cornerstonejs/tools';\nimport dcmjs from 'dcmjs';\nimport getPatientModule from './utilities/getPatientModule.js';\nimport getReferencedFrameOfReferenceSequence from './utilities/getReferencedFrameOfReferenceSequence.js';\nimport getReferencedSeriesSequence from './utilities/getReferencedSeriesSequence.js';\nimport getRTROIObservationsSequence from './utilities/getRTROIObservationsSequence.js';\nimport getRTSeriesModule from './utilities/getRTSeriesModule.js';\nimport getStructureSetModule from './utilities/getStructureSetModule.js';\n\nconst {\n  generateContourSetsFromLabelmap,\n  AnnotationToPointData\n} = utilities.contours;\nconst {\n  DicomMetaDictionary\n} = dcmjs.data;\nasync function generateRTSSFromSegmentations(segmentations, metadataProvider, DicomMetadataStore) {\n  const roiContours = [];\n  const contourSets = await generateContourSetsFromLabelmap({\n    segmentations\n  });\n  contourSets.forEach((contourSet, segIndex) => {\n    if (contourSet) {\n      const contourSequence = [];\n      contourSet.sliceContours.forEach(sliceContour => {\n        const sopCommon = metadataProvider.get(\"sopCommonModule\", sliceContour.referencedImageId);\n        const ReferencedSOPClassUID = sopCommon.sopClassUID;\n        const ReferencedSOPInstanceUID = sopCommon.sopInstanceUID;\n        const ContourImageSequence = [{\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID\n        }];\n        const sliceContourPolyData = sliceContour.polyData;\n        sliceContour.contours.forEach((contour, index) => {\n          const ContourGeometricType = contour.type;\n          const NumberOfContourPoints = contour.contourPoints.length;\n          const ContourData = [];\n          contour.contourPoints.forEach(point => {\n            const pointData = sliceContourPolyData.points[point];\n            pointData[0] = +pointData[0].toFixed(2);\n            pointData[1] = +pointData[1].toFixed(2);\n            pointData[2] = +pointData[2].toFixed(2);\n            ContourData.push(pointData[0]);\n            ContourData.push(pointData[1]);\n            ContourData.push(pointData[2]);\n          });\n          contourSequence.push({\n            ContourImageSequence,\n            ContourGeometricType,\n            NumberOfContourPoints,\n            ContourNumber: index + 1,\n            ContourData\n          });\n        });\n      });\n      const segLabel = contourSet.label || `Segment ${segIndex + 1}`;\n      const ROIContour = {\n        name: segLabel,\n        description: segLabel,\n        contourSequence,\n        color: contourSet.color,\n        metadata: contourSet.metadata\n      };\n      roiContours.push(ROIContour);\n    }\n  });\n  const rtMetadata = {\n    name: segmentations.label,\n    label: segmentations.label\n  };\n  const dataset = _initializeDataset(rtMetadata, roiContours[0].metadata, metadataProvider);\n  roiContours.forEach((contour, index) => {\n    const roiContour = {\n      ROIDisplayColor: contour.color || [255, 0, 0],\n      ContourSequence: contour.contourSequence,\n      ReferencedROINumber: index + 1\n    };\n    dataset.StructureSetROISequence.push(getStructureSetModule(contour, index));\n    dataset.ROIContourSequence.push(roiContour);\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(contour.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(contour.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction generateRTSSFromAnnotations(annotations, metadataProvider, DicomMetadataStore) {\n  const rtMetadata = {\n    name: \"RTSS from Annotations\",\n    label: \"RTSS from Annotations\"\n  };\n  const dataset = _initializeDataset(rtMetadata, annotations[0].metadata, metadataProvider);\n  annotations.forEach((annotation, index) => {\n    const ContourSequence = AnnotationToPointData.convert(annotation, index, metadataProvider);\n    dataset.StructureSetROISequence.push(getStructureSetModule(annotation, index));\n    dataset.ROIContourSequence.push(ContourSequence);\n    dataset.RTROIObservationsSequence.push(getRTROIObservationsSequence(annotation, index));\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(annotation.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(annotation.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction _initializeDataset(rtMetadata, imgMetadata, metadataProvider) {\n  const rtSOPInstanceUID = DicomMetaDictionary.uid();\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = imgMetadata;\n  const {\n    studyInstanceUID\n  } = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const patientModule = getPatientModule(imageId, metadataProvider);\n  const rtSeriesModule = getRTSeriesModule(DicomMetaDictionary);\n  return {\n    StructureSetROISequence: [],\n    ROIContourSequence: [],\n    RTROIObservationsSequence: [],\n    ReferencedSeriesSequence: [],\n    ReferencedFrameOfReferenceSequence: [],\n    ...patientModule,\n    ...rtSeriesModule,\n    StudyInstanceUID: studyInstanceUID,\n    SOPClassUID: \"1.2.840.10008.5.1.4.1.1.481.3\",\n    SOPInstanceUID: rtSOPInstanceUID,\n    Manufacturer: \"dcmjs\",\n    Modality: \"RTSTRUCT\",\n    FrameOfReferenceUID,\n    PositionReferenceIndicator: \"\",\n    StructureSetLabel: rtMetadata.label || \"\",\n    StructureSetName: rtMetadata.name || \"\",\n    ReferringPhysicianName: \"\",\n    OperatorsName: \"\",\n    StructureSetDate: DicomMetaDictionary.date(),\n    StructureSetTime: DicomMetaDictionary.time(),\n    _meta: null\n  };\n}\n\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations };\n","function getRTROIObservationsSequence(toolData, index) {\n  return {\n    ObservationNumber: index + 1,\n    ReferencedROINumber: index + 1,\n    RTROIInterpretedType: \"Todo: type\",\n    ROIInterpreter: \"Todo: interpreter\"\n  };\n}\n\nexport { getRTROIObservationsSequence as default };\n","function getPatientModule(imageId, metadataProvider) {\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const generalStudyModule = metadataProvider.get(\"generalStudyModule\", imageId);\n  const patientStudyModule = metadataProvider.get(\"patientStudyModule\", imageId);\n  const patientModule = metadataProvider.get(\"patientModule\", imageId);\n  const patientDemographicModule = metadataProvider.get(\"patientDemographicModule\", imageId);\n  return {\n    Modality: generalSeriesModule.modality,\n    PatientID: patientModule.patientId,\n    PatientName: patientModule.patientName,\n    PatientBirthDate: \"\",\n    PatientAge: patientStudyModule.patientAge,\n    PatientSex: patientDemographicModule.patientSex,\n    PatientWeight: patientStudyModule.patientWeight,\n    StudyDate: generalStudyModule.studyDate,\n    StudyTime: generalStudyModule.studyTime,\n    StudyID: \"ToDo\",\n    AccessionNumber: generalStudyModule.accessionNumber\n  };\n}\n\nexport { getPatientModule as default };\n","function getRTSeriesModule(DicomMetaDictionary) {\n  return {\n    SeriesInstanceUID: DicomMetaDictionary.uid(),\n    // generate a new series instance uid\n    SeriesNumber: \"99\" // Todo:: what should be the series number?\n  };\n}\n\nexport { getRTSeriesModule as default };\n","import { utilities } from '@cornerstonejs/tools';\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations } from './RTSS.js';\n\nconst {\n  generateContourSetsFromLabelmap\n} = utilities.contours;\n\nexport { generateContourSetsFromLabelmap };\n","import { utilities } from 'dcmjs';\nimport Probe from './Probe.js';\n\nvar _KeyImage;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass KeyImage extends Probe {\n  static getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier) {\n    const baseData = super.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier);\n    const {\n      data\n    } = baseData.annotation;\n    data.isPoint = trackingIdentifier.indexOf(\"Point\") !== -1;\n    return baseData;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const tid300Arguments = super.getTID300RepresentationArguments(tool, worldToImageCoords);\n    const {\n      data\n    } = tool;\n    if (data.isPoint) {\n      if (data.seriesLevel) {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesPointIdentifier;\n      } else {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingPointIdentifier;\n      }\n    }\n    if (data.seriesLevel) {\n      tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesIdentifier;\n    }\n    if (!tid300Arguments.points.length) {\n      tid300Arguments.points.push({\n        x: 0,\n        y: 0\n      });\n    }\n    return tid300Arguments;\n  }\n}\n_KeyImage = KeyImage;\n_KeyImage.init(\"KeyImage\", TID300Point, {\n  parentType: Probe.toolType\n});\n_KeyImage.trackingSeriesIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Series`;\n_KeyImage.trackingPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Point`;\n_KeyImage.trackingSeriesPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:SeriesPoint`;\n\nexport { KeyImage, KeyImage as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport CodingScheme from './CodingScheme.js';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport Bidirectional from './Bidirectional.js';\nimport Angle from './Angle.js';\nimport CobbAngle from './CobbAngle.js';\nimport CircleROI from './CircleROI.js';\nimport EllipticalROI from './EllipticalROI.js';\nimport RectangleROI from './RectangleROI.js';\nimport Length from './Length.js';\nimport PlanarFreehandROI from './PlanarFreehandROI.js';\nimport Probe from './Probe.js';\nimport UltrasoundDirectional from './UltrasoundDirectional.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport * as index from './Segmentation/index.js';\nimport * as index$1 from './ParametricMap/index.js';\nimport * as index$2 from './RTStruct/index.js';\nimport KeyImage from './KeyImage.js';\n\nconst Cornerstone3DSR = {\n  BaseAdapter3D,\n  Bidirectional,\n  CobbAngle,\n  Angle,\n  Length,\n  CircleROI,\n  EllipticalROI,\n  RectangleROI,\n  ArrowAnnotate,\n  Probe,\n  PlanarFreehandROI,\n  UltrasoundDirectional,\n  KeyImage,\n  MeasurementReport,\n  CodeScheme: CodingScheme,\n  CORNERSTONE_3D_TAG\n};\nconst Cornerstone3DSEG = {\n  Segmentation: index\n};\nconst Cornerstone3DPMAP = {\n  ParametricMap: index$1\n};\nconst Cornerstone3DRT = {\n  RTSS: index$2\n};\n\nexport { Cornerstone3DPMAP, Cornerstone3DRT, Cornerstone3DSEG, Cornerstone3DSR };\n","import { data } from 'dcmjs';\n\nconst {\n  Colors,\n  BitArray\n} = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n  const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n  rgba.push(255);\n  return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n  const Zx = x[1] * y[2] - x[2] * y[1];\n  const Zy = x[2] * y[0] - x[0] * y[2];\n  const Zz = x[0] * y[1] - x[1] * y[0];\n  out[0] = Zx;\n  out[1] = Zy;\n  out[2] = Zz;\n}\nfunction norm(x) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  switch (n) {\n    case 1:\n      return Math.abs(x);\n    case 2:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n    case 3:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n    default:\n      {\n        let sum = 0;\n        for (let i = 0; i < n; i++) {\n          sum += x[i] * x[i];\n        }\n        return Math.sqrt(sum);\n      }\n  }\n}\nfunction normalize(x) {\n  const den = norm(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n    x[2] /= den;\n  }\n  return den;\n}\nfunction subtract(a, b, out) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n  const geometry = {};\n  const pixelMeasures = dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  const planeOrientation = dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n  // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n  //\n  // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n  // sort them to obtain the first and last position along the acquisition axis.\n  const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n  const lastFunctionalGroup = PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n  const firstPosition = firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  const lastPosition = lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.origin = firstPosition;\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  geometry.spacing = [pixelMeasures.PixelSpacing[1], pixelMeasures.PixelSpacing[0], pixelMeasures.SpacingBetweenSlices].map(Number);\n  geometry.dimensions = [dataset.Columns, dataset.Rows, PerFrameFunctionalGroups.length].map(Number);\n  const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  const columnStepToPatient = orientation.slice(0, 3);\n  const rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n  geometry.sliceStep = [];\n  subtract(lastPosition, firstPosition, geometry.sliceStep);\n  normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient.concat(rowStepToPatient).concat(geometry.sliceStep);\n  return geometry;\n}\nclass Segmentation {\n  constructor() {}\n\n  /**\n   * Produces an array of Segments from an input DICOM Segmentation dataset\n   *\n   * Segments are returned with Geometry values that can be used to create\n   * VTK Image Data objects.\n   *\n   * @example Example usage to create VTK Volume actors from each segment:\n   *\n   * const actors = [];\n   * const segments = generateToolState(dataset);\n   * segments.forEach(segment => {\n   *   // now make actors using the segment information\n   *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n   *        name: \"Scalars\",\n   *        numberOfComponents: 1,\n   *        values: segment.pixelData,\n   *    });\n   *\n   *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n   *    imageData.getPointData().setScalars(scalarArray);\n   *    imageData.setDimensions(geometry.dimensions);\n   *    imageData.setSpacing(geometry.spacing);\n   *    imageData.setOrigin(geometry.origin);\n   *    imageData.setDirection(geometry.direction);\n   *\n   *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n   *    mapper.setInputData(imageData);\n   *    mapper.setSampleDistance(2.);\n   *\n   *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n   *    actor.setMapper(mapper);\n   *\n   *    actors.push(actor);\n   * });\n   *\n   * @param dataset\n   * @return {{}}\n   */\n  static generateSegments(dataset) {\n    if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n      dataset.SegmentSequence = [dataset.SegmentSequence];\n    }\n    dataset.SegmentSequence.forEach(segment => {\n      // TODO: other interesting fields could be extracted from the segment\n      // TODO: Read SegmentsOverlay field\n      // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n      // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n      // Why was this example converting to RGBA with 0-255 values?\n      const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n      segments[segment.SegmentNumber] = {\n        color,\n        functionalGroups: [],\n        offset: null,\n        size: null,\n        pixelData: null\n      };\n    });\n\n    // make a list of functional groups per segment\n    dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n      const segmentNumber = functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n      segments[segmentNumber].functionalGroups.push(functionalGroup);\n    });\n\n    // determine per-segment index into the pixel data\n    // TODO: only handles one-bit-per pixel\n    const frameSize = Math.ceil(dataset.Rows * dataset.Columns / 8);\n    let nextOffset = 0;\n    Object.keys(segments).forEach(segmentNumber => {\n      const segment = segments[segmentNumber];\n      segment.numberOfFrames = segment.functionalGroups.length;\n      segment.size = segment.numberOfFrames * frameSize;\n      segment.offset = nextOffset;\n      nextOffset = segment.offset + segment.size;\n      const packedSegment = dataset.PixelData.slice(segment.offset, nextOffset);\n      segment.pixelData = BitArray.unpack(packedSegment);\n      const geometry = geometryFromFunctionalGroups(dataset, segment.functionalGroups);\n      segment.geometry = geometry;\n    });\n    return segments;\n  }\n}\n\nexport { Segmentation as default };\n","import Segmentation from './Segmentation.js';\n\nconst VTKjsSEG = {\n  Segmentation\n};\n\nexport { VTKjsSEG };\n","import { CornerstoneSR, CornerstoneSEG, CornerstonePMAP } from './Cornerstone/index.js';\nimport { Cornerstone3DSR, Cornerstone3DSEG, Cornerstone3DPMAP, Cornerstone3DRT } from './Cornerstone3D/index.js';\nimport { VTKjsSEG } from './VTKjs/index.js';\nimport './enums/Events.js';\nimport 'dcmjs';\nimport 'buffer';\n\nconst adaptersSR = {\n  Cornerstone: CornerstoneSR,\n  Cornerstone3D: Cornerstone3DSR\n};\nconst adaptersSEG = {\n  Cornerstone: CornerstoneSEG,\n  Cornerstone3D: Cornerstone3DSEG,\n  VTKjs: VTKjsSEG\n};\nconst adaptersPMAP = {\n  Cornerstone: CornerstonePMAP,\n  Cornerstone3D: Cornerstone3DPMAP\n};\nconst adaptersRT = {\n  Cornerstone3D: Cornerstone3DRT\n};\n\nexport { adaptersPMAP, adaptersRT, adaptersSEG, adaptersSR };\n","import { data } from 'dcmjs';\nimport { Buffer } from 'buffer';\n\nconst {\n  datasetToDict\n} = data;\nfunction downloadDICOMData(bufferOrDataset, filename) {\n  let blob;\n  if (bufferOrDataset instanceof ArrayBuffer) {\n    blob = new Blob([bufferOrDataset], {\n      type: \"application/dicom\"\n    });\n  } else {\n    if (!bufferOrDataset._meta) {\n      throw new Error(\"Dataset must have a _meta property\");\n    }\n    const buffer = Buffer.from(datasetToDict(bufferOrDataset).write());\n    blob = new Blob([buffer], {\n      type: \"application/dicom\"\n    });\n  }\n  const link = document.createElement(\"a\");\n  link.href = window.URL.createObjectURL(blob);\n  link.download = filename;\n  link.click();\n}\n\nexport { downloadDICOMData };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_CUT_MERGE_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_CUT_MERGE_PROCESS_COMPLETED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":["toArray","x","Array","isArray","codeMeaningEquals","codeMeaningName","contentItem","ConceptNameCodeSequence","CodeMeaning","TID1500","addAccessors","StructuredReport","Normalizer","TID1500MeasurementReport","TID1501MeasurementGroup","DicomMetaDictionary","FINDING","CodingSchemeDesignator","CodeValue","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","group","code","oldCode","getMeasurementGroup","toolType","toolData","ReferencedSOPSequence","toolTypeData","toolClass","MeasurementReport","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","data","length","Measurements","map","tool","adapterClass","args","getTID300RepresentationArguments","TID300Representation","getTID300ContentItem","getSetupMeasurementData","MeasurementGroup","ContentSequence","contentSequenceArr","findingGroup","find","findingSiteGroups","filter","NUMGroup","ValueType","SCOORDGroup","ReferencedSOPInstanceUID","ReferencedFrameNumber","defaultState","sopInstanceUid","frameIndex","complete","finding","ConceptCodeSequence","undefined","findingSites","fsg","description","findingSite","location","generateReport","toolState","metadataProvider","options","allMeasurementGroups","firstImageId","Object","keys","Error","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","forEach","imageId","sopCommonModule","frameNumber","toolTypes","ReferencedSOPClassUID","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","measurementGroups","push","concat","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","StudyInstanceUID","SeriesInstanceUID","_meta","FileMetaInformationVersion","Value","buffer","vr","TransferSyntaxUID","ImplementationClassUID","uid","ImplementationVersionName","_vrMap","PixelData","report","dataset","assign","SpecificCharacterSet","generateToolState","hooks","arguments","ContentTemplateSequence","TemplateIdentifier","imagingMeasurementContent","measurementData","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","key","measurementGroup","TrackingIdentifierValue","TextValue","getToolClass","tc","isValidCornerstoneTrackingIdentifier","measurement","getMeasurementData","console","log","registerTool","utilityToolType","MEASUREMENT_BY_TOOLTYPE","CORNERSTONE_4_TAG","Length","TID300Length","TID300","LENGTH","state","MeasuredValueSequence","NumericValue","handles","start","end","textBox","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","y","GraphicData","point1","point2","distance","trackingIdentifierTextValue","TrackingIdentifier","includes","cornerstone4Tag","split","Polyline","TID300Polyline","FreehandRoi","points","active","cachedStats","area","color","invalidated","i","perimeter","Bidirectional","TID300Bidirectional","BIDIRECTIONAL","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","bottomRight","Math","max","highlight","index","perpendicularStart","perpendicularEnd","isCreating","toolName","visible","longAxis","shortAxis","longAxisLength","shortAxisLength","Ellipse","TID300Ellipse","ELLIPTICALROI","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","abs","halfYLength","center","Circle","TID300Circle","CIRCLEROI","CircleRoi","radius","PI","Point","TID300Point","ARROW_ANNOTATE","CORNERSTONEFREETEXT","ArrowAnnotate","text","TID300RepresentationArguments","CobbAngle","TID300CobbAngle","COBB_ANGLE","rAngle","start2","end2","point3","point4","Angle","TID300Angle","ANGLE","middle","RectangleRoi","intermediate","DicomMessage","getDatasetsFromImages","images","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","normalizeToDataset","rotateDirectionCosinesInPlane","flipImageOrientationPatient","flipIOP","flipMatrix2D","rotateMatrix902D","orientation","datasetToBlob","BitArray","Segmentation","SegmentationDerivation","generateSegmentation","brushData","includeSliceSpacing","segments","image0","dims","columns","rows","z","xy","seg","numSegments","_getSegCount","multiframe","_createSegFromImages","referencedFramesPerSegment","segmentIndicies","imageIdSpecificToolState","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","element","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","imageIds","imagePlaneModule","warn","validOrientations","iop","orientations","h","v","iop90","getValidOrientations","rowCosines","columnCosines","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData","SegmentIdentificationSequence","ReferencedSegmentNumber","SourceImageSequence","DerivationImageSequence","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","referencedFrames","pixelDataIndex","brushPixelData","p","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","Number","getImageIdOfReferencedFrame","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","dx","iop1","iop2","nearlyEqual","compareArrays","array1","array2","tolerance","checkOrientation","sourceDataDimensions","some","operation","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","Events","encode","decode","compression","generateSegmentationDefaultOptions","rleEncode","fillSegmentation","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","labelmapIndex","labelmap3D","labelmaps2D","metadata","labelmap2D","segmentsOnLabelmap","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","frame","findReferenceSourceImageId","frameSegment","sopUIDImageIdIndexMap","FrameOfReferenceUID","PerFrameFunctionalGroup","frameSourceImageSequence","baseImageId","replace","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","segFramePosition","sourceImageMetadata","isMultiframeImage","framePosition","imagePositionPatient","getImageIdOfSourceImagebyGeometry","insertOverlappingPixelDataPlanar","segmentsOnFrame","segmentsOnFrameArray","labelmapBufferArray","TypedArrayConstructor","segmentsPixelIndices","arrayBufferLength","BYTES_PER_ELEMENT","M","m","tempBuffer","slice","tempSegmentsOnFrame","structuredClone","numberOfSegs","segmentIndexToProcess","groupsLen","getSegmentIndex","view","readFromUnpackedChunks","imageIdIndex","findIndex","labelmap2DView","segmentOnFrame","j","len","ArrayBuffer","insertPixelDataPlanar","imageIdMaps","eventTarget","triggerEvent","chunkSize","ceil","shouldTriggerEvent","overlapping","Promise","resolve","processInChunks","min","has","set","indices","byteOffset","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","error","maxBytesPerChunk","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","floor","endByte","chunk","unpackedChunk","getUnpackedChunks","Uint16Array","imageMetadata","offset","mapping","totalBytes","reduce","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","calculateCentroid","imageIdIndexBufferIndex","xAcc","yAcc","zAcc","worldXAcc","worldYAcc","worldZAcc","count","bufferIndices","entries","debug","rowPixelSpacing","columnPixelSpacing","bufferIndex","image","world","async","referencedImageIds","skipOverlapping","pixelDataChunks","acc","insertFunction","frameSegmentsMapping","Map","segmentArray","role","temp2DArray","fill","checkSEGsOverlapping","curr","overlappingSegments","centroidXYZ","centroids","labelmaps3DorBrushData","cornerstoneToolsVersion","imageIdsIndex","CornerstoneSR","CornerstoneSEG","CornerstonePMAP","ParametricMap","TypedArrayClass","Int16Array","Uint32Array","Int32Array","PixelRepresentation","FloatPixelData","Float32Array","DoubleFloatPixelData","Float64Array","getPixelData","Perpendicular","Oblique","sourcePixelData","targetPixelData","constructor","numSlices","sourceSliceDataView","CORNERSTONE_3D_TAG","patientStudyTags","seriesTags","copySeriesTags","src","study","tagKey","value","CodingScheme","codeValues","NO_IMAGE_ID","_MeasurementReport","worldToImageCoords","this","measurementAdapterByToolType","getCornerstoneLabelFromDefaultState","cornersoneFreeTextCodingValue","freeTextLabel","fs","generateDatasetMeta","processSCOORDGroup","_ref","sopInstanceUIDToImageIdMap","referencedImageId","annotation","annotationUID","frameOfReferenceUID","label","processSCOORD3DGroup","_ref2","SCOORD3DGroup","ReferencedFrameOfReferenceUID","getSpatialCoordinatesState","_ref3","processSpatialCoordinatesGroup","_ref4","generateReferencedSOPSequence","_ref5","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","effectiveImageId","getImageIdFromVolume","instance","dsd","generateDerivationSourceDataset","_ref6","referenceToolData","volumeId","cache","getVolume","is3DSR","tid1500MeasurementReport","SOPClassUID","sopClassUIDsByName","Comprehensive3DSR","imageToWorldCoords","measurementGroupContentSequence","trackingIdentifierGroup","trackingIdentifierValue","trackingUniqueIdentifierGroup","trackingUniqueIdentifierValue","UID","toolAdapter","getAdapterForTrackingIdentifier","TrackingUniqueIdentifier","e","registerName","measurementAdapterByTrackingIdentifier","registerTrackingIdentifier","_len","trackingIdentifiers","_key","identifier","trackingIdentifier","adapter","adapterTest","values","copyStudyTags","BaseAdapter3D","init","representation","parentType","Set","alternateTrackingIdentifier","add","registerLegacy","registerSubType","subAdapter","create","startsWith","_imageToWorldCoords","seriesLevel","indexOf","getTID300RepresentationArgumentsSCOORD3D","point","pointImage","_ArrowAnnotate","_trackingIdentifier","getMeasurementDataFromScoord","getMeasurementDataFromScoord3D","worldCoords","arrowFirst","activeHandleIndex","imagePixelModule","xOffset","yOffset","secondPoint","pointImage2","use3DSpatialCoordinates","_Bidirectional","getMeasurementDataFromScoord3d","width","firstPointPairs","secondPointPairs","shortAxisPoints","longAxisPoints","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","longAxisStart","longAxisEnd","shortAxisStart","shortAxisEnd","cachedStatsKeys","_Angle","angle","start1","_CobbAngle","end1","_CircleROI","CircleROI","pointsWorld","worldPos","EPSILON","EllipticalROI","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","ellipsePoints","rotation","top","bottom","left","right","_RectangleROI","RectangleROI","corners","_Length","_PlanarFreehandROI","PlanarFreehandROI","isOpenContour","closedContourThreshold","pop","contour","polyline","closed","firstPoint","areaUnit","modalityUnit","mean","stdDev","_Probe","Probe","super","UltrasoundDirectional","SopClassUID","SOPInstanceUID","SopInstanceUID","voxelManager","getScalarData","_createMultiframeSegmentationFromReferencedImages","generateLabelMaps2DFrom3D","scalarData","dimensions","segmentsOnLabelmap3D","from","checkHasOverlapping","largerArray","currentTestedArray","newArray","_","currentImageIndex","originalImagePixelData","newImagePixelData","originalPixel","currentPixelIndex","newPixel","compactMergeSegmentDataWithoutInformationLoss","arrayOfSegmentData","newSegmentData","currentTestedIndex","mergedPixelData","updateSegmentsOnFrame","updateSegmentsPixelIndices","extractInfoFromPerFrameFunctionalGroups","sequenceIndex","referencedSOPInstanceUid","throttledTriggerLoadProgressEvent","utilities","labelMapImages","imagesPerChunk","processChunk","firstIndex","k","hasOverlappingSegments","arrayOfLabelMapImages","processLabelmapChunk","pfSeq","sharedPlaneOrientation","subarray","segmentsOnFrameArr","segSet","segmentPixelInfo","getAlignedPixelData","checkImageDimensions","getArrayOfLabelMapImagesWithSegmentData","_ref7","largestArray","segmentData","arr","hasEmptySegmentData","labelMapImage","imageLoader","Boolean","_ref8","getArrayOfSegmentData","_ref9","numberOfSegments","currentSegmentIndex","getSegmentData","_ref10","currentLabelMapImageIndex","currentLabelMapImage","PerFrameFunctionalGroupsIndex","currentSequenceIndex","groupsSegmentIndex","groupsReferenceImageId","segmentationDataForImageId","pixel","pixelIndex","createFromDICOMSegBuffer","referenceImageId","createLabelmapsFromBufferInternal","generateToolStateCornerstone","getReferencedFrameOfReferenceSequence","RTReferencedStudySequence","RTReferencedSeriesSequence","ContourImageSequence","ReferencedInstanceSequence","getReferencedSeriesSequence","_index","DicomMetadataStore","series","getSeries","ReferencedSeries","instances","getStructureSetModule","ROINumber","ROIName","name","ROIDescription","ROIGenerationAlgorithm","generateContourSetsFromLabelmap","AnnotationToPointData","generateRTSSFromSegmentations","segmentations","roiContours","contourSet","segIndex","contourSequence","sliceContours","sliceContour","sopCommon","sliceContourPolyData","polyData","contours","ContourGeometricType","type","NumberOfContourPoints","contourPoints","ContourData","pointData","toFixed","ContourNumber","segLabel","ROIContour","_initializeDataset","roiContour","ROIDisplayColor","ContourSequence","ReferencedROINumber","StructureSetROISequence","ROIContourSequence","ReferencedFrameOfReferenceSequence","generateRTSSFromAnnotations","annotations","convert","RTROIObservationsSequence","ObservationNumber","RTROIInterpretedType","ROIInterpreter","getRTROIObservationsSequence","rtMetadata","imgMetadata","rtSOPInstanceUID","patientModule","generalStudyModule","patientStudyModule","patientDemographicModule","Modality","modality","PatientID","patientId","PatientName","patientName","PatientBirthDate","PatientAge","patientAge","PatientSex","patientSex","PatientWeight","patientWeight","StudyDate","studyDate","StudyTime","studyTime","StudyID","AccessionNumber","accessionNumber","getPatientModule","rtSeriesModule","SeriesNumber","getRTSeriesModule","Manufacturer","PositionReferenceIndicator","StructureSetLabel","StructureSetName","ReferringPhysicianName","OperatorsName","StructureSetDate","date","StructureSetTime","time","_KeyImage","KeyImage","baseData","isPoint","tid300Arguments","trackingSeriesPointIdentifier","trackingPointIdentifier","trackingSeriesIdentifier","Cornerstone3DSR","CodeScheme","Cornerstone3DSEG","Cornerstone3DPMAP","Cornerstone3DRT","RTSS","Colors","normalize","den","n","sum","norm","adaptersSR","Cornerstone","Cornerstone3D","adaptersSEG","VTKjs","generateSegments","cielab","rgba","dicomlab2RGB","dicomlab2RGBA","RecommendedDisplayCIELabValue","SegmentNumber","functionalGroups","size","functionalGroup","segmentNumber","frameSize","nextOffset","packedSegment","geometry","pixelMeasures","PixelMeasuresSequence","planeOrientation","firstFunctionalGroup","lastFunctionalGroup","firstPosition","lastPosition","origin","spacing","PixelSpacing","SpacingBetweenSlices","columnStepToPatient","rowStepToPatient","a","b","out","planeNormal","Zx","Zy","Zz","cross","sliceStep","direction","geometryFromFunctionalGroups","adaptersPMAP","adaptersRT","datasetToDict","downloadDICOMData","bufferOrDataset","filename","blob","Blob","write","link","document","createElement","href","window","URL","createObjectURL","download","click","ChangeTypes","SegmentationRepresentations","StrategyCallbacks","MouseBindings","KeyboardBindings","ToolModes","Swipe","AnnotationStyleStates","module","exports","obj","isBuffer","iota","hasTypedArrays","compare1st","order","stride","terms","sort","compileConstructor","dtype","dimension","className","join","useGetters","Function","procedure","CACHED_CONSTRUCTORS","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","idx","shape","ctor","array","d","sz","prototype","toString","call","arrayDType","ctor_list"],"sourceRoot":""}