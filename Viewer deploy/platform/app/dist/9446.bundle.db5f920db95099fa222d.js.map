{"version":3,"file":"9446.bundle.db5f920db95099fa222d.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js"],"sourcesContent":["function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n","import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey) {\n            return kb.ShiftCtrl;\n        }\n        if (evt.altKey) {\n            return kb.ShiftAlt;\n        }\n        if (evt.metaKey) {\n            return kb.ShiftMeta;\n        }\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey) {\n            return kb.CtrlAlt;\n        }\n        if (evt.metaKey) {\n            return kb.CtrlMeta;\n        }\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n","import { getEnabledElement, triggerEvent, eventTarget, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nfunction triggerAnnotationAddedForElement(annotation, element) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewportId } = enabledElement;\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId: renderingEngine.id,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationAddedForFOR(annotation) {\n    const { toolName } = annotation.metadata;\n    const toolGroups = getToolGroupsWithToolName(toolName);\n    if (!toolGroups.length) {\n        return;\n    }\n    const viewportsToRender = [];\n    toolGroups.forEach((toolGroup) => {\n        toolGroup.viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const { FrameOfReferenceUID } = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n                viewportsToRender.push(viewportInfo);\n            }\n        });\n    });\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = { annotation };\n    if (!viewportsToRender.length) {\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return;\n    }\n    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n        eventDetail.viewportId = viewportId;\n        eventDetail.renderingEngineId = renderingEngineId;\n        triggerEvent(eventTarget, eventType, eventDetail);\n    });\n}\nfunction triggerAnnotationRemoved(eventDetail) {\n    const eventType = Events.ANNOTATION_REMOVED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationModified(annotation, element, changeType = ChangeTypes.HandlesUpdated) {\n    const enabledElement = element && getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement || {};\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n        changeType,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationCompleted(annotation) {\n    const eventDetail = {\n        annotation,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {\n    const eventDetail = {\n        annotation,\n        contourHoleProcessingEnabled,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction _triggerAnnotationCompleted(eventDetail) {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, triggerAnnotationModified, triggerAnnotationCompleted, triggerContourAnnotationCompleted, };\n","import { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { setAnnotationManager } from './annotationState';\nconst defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nsetAnnotationManager(defaultManager);\nexport function resetAnnotationManager() {\n    setAnnotationManager(defaultManager);\n}\n","const checkAndDefineTextBoxProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.handles) {\n        annotation.data.handles = {};\n    }\n    if (!annotation.data.handles.textBox) {\n        annotation.data.handles.textBox = {};\n    }\n    return annotation;\n};\nconst checkAndDefineCachedStatsProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.cachedStats) {\n        annotation.data.cachedStats = {};\n    }\n    return annotation;\n};\nexport { checkAndDefineTextBoxProperty, checkAndDefineCachedStatsProperty };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationAdded(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_ADDED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationModified(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {\n    const eventDetail = {\n        segmentationId,\n        type,\n        viewportId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {\n    const eventDetail = {\n        viewportId,\n        segmentationId,\n        type,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\n","import { getSegmentationRepresentation } from '../getSegmentationRepresentation';\nexport function internalGetHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\n","import { state } from '../state';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i]) {\n                continue;\n            }\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { getInterpolatedPoints, shouldSmooth, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        annotation,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;\n    this.createMemo(element, annotation);\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    if (annotation.autoGenerated) {\n        annotation.autoGenerated = false;\n    }\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n        annotation,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = getArea(pointSet1);\n    const areaPointSet2 = getArea(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration, annotation)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        if (annotation.autoGenerated) {\n            annotation.autoGenerated = false;\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { ChangeTypes, Events } from '../../../enums';\nimport { state } from '../../../store/state';\nimport { vec3 } from 'gl-matrix';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../../stateManagement/annotation/helpers/state';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n        this.configuration.contourHoleAdditionModifierKey;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};\n    if (!spacing || !xDir || !yDir) {\n        return;\n    }\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n        contourHoleProcessingEnabled,\n        newAnnotation: true,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;\n    this.createMemo(element, annotation, { newAnnotation });\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n        annotation.invalidated = true;\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    if (annotation.invalidated) {\n        triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n    }\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.doneEditMemo();\n    this.drawData.newAnnotation = false;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction completeDrawClosedContour(element, options) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n    if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n        return false;\n    }\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    if (!textBox?.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        if (indexToRemoveUpTo === 1) {\n            this.drawData.canvasPoints = canvasPoints.splice(1);\n        }\n        else {\n            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n        }\n    }\n}\nfunction completeDrawOpenContour(element, options) {\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled } = options ?? {};\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: false,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    if (!textBox.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    const remainingPoints = canvasPoints.slice(crossingIndex);\n    const newArea = polyline.getArea(remainingPoints);\n    if (utilities.isEqual(newArea, 0)) {\n        canvasPoints.splice(crossingIndex + 1);\n        return;\n    }\n    canvasPoints.splice(0, crossingIndex);\n    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n    if (this.completeDrawClosedContour(element, options)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this.doneEditMemo();\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    this.createMemo(element, this.commonData.annotation);\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    triggerAnnotationModified(annotation, element);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.doneEditMemo();\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: false,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        const worldPoints = annotation.data.contour.polyline;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle?.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawPath as drawPathSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport getContourHolesDataCanvas from '../../../utilities/contours/getContourHolesDataCanvas';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n    });\n    const { closed: isClosedContour } = annotation.data.contour;\n    const options = {\n        color,\n        width: lineWidth,\n        lineDash,\n        fillColor,\n        fillOpacity,\n        closePath: isClosedContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.contour.closed) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n    else {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [canvasPolyline, ...childContours];\n    const polylineUID = '1';\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { openUShapeContourVectorToPeak } = annotation.data;\n    const { polyline } = annotation.data.contour;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.closePath = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [fusedCanvasPoints, ...childContours];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    if (annotation.parentAnnotationUID && options.fillOpacity) {\n        options.fillOpacity = 0;\n    }\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const polylineUID = '1';\n    const center = canvasPolyline[0];\n    const radius = 6;\n    const numberOfPoints = 100;\n    const circlePoints = [];\n    for (let i = 0; i < numberOfPoints; i++) {\n        const angle = (i / numberOfPoints) * 2 * Math.PI;\n        const x = center[0] + radius * Math.cos(angle);\n        const y = center[1] + radius * Math.sin(angle);\n        circlePoints.push([x, y]);\n    }\n    const crosshair = [\n        [center[0] - radius * 2, center[1]],\n        [center[0] + radius * 2, center[1]],\n        [center[0], center[1] - radius * 2],\n        [center[0], center[1] + radius * 2],\n    ];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);\n    const allContours = [circlePoints, ...childContours];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderPointContourWithMarker =\n        renderPointContourWithMarker.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n","import { BaseVolumeViewport, cache, getEnabledElement, metaData, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { addAnnotation, removeAnnotation, getAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport ChangeTypes from '../../enums/ChangeTypes';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { addContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst { DefaultHistoryMemo } = csUtils.HistoryMemo;\nconst { PointsManager } = csUtils;\nclass AnnotationTool extends AnnotationDisplayTool {\n    static createAnnotation(...annotationBaseData) {\n        let annotation = {\n            annotationUID: null,\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.toolName,\n            },\n            data: {\n                text: '',\n                handles: {\n                    points: new Array(),\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                label: '',\n            },\n        };\n        for (const baseData of annotationBaseData) {\n            annotation = csUtils.deepMerge(annotation, baseData);\n        }\n        return annotation;\n    }\n    static createAnnotationForViewport(viewport, ...annotationBaseData) {\n        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);\n    }\n    static createAndAddAnnotation(viewport, ...annotationBaseData) {\n        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationModified(annotation, viewport.element);\n    }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation.annotationUID) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n        this.isSuvScaled = AnnotationTool.isSuvScaled;\n        if (toolProps.configuration?.getTextLines) {\n            this.configuration.getTextLines = toolProps.configuration.getTextLines;\n        }\n        if (toolProps.configuration?.statsCalculator) {\n            this.configuration.statsCalculator =\n                toolProps.configuration.statsCalculator;\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { isCanvasAnnotation } = data;\n        const { points, textBox } = data.handles;\n        if (textBox) {\n            const { worldBoundingBox } = textBox;\n            if (worldBoundingBox) {\n                const canvasBoundingBox = {\n                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n                };\n                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                    data.handles.activeHandleIndex = null;\n                    return textBox;\n                }\n            }\n        }\n        for (let i = 0; i < points?.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = isCanvasAnnotation\n                ? point.slice(0, 2)\n                : viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    static isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = csUtils.getVolumeId(targetId);\n            const volume = cache.getVolume(volumeId);\n            return volume?.scaling?.PT !== undefined;\n        }\n        const scalingModule = imageId && metaData.get('scalingModule', imageId);\n        return typeof scalingModule?.suvbw === 'number';\n    }\n    getAnnotationStyle(context) {\n        const { annotation, styleSpecifier } = context;\n        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);\n        const { annotationUID } = annotation;\n        const visibility = isAnnotationVisible(annotationUID);\n        const locked = isAnnotationLocked(annotationUID);\n        const lineWidth = getStyle('lineWidth');\n        const lineDash = getStyle('lineDash');\n        const angleArcLineDash = getStyle('angleArcLineDash');\n        const color = getStyle('color');\n        const markerSize = getStyle('markerSize');\n        const shadow = getStyle('shadow');\n        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        return {\n            visibility,\n            locked,\n            color,\n            lineWidth,\n            lineDash,\n            lineOpacity: 1,\n            fillColor: color,\n            fillOpacity: 0,\n            shadow,\n            textbox: textboxStyle,\n            markerSize,\n            angleArcLineDash,\n        };\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n    static createAnnotationState(annotation, deleting) {\n        const { data, annotationUID } = annotation;\n        const cloneData = {\n            ...data,\n            cachedStats: {},\n        };\n        delete cloneData.contour;\n        delete cloneData.spline;\n        const state = {\n            annotationUID,\n            data: structuredClone(cloneData),\n            deleting,\n        };\n        const contour = data.contour;\n        if (contour) {\n            state.data.contour = {\n                ...contour,\n                polyline: null,\n                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),\n            };\n        }\n        return state;\n    }\n    static createAnnotationMemo(element, annotation, options) {\n        if (!annotation) {\n            return;\n        }\n        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};\n        const { annotationUID } = annotation;\n        const state = AnnotationTool.createAnnotationState(annotation, deleting);\n        const annotationMemo = {\n            restoreMemo: () => {\n                const newState = AnnotationTool.createAnnotationState(annotation, deleting);\n                const { viewport } = getEnabledElement(element) || {};\n                viewport?.setViewReference(annotation.metadata);\n                if (state.deleting === true) {\n                    state.deleting = false;\n                    Object.assign(annotation.data, state.data);\n                    if (annotation.data.contour) {\n                        const annotationData = annotation.data;\n                        annotationData.contour.polyline = state.data.contour.pointsManager.points;\n                        delete state.data.contour.pointsManager;\n                        if (annotationData.segmentation) {\n                            addContourSegmentationAnnotation(annotation);\n                        }\n                    }\n                    state.data = newState.data;\n                    addAnnotation(annotation, element);\n                    setAnnotationSelected(annotation.annotationUID, true);\n                    viewport?.render();\n                    return;\n                }\n                if (state.deleting === false) {\n                    state.deleting = true;\n                    state.data = newState.data;\n                    setAnnotationSelected(annotation.annotationUID);\n                    removeAnnotation(annotation.annotationUID);\n                    viewport?.render();\n                    return;\n                }\n                const currentAnnotation = getAnnotation(annotationUID);\n                if (!currentAnnotation) {\n                    console.warn('No current annotation');\n                    return;\n                }\n                Object.assign(currentAnnotation.data, state.data);\n                if (currentAnnotation.data.contour) {\n                    currentAnnotation.data\n                        .contour.polyline = state.data.contour.pointsManager.points;\n                }\n                state.data = newState.data;\n                currentAnnotation.invalidated = true;\n                triggerAnnotationModified(currentAnnotation, element, ChangeTypes.History);\n            },\n            id: annotationUID,\n            operationType: 'annotation',\n        };\n        DefaultHistoryMemo.push(annotationMemo);\n        return annotationMemo;\n    }\n    createMemo(element, annotation, options) {\n        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);\n    }\n    static hydrateBase(ToolClass, enabledElement, points, options = {}) {\n        if (!enabledElement) {\n            return null;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const camera = viewport.getCamera();\n        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;\n        const viewUp = options.viewUp ?? camera.viewUp;\n        const instance = options.toolInstance || new ToolClass();\n        let referencedImageId;\n        let finalViewPlaneNormal = viewPlaneNormal;\n        let finalViewUp = viewUp;\n        if (options.referencedImageId) {\n            referencedImageId = options.referencedImageId;\n            finalViewPlaneNormal = undefined;\n            finalViewUp = undefined;\n        }\n        else {\n            if (viewport instanceof StackViewport) {\n                const closestImageIndex = csUtils.getClosestStackImageIndexForPoint(points[0], viewport);\n                if (closestImageIndex !== undefined) {\n                    referencedImageId = viewport.getImageIds()[closestImageIndex];\n                }\n            }\n            else if (viewport instanceof BaseVolumeViewport) {\n                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n            }\n            else {\n                throw new Error('Unsupported viewport type');\n            }\n        }\n        return {\n            FrameOfReferenceUID,\n            referencedImageId,\n            viewPlaneNormal: finalViewPlaneNormal,\n            viewUp: finalViewUp,\n            instance,\n            viewport,\n        };\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, getChildAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport AnnotationTool from './AnnotationTool';\nimport updateContourPolyline from '../../utilities/contours/updateContourPolyline';\nimport getContourHolesDataCanvas from '../../utilities/contours/getContourHolesDataCanvas';\nclass ContourBaseTool extends AnnotationTool {\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        let renderStatus = false;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return renderStatus;\n        }\n        let annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        const targetId = this.getTargetId(viewport);\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        for (let i = 0; i < annotations.length; i++) {\n            const annotation = annotations[i];\n            styleSpecifier.annotationUID = annotation.annotationUID;\n            const annotationStyle = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!annotationStyle.visibility) {\n                continue;\n            }\n            const annotationRendered = this.renderAnnotationInstance({\n                enabledElement,\n                targetId,\n                annotation,\n                annotationStyle,\n                svgDrawingHelper,\n            });\n            renderStatus ||= annotationRendered;\n            annotation.invalidated = false;\n        }\n        return renderStatus;\n    }\n    createAnnotation(evt) {\n        const annotation = super.createAnnotation(evt);\n        Object.assign(annotation.data, {\n            contour: {\n                polyline: [],\n                closed: false,\n            },\n        });\n        Object.assign(annotation, {\n            interpolationUID: '',\n            autoGenerated: false,\n        });\n        return annotation;\n    }\n    addAnnotation(annotation, element) {\n        return addAnnotation(annotation, element);\n    }\n    cancelAnnotation(annotation) {\n    }\n    moveAnnotation(annotation, worldPosDelta) {\n        const { points } = annotation.data.handles;\n        for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n            const point = points[i];\n            point[0] += worldPosDelta[0];\n            point[1] += worldPosDelta[1];\n            point[2] += worldPosDelta[2];\n        }\n        annotation.invalidated = true;\n        getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));\n    }\n    updateContourPolyline(annotation, polylineData, transforms, options) {\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, polylineData, transforms, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n            updateWindingDirection: options?.updateWindingDirection,\n        });\n    }\n    getPolylinePoints(annotation) {\n        return annotation.data.contour?.polyline ?? annotation.data.polyline;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        if (annotation.parentAnnotationUID) {\n            return;\n        }\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));\n        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;\n        const childContours = getContourHolesDataCanvas(annotation, viewport);\n        const allContours = [polylineCanvasPoints, ...childContours];\n        drawPathSvg(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {\n            color: color,\n            lineDash: lineDash,\n            lineWidth: Math.max(0.1, lineWidth),\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n        });\n        return true;\n    }\n}\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';\nimport { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nclass ContourSegmentationBaseTool extends ContourBaseTool {\n    static { this.PreviewSegmentIndex = 255; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const contourAnnotation = super.createAnnotation(evt);\n        if (!this.isContourSegmentationTool()) {\n            return contourAnnotation;\n        }\n        const activeSeg = getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation detected, create one before using scissors tool');\n        }\n        if (!activeSeg.representationData.Contour) {\n            throw new Error(`A contour segmentation must be active`);\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n            },\n        });\n    }\n    addAnnotation(annotation, element) {\n        const annotationUID = super.addAnnotation(annotation, element);\n        if (this.isContourSegmentationTool()) {\n            const contourSegAnnotation = annotation;\n            addContourSegmentationAnnotation(contourSegAnnotation);\n        }\n        return annotationUID;\n    }\n    cancelAnnotation(annotation) {\n        if (this.isContourSegmentationTool()) {\n            removeContourSegmentationAnnotation(annotation);\n        }\n        super.cancelAnnotation(annotation);\n    }\n    getAnnotationStyle(context) {\n        const annotationStyle = super.getAnnotationStyle(context);\n        if (!this.isContourSegmentationTool()) {\n            return annotationStyle;\n        }\n        const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation } = renderContext;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated && this.isContourSegmentationTool()) {\n            const { segmentationId } = (annotation).data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            const toolGroupIds = viewportIds.map((viewportId) => {\n                const toolGroup = getToolGroupForViewport(viewportId);\n                return toolGroup.id;\n            });\n            triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n        }\n        return renderResult;\n    }\n    _getContourSegmentationStyle(context) {\n        const annotation = context.annotation;\n        const { segmentationId, segmentIndex } = annotation.data.segmentation;\n        const { viewportId } = context.styleSpecifier;\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n        if (!segmentationRepresentations?.length) {\n            return {};\n        }\n        let segmentationRepresentation;\n        if (segmentationRepresentations.length > 1) {\n            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&\n                rep.type === SegmentationRepresentations.Contour);\n        }\n        else {\n            segmentationRepresentation = segmentationRepresentations[0];\n        }\n        const { autoGenerated } = annotation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const annotationLocked = segmentsLocked.includes(segmentIndex);\n        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n            autoGenerated,\n        });\n        return {\n            color,\n            fillColor,\n            lineWidth,\n            fillOpacity,\n            lineDash,\n            textbox: {\n                color,\n            },\n            visibility,\n            locked: annotationLocked,\n        };\n    }\n}\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthAutoGenerated: 3,\n    outlineWidth: 1,\n    outlineWidthInactive: 1,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    outlineDash: undefined,\n    outlineDashInactive: undefined,\n    outlineDashAutoGenerated: '5,3',\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.3,\n    fillAlphaAutoGenerated: 0.3,\n};\nfunction getDefaultContourStyle() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourStyle;\n","import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';\nimport { cache, utilities } from '@cornerstonejs/core';\nimport { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';\nimport { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';\nimport { validateGeometry } from './utils';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';\nfunction handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {\n    if (annotationUIDsMap.size) {\n        viewport.render();\n    }\n    else {\n        addContourSetsToElement(viewport, geometryIds, contourRepresentation);\n    }\n}\nfunction addContourSetsToElement(viewport, geometryIds, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        validateGeometry(geometry);\n        const segmentSpecificConfig = segmentationStyle.getStyle({\n            viewportId: viewport.id,\n            segmentationId,\n            type: SegmentationRepresentations.Contour,\n            segmentIndex,\n        });\n        const contourSet = geometry.data;\n        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;\n        contourSet.contours.forEach((contour) => {\n            const { points, color, id } = contour;\n            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);\n            const contourSegmentationAnnotation = {\n                annotationUID: utilities.uuidv4(),\n                data: {\n                    contour: {\n                        closed: true,\n                        polyline: points,\n                    },\n                    segmentation: {\n                        segmentationId,\n                        segmentIndex,\n                        color,\n                        id,\n                    },\n                    handles: {},\n                },\n                handles: {},\n                highlighted: false,\n                autoGenerated: false,\n                invalidated: false,\n                isLocked: true,\n                isVisible: true,\n                metadata: {\n                    referencedImageId,\n                    toolName: 'PlanarFreehandContourSegmentationTool',\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n                },\n            };\n            const annotationGroupSelector = viewport.element;\n            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);\n            addContourSegmentationAnnotation(contourSegmentationAnnotation);\n        });\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n    });\n    viewport.render();\n}\nexport { handleContourSegmentation, addContourSetsToElement };\n","import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.contours.forEach((contour) => {\n        const pointList = contour.points;\n        const flatPoints = contour.flatPointsArray;\n        const type = contour.type;\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n","import { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { removeAnnotation } from '../../../stateManagement';\nfunction removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    annotationUIDsMap.forEach((annotationSet) => {\n        annotationSet.forEach((annotationUID) => {\n            removeAnnotation(annotationUID);\n        });\n    });\n}\nexport default removeContourFromElement;\n","import { cache, Enums, convertMapperToNotSharedMapper, volumeLoader, eventTarget, createVolumeActor, } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nconst internalCache = new Map();\nconst load = ({ cfun, ofun, actor }) => {\n    actor.getProperty().setRGBTransferFunction(1, cfun);\n    actor.getProperty().setScalarOpacity(1, ofun);\n};\nexport async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {\n    const defaultActor = viewport.getDefaultActor();\n    const { actor } = defaultActor;\n    const { uid, callback } = defaultActor;\n    const referenceVolumeId = viewport.getVolumeId();\n    if (internalCache.get(uid)?.added) {\n        return {\n            uid,\n            actor,\n        };\n    }\n    const volumeInputArray = volumeInputs;\n    const firstImageVolume = cache.getVolume(volumeInputArray[0].volumeId);\n    if (!firstImageVolume) {\n        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);\n    }\n    const { volumeId } = volumeInputArray[0];\n    const segImageVolume = await volumeLoader.loadVolume(volumeId);\n    if (!segImageVolume) {\n        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);\n    }\n    const segVoxelManager = segImageVolume.voxelManager;\n    const segData = segVoxelManager.getCompleteScalarDataArray();\n    const { imageData: segImageData } = segImageVolume;\n    const baseVolume = cache.getVolume(referenceVolumeId);\n    const baseVoxelManager = baseVolume.voxelManager;\n    const baseData = baseVoxelManager.getCompleteScalarDataArray();\n    const newComp = 2;\n    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());\n    const dims = segImageData.getDimensions();\n    for (let z = 0; z < dims[2]; ++z) {\n        for (let y = 0; y < dims[1]; ++y) {\n            for (let x = 0; x < dims[0]; ++x) {\n                const iTuple = x + dims[0] * (y + dims[1] * z);\n                cubeData[iTuple * newComp + 0] = baseData[iTuple];\n                cubeData[iTuple * newComp + 1] = segData[iTuple];\n            }\n        }\n    }\n    viewport.removeActors([uid]);\n    const oldMapper = actor.getMapper();\n    const mapper = convertMapperToNotSharedMapper(oldMapper);\n    actor.setMapper(mapper);\n    mapper.setBlendMode(Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);\n    const arrayAgain = mapper.getInputData().getPointData().getArray(0);\n    arrayAgain.setData(cubeData);\n    arrayAgain.setNumberOfComponents(2);\n    actor.getProperty().setColorMixPreset(1);\n    actor.getProperty().setForceNearestInterpolation(1, true);\n    actor.getProperty().setIndependentComponents(true);\n    viewport.addActor({\n        actor,\n        uid,\n        callback,\n        referencedId: referenceVolumeId,\n        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n    });\n    internalCache.set(uid, {\n        added: true,\n        segmentationRepresentationUID: `${segmentationId}`,\n        originalBlendMode: viewport.getBlendMode(),\n    });\n    actor.set({\n        preLoad: load,\n    });\n    function onSegmentationDataModified(evt) {\n        const { segmentationId } = evt.detail;\n        const { representationData } = getSegmentation(segmentationId);\n        const { volumeId: segVolumeId } = representationData.Labelmap;\n        if (segVolumeId !== segImageVolume.volumeId) {\n            return;\n        }\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const segVoxelManager = segmentationVolume.voxelManager;\n        const imageData = mapper.getInputData();\n        const array = imageData.getPointData().getArray(0);\n        const baseData = array.getData();\n        const newComp = 2;\n        const dims = segImageData.getDimensions();\n        const slices = Array.from({ length: dims[2] }, (_, i) => i);\n        for (const z of slices) {\n            for (let y = 0; y < dims[1]; ++y) {\n                for (let x = 0; x < dims[0]; ++x) {\n                    const iTuple = x + dims[0] * (y + dims[1] * z);\n                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);\n                }\n            }\n        }\n        array.setData(baseData);\n        imageData.modified();\n        viewport.render();\n    }\n    eventTarget.addEventListenerDebounced(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);\n    eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);\n        const actorEntry = viewport.getActor(uid);\n        const { element, id } = viewport;\n        viewport.removeActors([uid]);\n        const actor = await createVolumeActor({\n            volumeId: uid,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            callback: ({ volumeActor }) => {\n                if (actorEntry.callback) {\n                    actorEntry.callback({\n                        volumeActor,\n                        volumeId,\n                    });\n                }\n            },\n        }, element, id);\n        viewport.addActor({ actor, uid });\n        viewport.render();\n    });\n    return {\n        uid,\n        actor,\n    };\n}\n","import { getEnabledElement, addVolumesToViewports, addImageSlicesToViewports, Enums, cache, BaseVolumeViewport, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationDataModified, triggerSegmentationModified, } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { addVolumesAsIndependentComponents } from './addVolumesAsIndependentComponents';\nconst { uuidv4 } = utilities;\nasync function addLabelmapToElement(element, labelMapData, segmentationId, config) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeLabelMapData = labelMapData;\n        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);\n        if (!cache.getVolume(volumeId)) {\n            await _handleMissingVolume(labelMapData);\n        }\n        let blendMode = config?.blendMode ?? Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n        let useIndependentComponents = blendMode === Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;\n        if (useIndependentComponents) {\n            const referenceVolumeId = viewport.getVolumeId();\n            const baseVolume = cache.getVolume(referenceVolumeId);\n            const segVolume = cache.getVolume(volumeId);\n            const segDims = segVolume.dimensions;\n            const refDims = baseVolume.dimensions;\n            if (segDims[0] !== refDims[0] ||\n                segDims[1] !== refDims[1] ||\n                segDims[2] !== refDims[2]) {\n                useIndependentComponents = false;\n                blendMode = Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n                console.debug('Dimensions mismatch - falling back to regular volume addition');\n            }\n        }\n        const volumeInputs = [\n            {\n                volumeId,\n                visibility,\n                representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                useIndependentComponents,\n                blendMode,\n            },\n        ];\n        if (!volumeInputs[0].useIndependentComponents) {\n            await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n        }\n        else {\n            const result = await addVolumesAsIndependentComponents({\n                viewport,\n                volumeInputs,\n                segmentationId,\n            });\n            return result;\n        }\n    }\n    else {\n        const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        const stackInputs = segmentationImageIds.map((imageId) => ({\n            imageId,\n            representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${imageId}`,\n        }));\n        addImageSlicesToViewports(renderingEngine, stackInputs, [viewportId]);\n    }\n    triggerSegmentationDataModified(segmentationId);\n}\nfunction _ensureVolumeHasVolumeId(labelMapData, segmentationId) {\n    let { volumeId } = labelMapData;\n    if (!volumeId) {\n        volumeId = uuidv4();\n        const segmentation = getSegmentation(segmentationId);\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            volumeId,\n        };\n        labelMapData.volumeId = volumeId;\n        triggerSegmentationModified(segmentationId);\n    }\n    return volumeId;\n}\nasync function _handleMissingVolume(labelMapData) {\n    const stackData = labelMapData;\n    const hasImageIds = stackData.imageIds.length > 0;\n    if (!hasImageIds) {\n        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');\n    }\n    const volume = await volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);\n    return volume;\n}\nexport default addLabelmapToElement;\n","const defaultLabelmapConfig = {\n    renderOutline: true,\n    renderOutlineInactive: true,\n    outlineWidth: 3,\n    outlineWidthInactive: 2,\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.4,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapStyle() {\n    return defaultLabelmapConfig;\n}\nexport default getDefaultLabelmapStyle;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getLabelmapActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeLabelmapFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);\n}\nexport default removeLabelmapFromElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorEntry, getSurfaceRepresentationUID, } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction addOrUpdateSurfaceToElement(element, surface, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);\n    const surfaceActor = surfaceActorEntry?.actor;\n    const isVisible = surface.visible;\n    if (surfaceActor) {\n        surfaceActor.setVisibility(isVisible);\n        if (!isVisible) {\n            return;\n        }\n        const surfaceMapper = surfaceActor.getMapper();\n        const currentPolyData = surfaceMapper.getInputData();\n        const newPoints = surface.points;\n        const newPolys = surface.polys;\n        const currentPoints = currentPolyData.getPoints().getData();\n        const currentPolys = currentPolyData.getPolys().getData();\n        if (newPoints.length === currentPoints.length &&\n            newPolys.length === currentPolys.length) {\n            return;\n        }\n        const polyData = vtkPolyData.newInstance();\n        polyData.getPoints().setData(newPoints, 3);\n        const triangles = vtkCellArray.newInstance({\n            values: Float32Array.from(newPolys),\n        });\n        polyData.setPolys(triangles);\n        surfaceMapper.setInputData(polyData);\n        surfaceMapper.modified();\n        viewport.getRenderer().resetCameraClippingRange();\n        return;\n    }\n    const points = surface.points;\n    const polys = surface.polys;\n    const color = surface.color;\n    const surfacePolyData = vtkPolyData.newInstance();\n    surfacePolyData.getPoints().setData(points, 3);\n    const triangles = vtkCellArray.newInstance({\n        values: Float32Array.from(polys),\n    });\n    surfacePolyData.setPolys(triangles);\n    const mapper = vtkMapper.newInstance({});\n    let clippingFilter;\n    mapper.setInputData(surfacePolyData);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n    actor.getProperty().setLineWidth(2);\n    const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);\n    viewport.addActor({\n        uid: utilities.uuidv4(),\n        actor: actor,\n        clippingFilter,\n        representationUID,\n    });\n    viewport.resetCamera();\n    viewport.getRenderer().resetCameraClippingRange();\n    viewport.render();\n}\nexport default addOrUpdateSurfaceToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeSurfaceFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const filteredSurfaceActors = actorEntries.filter((actor) => actor.representationUID &&\n        typeof actor.representationUID === 'string' &&\n        actor.representationUID.startsWith(segmentationId));\n    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));\n}\nexport default removeSurfaceFromElement;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { StrategyCallbacks } from '../../../enums';\nexport default class BrushStrategy {\n    static { this.COMPOSITIONS = compositions; }\n    static { this.childFunctions = {\n        [StrategyCallbacks.OnInteractionStart]: addListMethod(StrategyCallbacks.OnInteractionStart, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.OnInteractionEnd]: addListMethod(StrategyCallbacks.OnInteractionEnd, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n        [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n        [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks.CreateIsInThreshold),\n        [StrategyCallbacks.Interpolate]: addListMethod(StrategyCallbacks.Interpolate, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.AcceptPreview]: addListMethod(StrategyCallbacks.AcceptPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.RejectPreview]: addListMethod(StrategyCallbacks.RejectPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks.INTERNAL_setValue),\n        [StrategyCallbacks.Preview]: addSingletonMethod(StrategyCallbacks.Preview, false),\n        [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks.ComputeInnerCircleRadius),\n        [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),\n        [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureImageVolumeFor3DManipulation),\n        [StrategyCallbacks.AddPreview]: addListMethod(StrategyCallbacks.AddPreview),\n        [StrategyCallbacks.GetStatistics]: addSingletonMethod(StrategyCallbacks.GetStatistics),\n        compositions: null,\n    }; }\n    constructor(name, ...initializers) {\n        this._initialize = [];\n        this._fill = [];\n        this._onInteractionStart = [];\n        this.fill = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.Fill);\n            if (!initializedData) {\n                return;\n            }\n            this._fill.forEach((func) => func(initializedData));\n            const { segmentationVoxelManager, segmentIndex } = initializedData;\n            triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n            return initializedData;\n        };\n        this.onInteractionStart = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData);\n            if (!initializedData) {\n                return;\n            }\n            this._onInteractionStart.forEach((func) => func.call(this, initializedData));\n        };\n        this.addPreview = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.AddPreview);\n            if (!initializedData) {\n                return;\n            }\n            return initializedData;\n        };\n        this.configurationName = name;\n        this.compositions = initializers;\n        initializers.forEach((initializer) => {\n            const result = typeof initializer === 'function' ? initializer() : initializer;\n            if (!result) {\n                return;\n            }\n            for (const key in result) {\n                if (!BrushStrategy.childFunctions[key]) {\n                    throw new Error(`Didn't find ${key} as a brush strategy`);\n                }\n                BrushStrategy.childFunctions[key](this, result[key]);\n            }\n        });\n        this.strategyFunction = (enabledElement, operationData) => {\n            return this.fill(enabledElement, operationData);\n        };\n        for (const key of Object.keys(BrushStrategy.childFunctions)) {\n            this.strategyFunction[key] = this[key];\n        }\n    }\n    initialize(enabledElement, operationData, operationName) {\n        const { viewport } = enabledElement;\n        const data = getStrategyData({ operationData, viewport, strategy: this });\n        if (!data) {\n            return null;\n        }\n        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;\n        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);\n        const initializedData = {\n            operationName,\n            ...operationData,\n            segmentIndex: operationData.segmentIndex,\n            enabledElement,\n            imageVoxelManager,\n            segmentationVoxelManager,\n            segmentationImageData,\n            viewport,\n            centerWorld: null,\n            isInObject: null,\n            isInObjectBoundsIJK: null,\n            brushStrategy: this,\n            memo,\n        };\n        this._initialize.forEach((func) => func(initializedData));\n        return initializedData;\n    }\n}\nfunction addListMethod(name, createInitialized) {\n    const listName = `_${name}`;\n    return (brushStrategy, func) => {\n        brushStrategy[listName] ||= [];\n        brushStrategy[listName].push(func);\n        brushStrategy[name] ||= createInitialized\n            ? (enabledElement, operationData, ...args) => {\n                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);\n                let returnValue;\n                brushStrategy[listName].forEach((func) => {\n                    const value = func.call(brushStrategy, initializedData, ...args);\n                    returnValue ||= value;\n                });\n                return returnValue;\n            }\n            : (operationData, ...args) => {\n                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));\n            };\n    };\n}\nfunction addSingletonMethod(name, isInitialized = true) {\n    return (brushStrategy, func) => {\n        if (brushStrategy[name]) {\n            throw new Error(`The singleton method ${name} already exists`);\n        }\n        brushStrategy[name] = isInitialized\n            ? func\n            : (enabledElement, operationData, ...args) => {\n                operationData.enabledElement = enabledElement;\n                return func.call(brushStrategy, operationData, ...args);\n            };\n    };\n}\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;\n        if (!configuration?.useCenterSegmentIndex) {\n            return;\n        }\n        let hasSegmentIndex = false;\n        let hasPreviewIndex = false;\n        const nestedBounds = [\n            ...segmentationVoxelManager.getBoundsIJK(),\n        ];\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const callback = ({ value }) => {\n            hasSegmentIndex ||= value === segmentIndex;\n            hasPreviewIndex ||= value === previewSegmentIndex;\n        };\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: nestedBounds,\n        });\n        if (!hasSegmentIndex && !hasPreviewIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            return;\n        }\n        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;\n        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;\n        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;\n        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {\n            return;\n        }\n        if (operationName === StrategyCallbacks.RejectPreview ||\n            operationName === StrategyCallbacks.OnInteractionEnd) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager.getBoundsIJK();\n        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;\n        const useDelta = oldThreshold ? 0 : dynamicRadius;\n        const { viewPlaneNormal } = viewport.getCamera();\n        const nestedBounds = boundsIJK.map((ijk, idx) => {\n            const [min, max] = ijk;\n            return [\n                Math.max(min, centerIJK[idx] - useDelta),\n                Math.min(max, centerIJK[idx] + useDelta),\n            ];\n        });\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const threshold = oldThreshold || [Infinity, -Infinity];\n        const useDeltaSqr = useDelta * useDelta;\n        const callback = ({ value, pointIJK }) => {\n            const distance = vec3.sqrDist(centerIJK, pointIJK);\n            if (distance > useDeltaSqr) {\n                return;\n            }\n            const gray = Array.isArray(value) ? vec3.len(value) : value;\n            threshold[0] = Math.min(gray, threshold[0]);\n            threshold[1] = Math.max(gray, threshold[1]);\n        };\n        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n        configuration.threshold.range = threshold;\n    },\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { configuration } = operationData;\n        if (!configuration?.threshold?.isDynamic) {\n            return;\n        }\n        configuration.threshold.range = null;\n    },\n    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {\n        const { configuration, viewport } = operationData;\n        const { dynamicRadius = 0, isDynamic } = configuration.threshold;\n        if (!isDynamic) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n            return;\n        }\n        if (dynamicRadius === 0) {\n            return;\n        }\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        const { spacing } = imageData;\n        const centerCanvas = [\n            viewport.element.clientWidth / 2,\n            viewport.element.clientHeight / 2,\n        ];\n        const radiusInWorld = dynamicRadius * spacing[0];\n        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);\n        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);\n        if (!configuration.threshold.dynamicRadiusInCanvas) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n        }\n        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        operationData.segmentIndex = 0;\n    },\n};\n","import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport IslandRemoval from '../../../../utilities/segmentation/islandRemoval';\nexport default {\n    [StrategyCallbacks.OnInteractionEnd]: (operationData) => {\n        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;\n        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||\n            segmentIndex === null) {\n            return;\n        }\n        const islandRemoval = new IslandRemoval();\n        const voxelManager = memo?.voxelManager || segmentationVoxelManager;\n        if (!islandRemoval.initialize(viewport, voxelManager, {\n            previewSegmentIndex,\n            segmentIndex,\n        })) {\n            return;\n        }\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();\n        if (!arrayOfSlices) {\n            return;\n        }\n        triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);\n    },\n};\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/events/triggerSegmentationDataModified';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { setSegmentIndexColor } from '../../../../stateManagement/segmentation/config/segmentationColor';\nimport { getViewportIdsWithSegmentation } from '../../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nexport default {\n    [StrategyCallbacks.Preview]: function (operationData) {\n        const { previewSegmentIndex, configuration, enabledElement } = operationData;\n        if (!previewSegmentIndex || !configuration) {\n            return;\n        }\n        this.onInteractionStart?.(enabledElement, operationData);\n        const preview = this.fill(enabledElement, operationData);\n        if (preview) {\n            this.onInteractionEnd?.(enabledElement, operationData);\n        }\n        return preview;\n    },\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;\n        if (previewSegmentIndex == null || segmentIndex == null) {\n            return;\n        }\n        const viewportIds = getViewportIdsWithSegmentation(operationData.segmentationId);\n        viewportIds?.forEach((viewportId) => {\n            setSegmentIndexColor(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);\n        });\n    },\n    [StrategyCallbacks.AcceptPreview]: (operationData) => {\n        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};\n        const { changedIndices } = centerSegmentIndexInfo || {};\n        const labelmapMemo = memo;\n        const callback = ({ index }) => {\n            const oldValue = segmentationVoxelManager.getAtIndex(index);\n            if (changedIndices?.length > 0) {\n                if (changedIndices.includes(index)) {\n                    labelmapMemo.voxelManager.setAtIndex(index, 0);\n                }\n            }\n            else {\n                if (oldValue === previewSegmentIndex) {\n                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);\n                }\n            }\n        };\n        segmentationVoxelManager.forEach(callback);\n        triggerSegmentationDataModified(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n        operationData.centerSegmentIndexInfo.changedIndices = [];\n    },\n    [StrategyCallbacks.RejectPreview]: (operationData) => {\n        if (!operationData) {\n            return;\n        }\n        utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {\n            const labelmapMemo = memo;\n            if (!labelmapMemo?.voxelManager) {\n                return false;\n            }\n            const { segmentationVoxelManager } = labelmapMemo;\n            let hasPreviewSegmentIndex = false;\n            const callback = ({ value }) => {\n                if (value === operationData.previewSegmentIndex) {\n                    hasPreviewSegmentIndex = true;\n                }\n            };\n            segmentationVoxelManager.forEach(callback);\n            return hasPreviewSegmentIndex;\n        });\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Fill]: (operationData) => {\n        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;\n        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);\n        const { setValue } = brushStrategy;\n        const callback = isWithinThreshold\n            ? (data) => {\n                const { value, index } = data;\n                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n                    return;\n                }\n                setValue(operationData, data);\n            }\n            : (data) => setValue(operationData, data);\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: operationData.isInObjectBoundsIJK,\n        });\n        segmentationVoxelManager.addPoint(centerIJK);\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { handleUseSegmentCenterIndex } from '../utils/handleUseSegmentCenterIndex';\nexport default {\n    [StrategyCallbacks.INTERNAL_setValue]: (operationData, { value, index }) => {\n        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;\n        const existingValue = segmentationVoxelManager.getAtIndex(index);\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&\n            existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex === null) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);\n            return;\n        }\n        if (!previewSegmentIndex) {\n            let useSegmentIndex = segmentIndex;\n            if (centerSegmentIndexInfo) {\n                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;\n            }\n            memo.voxelManager.setAtIndex(index, useSegmentIndex);\n            return;\n        }\n        handleUseSegmentCenterIndex({\n            operationData,\n            existingValue,\n            index,\n        });\n    },\n};\n","export function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {\n    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;\n    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;\n    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === 0 || existingValue !== segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        centerSegmentIndexInfo.changedIndices.push(index);\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        !hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n}\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.CreateIsInThreshold]: (operationData) => {\n        const { imageVoxelManager, segmentIndex, configuration } = operationData;\n        if (!configuration || !segmentIndex) {\n            return;\n        }\n        return (index) => {\n            const voxelValue = imageVoxelManager.getAtIndex(index);\n            const gray = Array.isArray(voxelValue)\n                ? vec3.length(voxelValue)\n                : voxelValue;\n            const { threshold } = configuration || {};\n            if (!threshold?.range?.length) {\n                return true;\n            }\n            return threshold.range[0] <= gray && gray <= threshold.range[1];\n        };\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getStatistics from '../../../../utilities/segmentation/getStatistics';\nexport default {\n    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {\n        const { indices } = options;\n        const { segmentationId, viewport } = operationData;\n        getStatistics({\n            segmentationId,\n            segmentIndices: indices,\n        });\n    },\n};\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemovalComposition';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\nimport labelmapStatistics from './labelmapStatistics';\nimport ensureSegmentationVolumeFor3DManipulation from './ensureSegmentationVolume';\nimport ensureImageVolumeFor3DManipulation from './ensureImageVolume';\nexport default {\n    determineSegmentIndex,\n    dynamicThreshold,\n    erase,\n    islandRemoval,\n    preview,\n    regionFill,\n    setValue,\n    threshold,\n    labelmapStatistics,\n    ensureSegmentationVolumeFor3DManipulation,\n    ensureImageVolumeFor3DManipulation,\n};\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy('EraseCircle', compositions.erase, ...CIRCLE_STRATEGY.compositions);\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\nexport { eraseInsideCircle };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy('EraseSphere', compositions.erase, ...SPHERE_STRATEGY.compositions);\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\nexport { eraseInsideSphere };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport BrushStrategy from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfoFromViewport } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK: newBoundsIJK, topLeftWorld, bottomRightWorld, } = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);\n        operationData.isInObjectBoundsIJK = newBoundsIJK;\n        operationData.isInObject = createEllipseInPoint({\n            topLeftWorld,\n            bottomRightWorld,\n            center,\n        });\n    },\n};\nconst SPHERE_STRATEGY = new BrushStrategy('Sphere', compositions.regionFill, compositions.setValue, sphereComposition, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics, compositions.ensureSegmentationVolumeFor3DManipulation);\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.islandRemoval, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\nconst thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;\nexport function fillOutsideSphere() {\n    throw new Error('fill outside sphere not implemented');\n}\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY, thresholdInsideSphereIsland, };\n","import { cache, Enums, eventTarget } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdForViewport } from '../../../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../../../stateManagement/segmentation/helpers';\nimport { getReferenceVolumeForSegmentationVolume } from '../../../../utilities/segmentation/getReferenceVolumeForSegmentationVolume';\nfunction getStrategyDataForVolumeViewport({ operationData }) {\n    const { volumeId } = operationData;\n    if (!volumeId) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n            detail: {\n                type: 'Segmentation',\n                message: 'No volume id found for the segmentation',\n            },\n            cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n    }\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = getReferenceVolumeForSegmentationVolume(volumeId);\n    if (!segmentationVolume || !imageVolume) {\n        return null;\n    }\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { voxelManager: segmentationVoxelManager } = segmentationVolume;\n    const { voxelManager: imageVoxelManager, imageData } = imageVolume;\n    return {\n        segmentationImageData,\n        segmentationVoxelManager,\n        segmentationScalarData: null,\n        imageScalarData: null,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyDataForStackViewport({ operationData, viewport, strategy, }) {\n    const { segmentationId } = operationData;\n    let segmentationImageData;\n    let segmentationVoxelManager;\n    let segmentationScalarData;\n    let imageScalarData;\n    let imageVoxelManager;\n    let imageData;\n    if (strategy.ensureSegmentationVolumeFor3DManipulation) {\n        strategy.ensureSegmentationVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        segmentationVoxelManager = operationData.segmentationVoxelManager;\n        segmentationImageData = operationData.segmentationImageData;\n        segmentationScalarData = null;\n    }\n    else {\n        const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n        if (!labelmapImageId) {\n            return null;\n        }\n        const actorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n        if (!actorEntry) {\n            return null;\n        }\n        const currentSegImage = cache.getImage(labelmapImageId);\n        segmentationImageData = actorEntry.actor.getMapper().getInputData();\n        segmentationVoxelManager = currentSegImage.voxelManager;\n        const currentSegmentationImageId = operationData.imageId;\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        if (!segmentationImage) {\n            return null;\n        }\n        segmentationScalarData = segmentationImage.getPixelData?.();\n    }\n    if (strategy.ensureImageVolumeFor3DManipulation) {\n        strategy.ensureImageVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        imageVoxelManager = operationData.imageVoxelManager;\n        imageScalarData = operationData.imageScalarData;\n        imageData = operationData.imageData;\n    }\n    else {\n        const currentImageId = viewport.getCurrentImageId();\n        if (!currentImageId) {\n            return null;\n        }\n        const image = cache.getImage(currentImageId);\n        imageData = image ? null : viewport.getImageData();\n        imageScalarData = image?.getPixelData() || imageData.getScalarData();\n        imageVoxelManager = image?.voxelManager;\n    }\n    return {\n        segmentationImageData,\n        segmentationScalarData,\n        imageScalarData,\n        segmentationVoxelManager,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyData({ operationData, viewport, strategy, }) {\n    if (!operationData) {\n        return null;\n    }\n    if (('volumeId' in operationData && operationData.volumeId != null) ||\n        ('referencedVolumeId' in operationData &&\n            operationData.referencedVolumeId != null)) {\n        return getStrategyDataForVolumeViewport({ operationData });\n    }\n    return getStrategyDataForStackViewport({ operationData, viewport, strategy });\n}\nexport { getStrategyData };\n","class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n","import { getAnnotations } from '../../../stateManagement/annotation/annotationState';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function getInterpolationData(viewportData, filterParams = []) {\n    const { viewport, sliceData, annotation } = viewportData;\n    const interpolationDatas = new Map();\n    const { toolName, originalToolName } = annotation.metadata;\n    const testToolName = originalToolName || toolName;\n    const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||\n        annotation.metadata.originalToolName === testToolName);\n    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n        const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);\n        if (modifiedAnnotations?.length) {\n            modifiedAnnotations.forEach((annotation) => {\n                const { metadata } = annotation;\n                if (metadata.originalToolName === testToolName &&\n                    metadata.originalToolName !== metadata.toolName) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n    }\n    if (!annotations?.length) {\n        return interpolationDatas;\n    }\n    for (let i = 0; i < sliceData.numberOfSlices; i++) {\n        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);\n        if (!imageAnnotations?.length) {\n            continue;\n        }\n        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {\n            return filterParams.every((x) => {\n                const parent = x.parentKey\n                    ? x.parentKey(imageAnnotation)\n                    : imageAnnotation;\n                const value = parent?.[x.key];\n                if (Array.isArray(value)) {\n                    return value.every((item, index) => item === x.value[index]);\n                }\n                return value === x.value;\n            });\n        });\n        if (filteredInterpolatedAnnotations.length) {\n            interpolationDatas.set(i, filteredInterpolatedAnnotations);\n        }\n    }\n    return interpolationDatas;\n}\n","import getInterpolationData from './getInterpolationData';\nexport default function getInterpolationDataCollection(viewportData, filterParams) {\n    const imageAnnotations = getInterpolationData(viewportData, filterParams);\n    const interpolatedDataCollection = [];\n    if (!imageAnnotations?.size) {\n        return interpolatedDataCollection;\n    }\n    for (const annotations of imageAnnotations.values()) {\n        annotations.forEach((annotation) => {\n            interpolatedDataCollection.push(annotation);\n        });\n    }\n    return interpolatedDataCollection;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport default function createPolylineToolData(polyline, handlePoints, referencedToolData) {\n    const annotation = csUtils.deepMerge({\n        data: {},\n        metadata: {},\n    }, referencedToolData);\n    Object.assign(annotation, {\n        highlighted: false,\n        invalidated: true,\n        autoGenerated: true,\n        annotationUID: undefined,\n        cachedStats: {},\n        childAnnotationUIDs: [],\n        parentAnnotationUID: undefined,\n    });\n    Object.assign(annotation.data, {\n        handles: {\n            points: handlePoints.points || handlePoints || [],\n            interpolationSources: handlePoints.sources,\n            activeHandleIndex: null,\n            textBox: {\n                hasMoved: false,\n                worldPosition: [0, 0, 0],\n                worldBoundingBox: {\n                    topLeft: [0, 0, 0],\n                    topRight: [0, 0, 0],\n                    bottomLeft: [0, 0, 0],\n                    bottomRight: [0, 0, 0],\n                },\n            },\n        },\n        contour: {\n            ...referencedToolData.data.contour,\n            polyline,\n        },\n    });\n    return annotation;\n}\n","import getInterpolationData from './getInterpolationData';\nfunction findAnnotationsForInterpolation(toolData, viewportData) {\n    const interpolationData = getInterpolationData(viewportData, [\n        {\n            key: 'interpolationUID',\n            value: viewportData.interpolationUID,\n        },\n    ]);\n    const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n    if (!rangeToInterpolate) {\n        console.warn('No annotations found to interpolate', interpolationData);\n        return;\n    }\n    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);\n    const interpolationList = [];\n    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n        if (_sliceNeedsInterpolating(interpolationData, i)) {\n            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);\n            if (contourPair?.[0] === sliceEdited ||\n                contourPair?.[1] === sliceEdited) {\n                _appendInterpolationList(contourPair, interpolationList, i);\n            }\n        }\n    }\n    return {\n        interpolationData,\n        interpolationList,\n    };\n}\nfunction getRangeToInterpolate(interpolationData) {\n    let first = Infinity;\n    let last = -Infinity;\n    let found = false;\n    for (const [sliceIndex, annotations] of interpolationData.entries()) {\n        if (annotations.length) {\n            first = Math.min(sliceIndex, first);\n            last = Math.max(sliceIndex, last);\n            found = true;\n        }\n    }\n    if (!found) {\n        return;\n    }\n    return [first, last];\n}\nfunction _getSlicePositionOfToolData(interpolationData, annotationUID) {\n    for (const [sliceIndex, annotations] of interpolationData) {\n        for (let j = 0; j < annotations.length; j++) {\n            if (annotations[j].annotationUID === annotationUID) {\n                return sliceIndex;\n            }\n        }\n    }\n    return;\n}\nfunction _sliceNeedsInterpolating(interpolationData, sliceIndex) {\n    const annotations = interpolationData.get(sliceIndex);\n    return (!annotations?.length ||\n        (annotations.length === 1 && annotations[0].autoGenerated));\n}\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n    const [startIndex] = contourPair;\n    interpolationList[startIndex] ||= {\n        pair: contourPair,\n        list: [],\n    };\n    interpolationList[startIndex].list.push(itemIndex);\n}\nfunction _getBoundingPair(sliceIndex, sliceRange, interpolationData) {\n    const annotationPair = [];\n    let canInterpolate = true;\n    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || !annotationPair.length) {\n        return;\n    }\n    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || annotationPair.length < 2) {\n        return;\n    }\n    return annotationPair;\n}\nexport default findAnnotationsForInterpolation;\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nconst { PointsManager } = utilities;\nexport default function selectHandles(polyline, handleCount = 12) {\n    const handles = PointsManager.create3(handleCount);\n    handles.sources = [];\n    const { sources: destPoints } = handles;\n    const { length, sources: sourcePoints = [] } = polyline;\n    const distance = 5;\n    if (length < distance * 3) {\n        return polyline.subselect(handleCount);\n    }\n    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));\n    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));\n    const dotValues = createDotValues(polyline, distance);\n    const minimumRegions = findMinimumRegions(dotValues, handleCount);\n    const indices = [];\n    if (minimumRegions?.length > 2) {\n        let lastHandle = -1;\n        const thirdInterval = interval / 3;\n        minimumRegions.forEach((region) => {\n            const [start, , end] = region;\n            const midIndex = Math.ceil((start + end) / 2);\n            if (end - lastHandle < thirdInterval) {\n                return;\n            }\n            if (midIndex - start > 2 * thirdInterval) {\n                addInterval(indices, lastHandle, start, interval, length);\n                lastHandle = addInterval(indices, start, midIndex, interval, length);\n            }\n            else {\n                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);\n            }\n            if (end - lastHandle > thirdInterval) {\n                lastHandle = addInterval(indices, lastHandle, end, interval, length);\n            }\n        });\n        const firstHandle = indices[0];\n        const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n        if (lastDistance > 2 * thirdInterval) {\n            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);\n        }\n    }\n    else {\n        const interval = Math.floor(length / handleCount);\n        addInterval(indices, -1, length - interval, interval, length);\n    }\n    indices.forEach((index) => {\n        const point = polyline.getPointArray(index);\n        handles.push(point);\n        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));\n    });\n    return handles;\n}\nexport function createDotValues(polyline, distance = 6) {\n    const { length } = polyline;\n    const prevVec3 = vec3.create();\n    const nextVec3 = vec3.create();\n    const dotValues = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        const point = polyline.getPoint(i);\n        const prevPoint = polyline.getPoint(i - distance);\n        const nextPoint = polyline.getPoint((i + distance) % length);\n        vec3.sub(prevVec3, point, prevPoint);\n        vec3.sub(nextVec3, nextPoint, point);\n        const dot = vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n        dotValues[i] = dot;\n    }\n    return dotValues;\n}\nfunction findMinimumRegions(dotValues, handleCount) {\n    const { max, deviation } = getStats(dotValues);\n    const { length } = dotValues;\n    if (deviation < 0.01 || length < handleCount * 3) {\n        return [];\n    }\n    const inflection = [];\n    let pair = null;\n    let minValue;\n    let minIndex = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        if (dot < max - deviation) {\n            if (pair) {\n                pair[2] = i;\n                if (dot < minValue) {\n                    minValue = dot;\n                    minIndex = i;\n                }\n                pair[1] = minIndex;\n            }\n            else {\n                minValue = dot;\n                minIndex = i;\n                pair = [i, i, i];\n            }\n        }\n        else {\n            if (pair) {\n                inflection.push(pair);\n                pair = null;\n            }\n        }\n    }\n    if (pair) {\n        if (inflection[0][0] === 0) {\n            inflection[0][0] = pair[0];\n        }\n        else {\n            pair[1] = minIndex;\n            pair[2] = length - 1;\n            inflection.push(pair);\n        }\n    }\n    return inflection;\n}\nexport function addInterval(indices, start, finish, interval, length) {\n    if (finish < start) {\n        finish += length;\n    }\n    const distance = finish - start;\n    const count = Math.ceil(distance / interval);\n    if (count <= 0) {\n        if (indices[indices.length - 1] !== finish) {\n            indices.push(indexValue(finish, length));\n        }\n        return finish;\n    }\n    for (let i = 1; i <= count; i++) {\n        const index = indexValue(start + (i * distance) / count, length);\n        indices.push(index);\n    }\n    return indices[indices.length - 1];\n}\nfunction indexValue(v, length) {\n    return (Math.round(v) + length) % length;\n}\nfunction getStats(dotValues) {\n    const { length } = dotValues;\n    let sum = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    let sumSq = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        sum += dot;\n        min = Math.min(min, dot);\n        max = Math.max(max, dot);\n    }\n    const mean = sum / length;\n    for (let i = 0; i < length; i++) {\n        const valueDiff = dotValues[i] - mean;\n        sumSq += valueDiff * valueDiff;\n    }\n    return {\n        mean,\n        max,\n        min,\n        sumSq,\n        deviation: Math.sqrt(sumSq / length),\n    };\n}\n","import { triggerEvent, utilities } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../contourSegmentation';\nconst { PointsManager } = utilities;\nconst dP = 0.2;\nfunction interpolate(viewportData) {\n    if (!viewportData.annotation) {\n        return;\n    }\n    const { isInterpolationUpdate, annotation } = viewportData;\n    queueMicrotask(() => {\n        try {\n            if (isInterpolationUpdate) {\n                annotation.isInterpolationUpdate = true;\n                annotation.autoGenerated = false;\n            }\n            startInterpolation(viewportData);\n        }\n        finally {\n            if (isInterpolationUpdate) {\n                annotation.autoGenerated = true;\n            }\n        }\n    });\n}\nfunction startInterpolation(viewportData) {\n    const { annotation: toolData } = viewportData;\n    updateChildInterpolationUID(toolData);\n    const { interpolationData, interpolationList } = findAnnotationsForInterpolation(toolData, viewportData) || {};\n    if (!interpolationData || !interpolationList) {\n        return;\n    }\n    const eventData = {\n        toolName: toolData.metadata.toolName,\n        toolType: toolData.metadata.toolName,\n        viewport: viewportData.viewport,\n    };\n    for (let i = 0; i < interpolationList.length; i++) {\n        if (interpolationList[i]) {\n            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);\n        }\n    }\n    const { id, renderingEngineId, element } = viewportData.viewport;\n    const eventDetails = {\n        annotation: toolData,\n        element,\n        viewportId: id,\n        renderingEngineId,\n    };\n    if (interpolationList.length) {\n        triggerEvent(viewportData.viewport.element, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n    }\n}\nfunction _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {\n    const annotation0 = interpolationData.get(annotationPair[0])[0];\n    const annotation1 = interpolationData.get(annotationPair[1])[0];\n    const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n    const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n    c1Interp.kIndex = annotationPair[0];\n    c2Interp.kIndex = annotationPair[1];\n    indices.forEach(function (index) {\n        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);\n    });\n}\nfunction getPointCount(pointArray) {\n    let sum = 0;\n    for (let i = 0; i < pointArray.I.length; i++) {\n        if (pointArray.I[i]) {\n            sum++;\n        }\n    }\n    return sum;\n}\nfunction _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {\n    const [startIndex, endIndex] = annotationPair;\n    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n    const annotation0 = interpolationData.get(startIndex)[0];\n    const annotation1 = interpolationData.get(endIndex)[0];\n    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);\n    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n    const handlePoints = selectHandles(interpolated3DPoints);\n    if (interpolationData.has(sliceIndex)) {\n        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n    else {\n        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n}\nfunction _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const points = interpolated3DPoints.points;\n    const { viewport } = eventData;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);\n    const viewRef = viewport.getViewReference({ sliceIndex });\n    if (!viewRef) {\n        throw new Error(`Can't find slice ${sliceIndex}`);\n    }\n    Object.assign(interpolatedAnnotation.metadata, viewRef);\n    annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);\n    const { parentAnnotationUID } = referencedToolData;\n    if (parentAnnotationUID) {\n        const parentReferenced = annotationState.state.getAnnotation(parentAnnotationUID);\n        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);\n        createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n    }\n}\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n    const { viewport } = eventData;\n    const annotations = annotationState.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        if (annotation.interpolationUID === referencedToolData.interpolationUID &&\n            annotation.metadata.sliceIndex === sliceIndex) {\n            return annotation;\n        }\n    }\n}\nfunction _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);\n    const points = interpolated3DPoints.points;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);\n    Object.assign(oldAnnotationData, {\n        metadata: interpolatedAnnotation.metadata,\n        data: interpolatedAnnotation.data,\n    });\n}\nfunction _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {\n    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n    const c1 = PointsManager.fromXYZ(c1ir);\n    const c2 = PointsManager.fromXYZ(c2ir);\n    const { length } = c1;\n    const cInterp = PointsManager.create3(length);\n    const vecSubtract = vec3.create();\n    const vecResult = vec3.create();\n    const c1Source = PointsManager.create3(length);\n    c1Source.kIndex = c1ir.kIndex;\n    const c2Source = PointsManager.create3(length);\n    c2Source.kIndex = c2ir.kIndex;\n    for (let i = 0; i < c1ir.x.length; i++) {\n        if (indices[i]) {\n            const c1point = c1.getPoint(i);\n            const c2point = c2.getPoint(i);\n            c1Source.push(c1point);\n            c2Source.push(c2point);\n            vec3.sub(vecSubtract, c2point, c1point);\n            cInterp.push(vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));\n        }\n    }\n    cInterp.sources = [c1Source, c2Source];\n    return cInterp;\n}\nfunction _generateInterpolationContourPair(c1, c2) {\n    const cumPerim1 = _getCumulativePerimeter(c1);\n    const cumPerim2 = _getCumulativePerimeter(c2);\n    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));\n    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n    const numNodes1 = interpNodes + c2.x.length;\n    const numNodes2 = interpNodes + c1.x.length;\n    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n    _shiftSuperSampledContourInPlace(c1i, c2i);\n    return _reduceContoursToOriginNodes(c1i, c2i);\n}\nfunction _reduceContoursToOriginNodes(c1i, c2i) {\n    const c1Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    const c2Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let i = 0; i < c1i.x.length; i++) {\n        if (c1i.I[i] || c2i.I[i]) {\n            c1Interp.x.push(c1i.x[i]);\n            c1Interp.y.push(c1i.y[i]);\n            c1Interp.z.push(c1i.z[i]);\n            c1Interp.I.push(c1i.I[i]);\n            c2Interp.x.push(c2i.x[i]);\n            c2Interp.y.push(c2i.y[i]);\n            c2Interp.z.push(c2i.z[i]);\n            c2Interp.I.push(c2i.I[i]);\n        }\n    }\n    return {\n        c1Interp,\n        c2Interp,\n    };\n}\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n    const c1iLength = c1i.x.length;\n    const optimal = {\n        startingNode: 0,\n        totalSquaredXYLengths: Infinity,\n    };\n    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n        let node = startingNode;\n        let totalSquaredXYLengths = 0;\n        for (let iteration = 0; iteration < c1iLength; iteration++) {\n            totalSquaredXYLengths +=\n                (c1i.x[node] - c2i.x[iteration]) ** 2 +\n                    (c1i.y[node] - c2i.y[iteration]) ** 2 +\n                    (c1i.z[node] - c2i.z[iteration]) ** 2;\n            node++;\n            if (node === c1iLength) {\n                node = 0;\n            }\n        }\n        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n            optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n            optimal.startingNode = startingNode;\n        }\n    }\n    const node = optimal.startingNode;\n    _shiftCircularArray(c1i.x, node);\n    _shiftCircularArray(c1i.y, node);\n    _shiftCircularArray(c1i.z, node);\n    _shiftCircularArray(c1i.I, node);\n}\nfunction _shiftCircularArray(arr, count) {\n    count -= arr.length * Math.floor(count / arr.length);\n    const slicedArray = arr.splice(0, count);\n    arr.push(...slicedArray);\n    return arr;\n}\nfunction _getSuperSampledContour(c, nodesPerSegment) {\n    const ci = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let n = 0; n < c.x.length - 1; n++) {\n        ci.x.push(c.x[n]);\n        ci.y.push(c.y[n]);\n        ci.z.push(c.z[n]);\n        ci.I.push(true);\n        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n            ci.I.push(false);\n        }\n    }\n    return ci;\n}\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n    const idx = [];\n    for (let i = 0; i < perimInterp.length; ++i) {\n        idx[i] = i;\n    }\n    idx.sort(function (a, b) {\n        return perimInterp[a] < perimInterp[b] ? -1 : 1;\n    });\n    const perimIndSorted = [];\n    for (let i = 0; i < perimInd.length; i++) {\n        perimIndSorted.push(perimInd[idx[i]]);\n    }\n    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {\n        if (elementValue) {\n            arr.push(i);\n        }\n        return arr;\n    }, []);\n    const nodesPerSegment = [];\n    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n    }\n    return nodesPerSegment;\n}\nfunction _getIndicatorArray(numFalse, numTrue) {\n    const perimInd = new Array(numFalse + numTrue);\n    perimInd.fill(false, 0, numFalse);\n    perimInd.fill(true, numFalse, numFalse + numTrue);\n    return perimInd;\n}\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n    const diff = 1 / (numNodes - 1);\n    const linspace = [diff];\n    for (let i = 1; i < numNodes - 2; i++) {\n        linspace.push(linspace[linspace.length - 1] + diff);\n    }\n    return linspace.concat(cumPerimNorm);\n}\nfunction _normalisedCumulativePerimeter(cumPerim) {\n    const cumPerimNorm = [];\n    for (let i = 0; i < cumPerim.length; i++) {\n        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n    }\n    return cumPerimNorm;\n}\nfunction _getCumulativePerimeter(contour) {\n    const cumulativePerimeter = [0];\n    for (let i = 1; i < contour.x.length; i++) {\n        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +\n            (contour.y[i] - contour.y[i - 1]) ** 2 +\n            (contour.z[i] - contour.z[i - 1]) ** 2);\n        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n    }\n    return cumulativePerimeter;\n}\nfunction _generateClosedContour(points) {\n    const c = {\n        x: [],\n        y: [],\n        z: [],\n    };\n    for (let i = 0; i < points.length; i++) {\n        c.x[i] = points[i][0];\n        c.y[i] = points[i][1];\n        c.z[i] = points[i][2];\n    }\n    c.x.push(c.x[0]);\n    c.y.push(c.y[0]);\n    c.z.push(c.z[0]);\n    return c;\n}\nexport default interpolate;\n","import * as annotationState from '../../../stateManagement/annotation';\nexport default function updateChildInterpolationUID(annotation) {\n    const { parentAnnotationUID, annotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return annotation.interpolationUID;\n    }\n    const parentAnnotation = annotationState.state.getAnnotation(parentAnnotationUID);\n    const { interpolationUID } = parentAnnotation;\n    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n    annotation.interpolationUID = `${interpolationUID}-${index}`;\n    return annotation.interpolationUID;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { Calculator, InstanceCalculator } from './Calculator';\nconst { PointsManager } = utilities;\nfunction createBasicStatsState(storePointData) {\n    return {\n        max: [-Infinity],\n        min: [Infinity],\n        sum: [0],\n        count: 0,\n        maxIJK: null,\n        maxLPS: null,\n        minIJK: null,\n        minLPS: null,\n        runMean: [0],\n        m2: [0],\n        m3: [0],\n        m4: [0],\n        allValues: [[]],\n        pointsInShape: storePointData ? PointsManager.create3(1024) : null,\n        sumLPS: [0, 0, 0],\n    };\n}\nfunction basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {\n    if (Array.isArray(newValue) &&\n        newValue.length > 1 &&\n        state.max.length === 1) {\n        state.max.push(state.max[0], state.max[0]);\n        state.min.push(state.min[0], state.min[0]);\n        state.sum.push(state.sum[0], state.sum[0]);\n        state.runMean.push(0, 0);\n        state.m2.push(state.m2[0], state.m2[0]);\n        state.m3.push(state.m3[0], state.m3[0]);\n        state.m4.push(state.m4[0], state.m4[0]);\n        state.allValues.push([], []);\n    }\n    if (state?.pointsInShape && pointLPS) {\n        state.pointsInShape.push(pointLPS);\n    }\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    state.count += 1;\n    if (pointLPS) {\n        state.sumLPS[0] += pointLPS[0];\n        state.sumLPS[1] += pointLPS[1];\n        state.sumLPS[2] += pointLPS[2];\n    }\n    state.max.forEach((it, idx) => {\n        const value = newArray[idx];\n        state.allValues[idx].push(value);\n        const n = state.count;\n        const delta = value - state.runMean[idx];\n        const delta_n = delta / n;\n        const term1 = delta * delta_n * (n - 1);\n        state.sum[idx] += value;\n        state.runMean[idx] += delta_n;\n        state.m4[idx] +=\n            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +\n                6 * delta_n * delta_n * state.m2[idx] -\n                4 * delta_n * state.m3[idx];\n        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];\n        state.m2[idx] += term1;\n        if (value < state.min[idx]) {\n            state.min[idx] = value;\n            if (idx === 0) {\n                state.minIJK = pointIJK ? [...pointIJK] : null;\n                state.minLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n        if (value > state.max[idx]) {\n            state.max[idx] = value;\n            if (idx === 0) {\n                state.maxIJK = pointIJK ? [...pointIJK] : null;\n                state.maxLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n    });\n}\nfunction calculateMedian(values) {\n    if (values.length === 0) {\n        return 0;\n    }\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    else {\n        return sorted[mid];\n    }\n}\nfunction basicGetStatistics(state, unit) {\n    const mean = state.sum.map((sum) => sum / state.count);\n    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));\n    const center = state.sumLPS.map((sum) => sum / state.count);\n    const skewness = state.m3.map((m3, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m3 / (state.count * Math.pow(variance, 1.5));\n    });\n    const kurtosis = state.m4.map((m4, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m4 / (state.count * variance * variance) - 3;\n    });\n    const median = state.allValues.map((values) => calculateMedian(values));\n    const named = {\n        max: {\n            name: 'max',\n            label: 'Max Pixel',\n            value: state.max.length === 1 ? state.max[0] : state.max,\n            unit,\n            pointIJK: state.maxIJK ? [...state.maxIJK] : null,\n            pointLPS: state.maxLPS ? [...state.maxLPS] : null,\n        },\n        min: {\n            name: 'min',\n            label: 'Min Pixel',\n            value: state.min.length === 1 ? state.min[0] : state.min,\n            unit,\n            pointIJK: state.minIJK ? [...state.minIJK] : null,\n            pointLPS: state.minLPS ? [...state.minLPS] : null,\n        },\n        mean: {\n            name: 'mean',\n            label: 'Mean Pixel',\n            value: mean.length === 1 ? mean[0] : mean,\n            unit,\n        },\n        stdDev: {\n            name: 'stdDev',\n            label: 'Standard Deviation',\n            value: stdDev.length === 1 ? stdDev[0] : stdDev,\n            unit,\n        },\n        count: {\n            name: 'count',\n            label: 'Voxel Count',\n            value: state.count,\n            unit: null,\n        },\n        median: {\n            name: 'median',\n            label: 'Median',\n            value: median.length === 1 ? median[0] : median,\n            unit,\n        },\n        skewness: {\n            name: 'skewness',\n            label: 'Skewness',\n            value: skewness.length === 1 ? skewness[0] : skewness,\n            unit: null,\n        },\n        kurtosis: {\n            name: 'kurtosis',\n            label: 'Kurtosis',\n            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,\n            unit: null,\n        },\n        maxLPS: {\n            name: 'maxLPS',\n            label: 'Max LPS',\n            value: state.maxLPS ? Array.from(state.maxLPS) : null,\n            unit: null,\n        },\n        minLPS: {\n            name: 'minLPS',\n            label: 'Min LPS',\n            value: state.minLPS ? Array.from(state.minLPS) : null,\n            unit: null,\n        },\n        pointsInShape: state.pointsInShape,\n        center: {\n            name: 'center',\n            label: 'Center',\n            value: center ? [...center] : null,\n            unit: null,\n        },\n        array: [],\n    };\n    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);\n    if (named.center.value) {\n        named.array.push(named.center);\n    }\n    const store = state.pointsInShape !== null;\n    const freshState = createBasicStatsState(store);\n    state.max = freshState.max;\n    state.min = freshState.min;\n    state.sum = freshState.sum;\n    state.count = freshState.count;\n    state.maxIJK = freshState.maxIJK;\n    state.maxLPS = freshState.maxLPS;\n    state.minIJK = freshState.minIJK;\n    state.minLPS = freshState.minLPS;\n    state.runMean = freshState.runMean;\n    state.m2 = freshState.m2;\n    state.m3 = freshState.m3;\n    state.m4 = freshState.m4;\n    state.allValues = freshState.allValues;\n    state.pointsInShape = freshState.pointsInShape;\n    state.sumLPS = freshState.sumLPS;\n    return named;\n}\nexport class BasicStatsCalculator extends Calculator {\n    static { this.state = createBasicStatsState(true); }\n    static statsInit(options) {\n        if (!options.storePointData) {\n            this.state.pointsInShape = null;\n        }\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {\n        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);\n    }; }\n    static { this.getStatistics = (options) => {\n        return basicGetStatistics(this.state, options?.unit);\n    }; }\n}\nexport class InstanceBasicStatsCalculator extends InstanceCalculator {\n    constructor(options) {\n        super(options);\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsInit(options) {\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsCallback(data) {\n        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);\n    }\n    getStatistics(options) {\n        return basicGetStatistics(this.state, options?.unit);\n    }\n}\n","export default function getCanvasEllipseCorners(ellipseCanvasPoints) {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [topLeft, bottomRight];\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End, infinite = false) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    if (infinite) {\n        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (Math.abs(denom) < 1e-10) {\n            return undefined;\n        }\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        const x = x1 + t * (x2 - x1);\n        const y = y1 + t * (y2 - y1);\n        return [x, y];\n    }\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return undefined;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return undefined;\n    }\n    const denomSegment = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denomSegment;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denomSegment;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n","import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldSmooth(configuration, annotation) {\n    if (annotation?.autoGenerated) {\n        return false;\n    }\n    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||\n        configuration?.smoothing?.smoothOnEdit === true;\n    return shouldSmooth;\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation, smoothing } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n","import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {\n    if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        if (!imageId) {\n            return [];\n        }\n        const colonIndex = imageId.indexOf(':');\n        filterOptions.imageURI = imageId.substring(colonIndex + 1);\n    }\n    return annotations.filter((annotation) => {\n        if (!annotation.isVisible) {\n            return false;\n        }\n        if (annotation.data.isCanvasAnnotation) {\n            return true;\n        }\n        return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n    });\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport function filterAnnotationsWithinSamePlane(annotations, camera) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    return annotationsWithParallelNormals;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!td.metadata.referencedImageId &&\n            !annotationViewPlaneNormal &&\n            td.metadata.FrameOfReferenceUID) {\n            for (const point of td.data.handles.points) {\n                const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                const dotProduct = vec3.dot(vector, camera.viewPlaneNormal);\n                if (!isEqual(dotProduct, 0)) {\n                    return false;\n                }\n            }\n            td.metadata.viewPlaneNormal = camera.viewPlaneNormal;\n            td.metadata.cameraFocalPoint = camera.focalPoint;\n            return true;\n        }\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const data = annotation.data;\n        const point = data.handles.points[0] || data.contour?.polyline[0];\n        if (!annotation.isVisible) {\n            continue;\n        }\n        const dir = vec3.create();\n        if (!point) {\n            annotationsWithinSlice.push(annotation);\n            continue;\n        }\n        vec3.sub(dir, focalPoint, point);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const points = getPointsInLineOfSight(viewport, worldPos, {\n        targetVolumeId,\n        stepSize,\n    });\n    let pickedPoint;\n    for (const point of points) {\n        const intensity = viewport.getIntensityFromWorld(point);\n        const pointToPick = criteriaFunction(intensity, point);\n        if (pointToPick) {\n            pickedPoint = pointToPick;\n        }\n    }\n    return pickedPoint;\n}\nexport function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal: normalDirection } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize || 1;\n    const bounds = viewport.getBounds();\n    const points = [];\n    let currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] += normalDirection[0] * step;\n        currentPos[1] += normalDirection[1] * step;\n        currentPos[2] += normalDirection[2] * step;\n    }\n    currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] -= normalDirection[0] * step;\n        currentPos[1] -= normalDirection[1] * step;\n        currentPos[2] -= normalDirection[2] * step;\n    }\n    return points;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    const padding = 10;\n    return (point[0] > xMin + padding &&\n        point[0] < xMax - padding &&\n        point[1] > yMin + padding &&\n        point[1] < yMax - padding &&\n        point[2] > zMin + padding &&\n        point[2] < zMax - padding);\n};\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {\n    const vertices = [\n        vec3.fromValues(minX, minY, minZ),\n        vec3.fromValues(maxX, minY, minZ),\n        vec3.fromValues(minX, maxY, minZ),\n        vec3.fromValues(maxX, maxY, minZ),\n        vec3.fromValues(minX, minY, maxZ),\n        vec3.fromValues(maxX, minY, maxZ),\n        vec3.fromValues(minX, maxY, maxZ),\n        vec3.fromValues(maxX, maxY, maxZ),\n    ];\n    const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n    const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n    const planeDistance = -vec3.dot(normalVec, originVec);\n    let initialSign = null;\n    for (const vertex of vertices) {\n        const distance = vec3.dot(normalVec, vertex) + planeDistance;\n        if (initialSign === null) {\n            initialSign = Math.sign(distance);\n        }\n        else if (Math.sign(distance) !== initialSign) {\n            return true;\n        }\n    }\n    return false;\n};\n","import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport EventTypes from '../../../enums/Events';\nexport default function deleteRelatedAnnotations(viewportData) {\n    const { annotation } = viewportData;\n    const interpolationAnnotations = getInterpolationData(viewportData, [\n        { key: 'interpolationUID', value: viewportData.interpolationUID },\n    ]);\n    const referencedSliceIndex = annotation.metadata.sliceIndex;\n    let minInterpolation = -1;\n    let maxInterpolation = viewportData.sliceData.numberOfSlices;\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);\n        if (!nonInterpolated) {\n            continue;\n        }\n        if (sliceIndex < referencedSliceIndex) {\n            minInterpolation = Math.max(sliceIndex, minInterpolation);\n        }\n        else {\n            maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n        }\n    }\n    const removedAnnotations = [];\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex <= minInterpolation ||\n            sliceIndex >= maxInterpolation ||\n            sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        annotations.forEach((annotationToDelete) => {\n            if (annotationToDelete.autoGenerated) {\n                annotationStateManagement.state.removeAnnotation(annotationToDelete.annotationUID);\n                removedAnnotations.push(annotationToDelete);\n            }\n        });\n    }\n    if (removedAnnotations.length) {\n        const eventDetails = {\n            annotations: removedAnnotations,\n            element: viewportData.viewport.element,\n            viewportId: viewportData.viewport.id,\n            renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n        };\n        triggerEvent(viewportData.viewport.element, EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);\n    }\n    if (minInterpolation >= 0 &&\n        maxInterpolation < viewportData.sliceData.numberOfSlices) {\n        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];\n        const viewportNewData = {\n            viewport: viewportData.viewport,\n            sliceData: {\n                numberOfSlices: viewportData.sliceData.numberOfSlices,\n                imageIndex: nextAnnotation.metadata.sliceIndex,\n            },\n            annotation: nextAnnotation,\n            interpolationUID: nextAnnotation.interpolationUID,\n        };\n        interpolate(viewportNewData);\n    }\n}\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport addRepresentationData from '../../stateManagement/segmentation/internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport debounce from '../debounce';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n","import { SegmentationRepresentations } from '../../enums';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';\nimport { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';\nexport function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {\n    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActive = activeSegmentation?.segmentationId === segmentationId;\n    const style = segmentationStyle.getStyle({\n        viewportId,\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n        segmentIndex,\n    });\n    const mergedConfig = style;\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n    if (autoGenerated) {\n        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    }\n    else if (isActive) {\n        lineWidth = mergedConfig.outlineWidth ?? lineWidth;\n        lineDash = mergedConfig.outlineDash ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    }\n    else {\n        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n        lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {\n        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const isVisible = !hiddenSegments.has(segmentIndex);\n    return {\n        color,\n        fillColor,\n        lineWidth,\n        fillOpacity,\n        lineDash,\n        textbox: {\n            color,\n        },\n        visibility: segmentationVisible && isVisible,\n    };\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n"],"names":["annotationUID","drawingElementType","nodeUID","evt","shiftKey","ctrlKey","ShiftCtrl","altKey","ShiftAlt","metaKey","ShiftMeta","Shift","CtrlAlt","CtrlMeta","Ctrl","AltMeta","Alt","Meta","triggerAnnotationAddedForElement","annotation","element","enabledElement","getEnabledElement","renderingEngine","viewportId","eventType","Events","ANNOTATION_ADDED","eventDetail","renderingEngineId","id","triggerEvent","eventTarget","triggerAnnotationAddedForFOR","toolName","metadata","toolGroups","getToolGroupsWithToolName","length","viewportsToRender","forEach","toolGroup","viewportsInfo","viewportInfo","FrameOfReferenceUID","getEnabledElementByIds","push","triggerAnnotationRemoved","ANNOTATION_REMOVED","triggerAnnotationModified","changeType","ChangeTypes","HandlesUpdated","ANNOTATION_MODIFIED","triggerAnnotationCompleted","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","contourHoleProcessingEnabled","ANNOTATION_COMPLETED","defaultManager","resetAnnotationManager","setAnnotationManager","setPreprocessingFn","uid","data","cachedStats","checkAndDefineCachedStatsProperty","handles","textBox","checkAndDefineTextBoxProperty","isLocked","checkAndSetAnnotationLocked","isVisible","checkAndSetAnnotationVisibility","triggerSegmentationAdded","segmentationId","SEGMENTATION_ADDED","triggerSegmentationModified","SEGMENTATION_MODIFIED","triggerSegmentationRemoved","SEGMENTATION_REMOVED","triggerSegmentationRepresentationModified","type","SEGMENTATION_REPRESENTATION_MODIFIED","triggerSegmentationRepresentationRemoved","SEGMENTATION_REPRESENTATION_REMOVED","internalGetHiddenSegmentIndices","specifier","representation","Set","Object","entries","segments","reduce","acc","segmentIndex","segment","visible","add","Number","MODES","ToolModes","Active","Passive","Enabled","filter","toolOptions","toolGroupToolNames","keys","i","includes","mode","getSubPixelSpacingAndXYDirections","addCanvasPointsToArray","getArea","polyline","activateClosedContourEdit","viewportIdsToRender","this","isEditingClosed","detail","currentPoints","canvasPos","canvas","viewport","prevCanvasPoints","contour","map","worldToCanvas","spacing","xDir","yDir","configuration","subPixelResolution","editData","editCanvasPoints","startCrossingIndex","undefined","editIndex","commonData","movingTextBox","isInteractingWithTool","addEventListener","MOUSE_UP","mouseUpClosedContourEditCallback","MOUSE_DRAG","mouseDragClosedContourEditCallback","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","hideElementCursor","deactivateClosedContourEdit","removeEventListener","resetElementCursor","worldPos","world","createMemo","lastCanvasPoint","lastWorldPoint","canvasToWorld","worldPosDiff","xDist","Math","abs","yDist","checkAndRemoveCrossesOnEditLine","currentEditIndex","checkForFirstCrossing","snapIndex","findSnapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","checkForSecondCrossing","removePointsAfterSecondCrossing","finishEditAndStartNewEdit","points","closed","targetWindingDirection","Clockwise","autoGenerated","lastEditCanvasPoint","pop","augmentedEditCanvasPoints","lowIndex","highIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","canvasPoint","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","doneEditMemo","updatedPoints","decimateConfig","decimate","enabled","epsilon","cancelClosedContourEdit","toolInstance","bind","pointsAreWithinCloseContourProximity","getFirstLineSegmentIntersectionIndexes","activateDraw","isDrawing","event","contourHoleAdditionModifierKey","drawData","canvasPoints","polylineIndex","newAnnotation","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","deltaPoints","worldPosDelta","worldPosition","hasMoved","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","invalidated","allowOpenContours","firstPoint","lastPoint","closeContourProximity","completeDrawOpenContour","completeDrawClosedContour","options","removeCrossedLinesOnCompleteDraw","minPointsToSave","haltDrawing","updateContourPolyline","numPoints","endToStart","canvasPointsMinusEnds","slice","lineSegment","indexToRemoveUpTo","splice","worldPoints","isOpenUShapeContour","openUShapeContourVectorToPeak","lastPoints","pointsLessLastOne","remainingPoints","newArea","utilities","cancelDrawing","minPoints","max","shouldHaltDrawing","removeAnnotation","isClosedContour","crossedLineSegment","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","distance","index","sort","a","b","twoClosestDistanceIndexPairs","lowestIndex","min","dir","proximity","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","unshift","numPointsToRemove","firstLine","lastLine","didCrossLine","editCanvasPointsLessLastOne","snapCanvasPosition","editIndexCrossed","findOpenUShapedContourVectorToPeak","first","last","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","dist","findOpenUShapedContourVectorToPeakOnRender","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activeHandleIndex","activateOpenContourEndEdit","lastCanvasPos","p1","p2","p3","aDotb","magA","sqrt","magB","acos","PI","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","handle","reverse","_getRenderingOptions","styleSpecifier","toolGroupId","getToolName","lineWidth","lineDash","color","fillColor","fillOpacity","getAnnotationStyle","width","closePath","renderContour","svgDrawingHelper","getImageData","renderClosedContour","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","parentAnnotationUID","allContours","drawPath","drawPolyline","alwaysRenderOpenContourHandles","radius","handleGroupUID","handlePoints","shift","drawHandles","handleRadius","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","canvasPolyline","childContours","center","circlePoints","angle","x","cos","y","sin","crosshair","polylineUID","DefaultHistoryMemo","PointsManager","AnnotationTool","A","createAnnotation","annotationBaseData","highlighted","text","Array","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","getViewReference","createAndAddAnnotation","addAnnotation","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","isAnnotationLocked","isAnnotationVisible","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","isSuvScaled","getTextLines","statsCalculator","getHandleNearImagePoint","isCanvasAnnotation","canvasBoundingBox","point","annotationCanvasCoordinate","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","shadow","background","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","context","property","locked","angleArcLineDash","markerSize","lineOpacity","textbox","isPointNearTool","createAnnotationState","deleting","cloneData","spline","state","structuredClone","pointsManager","create3","createAnnotationMemo","annotationMemo","restoreMemo","newState","setViewReference","assign","annotationData","segmentation","addContourSegmentationAnnotation","setAnnotationSelected","render","currentAnnotation","getAnnotation","History","console","warn","operationType","memo","hydrateBase","ToolClass","getFrameOfReferenceUID","camera","getCamera","viewPlaneNormal","viewplaneNormal","viewUp","instance","referencedImageId","finalViewPlaneNormal","finalViewUp","StackViewport","closestImageIndex","getImageIds","Error","getReferencedImageId","ContourBaseTool","renderAnnotation","renderStatus","getRenderingEngine","annotations","getAnnotations","filterInteractableAnnotationsForElement","getTargetId","annotationStyle","annotationRendered","renderAnnotationInstance","interpolationUID","cancelAnnotation","moveAnnotation","getChildAnnotations","childAnnotation","polylineData","transforms","updateWindingDirection","getPolylinePoints","renderContext","polylineCanvasPoints","getContourHolesDataCanvas","ContourSegmentationBaseTool","PreviewSegmentIndex","interpolation","InterpolationManager","addTool","isContourSegmentationTool","contourAnnotation","activeSeg","getActiveSegmentation","representationData","Contour","getActiveSegmentIndex","contourSegAnnotation","removeContourSegmentationAnnotation","contourSegmentationStyle","_getContourSegmentationStyle","renderResult","triggerSegmentationDataModified","toolGroupIds","getViewportIdsWithSegmentation","getToolGroupForViewport","triggerAnnotationRenderForToolGroupIds","segmentationRepresentations","getSegmentationRepresentation","segmentationRepresentation","find","rep","SegmentationRepresentations","annotationLocked","getLockedSegmentIndices","getSVGStyleForSegment","defaultContourConfig","renderOutline","outlineWidthAutoGenerated","outlineWidth","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","outlineDash","outlineDashInactive","outlineDashAutoGenerated","activeSegmentOutlineWidthDelta","renderFill","fillAlpha","fillAlphaInactive","fillAlphaAutoGenerated","handleContourSegmentation","geometryIds","annotationUIDsMap","contourRepresentation","size","segmentSpecificMap","Map","geometryId","geometry","getGeometry","Enums","CONTOUR","validateGeometry","segmentSpecificConfig","contourSet","contours","contourSegmentationAnnotation","annotationGroupSelector","set","addContourSetsToElement","removeFromCache","annotationSet","internalCache","load","cfun","ofun","actor","getProperty","setRGBTransferFunction","setScalarOpacity","uuidv4","async","labelMapData","config","getSegmentation","Labelmap","_ensureVolumeHasVolumeId","stackData","imageIds","volumeLoader","_handleMissingVolume","blendMode","MAXIMUM_INTENSITY_BLEND","useIndependentComponents","LABELMAP_EDGE_PROJECTION_BLEND","referenceVolumeId","getVolumeId","baseVolume","segDims","dimensions","refDims","debug","volumeInputs","representationUID","result","defaultActor","getDefaultActor","callback","get","added","volumeInputArray","firstImageVolume","segImageVolume","segData","voxelManager","getCompleteScalarDataArray","imageData","segImageData","cubeData","Float32Array","getScalarDataLength","dims","getDimensions","z","iTuple","removeActors","oldMapper","getMapper","mapper","convertMapperToNotSharedMapper","setMapper","setBlendMode","arrayAgain","getInputData","getPointData","getArray","onSegmentationDataModified","segVolumeId","segVoxelManager","array","getData","slices","from","_","getAtIndex","setData","modified","setNumberOfComponents","setColorMixPreset","setForceNearestInterpolation","setIndependentComponents","addActor","referencedId","segmentationRepresentationUID","originalBlendMode","getBlendMode","preLoad","addEventListenerDebounced","SEGMENTATION_DATA_MODIFIED","actorEntry","getActor","createVolumeActor","volumeActor","addVolumesAsIndependentComponents","addVolumesToViewports","stackInputs","addImageSlicesToViewports","defaultLabelmapConfig","renderOutlineInactive","renderFillInactive","surface","surfaceActorEntry","surfaceActor","setVisibility","surfaceMapper","currentPolyData","newPoints","newPolys","polys","getPoints","currentPolys","getPolys","polyData","triangles","values","setPolys","setInputData","getRenderer","resetCameraClippingRange","surfacePolyData","setColor","setLineWidth","clippingFilter","resetCamera","filteredSurfaceActors","getActors","startsWith","BrushStrategy","COMPOSITIONS","childFunctions","StrategyCallbacks","OnInteractionStart","addListMethod","Initialize","OnInteractionEnd","Fill","CreateIsInThreshold","addSingletonMethod","Interpolate","AcceptPreview","RejectPreview","INTERNAL_setValue","Preview","ComputeInnerCircleRadius","EnsureSegmentationVolumeFor3DManipulation","EnsureImageVolumeFor3DManipulation","AddPreview","GetStatistics","compositions","name","initializers","_initialize","_fill","_onInteractionStart","fill","operationData","initializedData","initialize","func","segmentationVoxelManager","getArrayOfModifiedSlices","onInteractionStart","call","addPreview","configurationName","initializer","key","strategyFunction","operationName","strategy","imageVoxelManager","segmentationImageData","centerWorld","isInObject","isInObjectBoundsIJK","brushStrategy","createInitialized","listName","args","returnValue","value","isInitialized","previewSegmentIndex","centerIJK","useCenterSegmentIndex","hasSegmentIndex","hasPreviewIndex","nestedBounds","getBoundsIJK","boundsIJK","centerSegmentIndexInfo","existingValue","getAtIJKPoint","threshold","isDynamic","range","oldThreshold","dynamicRadius","useDelta","ijk","idx","Infinity","useDeltaSqr","pointIJK","gray","isArray","dynamicRadiusInCanvas","centerCanvas","clientWidth","clientHeight","radiusInWorld","offSetCenterInWorld","coord","offSetCenterCanvas","activeStrategy","islandRemoval","floodFillSegmentIsland","removeExternalIslands","removeInternalIslands","arrayOfSlices","preview","onInteractionEnd","previewColor","viewportIds","setSegmentIndexColor","changedIndices","labelmapMemo","oldValue","setAtIndex","undoIf","hasPreviewSegmentIndex","segmentsLocked","isWithinThreshold","createIsInThreshold","setValue","addPoint","useSegmentIndex","previewOnHover","centerSegmentIndex","handleUseSegmentCenterIndex","voxelValue","indices","getStatistics","segmentIndices","determineSegmentIndex","dynamicThreshold","erase","regionFill","labelmapStatistics","ensureSegmentationVolumeFor3DManipulation","ensureImageVolumeFor3DManipulation","eraseInsideCircle","eraseInsideSphere","transformWorldToIndex","sphereComposition","newBoundsIJK","topLeftWorld","bottomRightWorld","SPHERE_STRATEGY","fillInsideSphere","SPHERE_THRESHOLD_STRATEGY","SPHERE_THRESHOLD_STRATEGY_ISLAND","thresholdInsideSphere","thresholdInsideSphereIsland","getStrategyData","referencedVolumeId","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","segmentationVolume","imageVolume","segmentationScalarData","imageScalarData","getStrategyDataForVolumeViewport","labelmapImageId","getCurrentLabelmapImageIdForViewport","currentSegImage","getImage","currentSegmentationImageId","segmentationImage","getPixelData","currentImageId","getCurrentImageId","image","getScalarData","getStrategyDataForStackViewport","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","orderedPoints","pointsArrayWithPrecision","flat","toFixed","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","DEFAULT_CONTOUR_SEG_TOOLNAME","getInterpolationData","viewportData","filterParams","sliceData","interpolationDatas","originalToolName","testToolName","modifiedAnnotations","numberOfSlices","imageAnnotations","sliceIndex","filteredInterpolatedAnnotations","imageAnnotation","every","parent","parentKey","item","getInterpolationDataCollection","interpolatedDataCollection","createPolylineToolData","referencedToolData","childAnnotationUIDs","interpolationSources","sources","_sliceNeedsInterpolating","interpolationData","_appendInterpolationList","contourPair","interpolationList","itemIndex","startIndex","pair","list","_getBoundingPair","sliceRange","annotationPair","canInterpolate","rangeToInterpolate","found","getRangeToInterpolate","sliceEdited","j","_getSlicePositionOfToolData","selectHandles","handleCount","destPoints","sourcePoints","subselect","interval","floor","dotValues","prevVec3","nextVec3","getPoint","prevPoint","nextPoint","dot","createDotValues","minimumRegions","deviation","sum","sumSq","mean","valueDiff","getStats","inflection","minValue","minIndex","findMinimumRegions","lastHandle","thirdInterval","region","start","end","midIndex","ceil","addInterval","firstHandle","indexValue","getPointArray","source","destSourceIndex","finish","count","v","round","dP","_linearlyInterpolateBetween","eventData","annotation0","annotation1","c1","_generateClosedContour","c2","c1Interp","c2Interp","cumPerim1","_getCumulativePerimeter","cumPerim2","interpNodes","cumPerim1Norm","_normalisedCumulativePerimeter","cumPerim2Norm","numNodes1","numNodes2","perim1Interp","_getInterpolatedPerim","perim2Interp","perim1Ind","_getIndicatorArray","perim2Ind","nodesPerSegment1","_getNodesPerSegment","nodesPerSegment2","c1i","_getSuperSampledContour","c2i","c1iLength","optimal","startingNode","totalSquaredXYLengths","node","iteration","_shiftCircularArray","I","_shiftSuperSampledContourInPlace","_reduceContoursToOriginNodes","_generateInterpolationContourPair","kIndex","c1HasMoreNodes","endIndex","zInterp","interpolated3DPoints","c1ir","c2ir","fromXYZ","cInterp","vecSubtract","vecResult","c1Source","c2Source","c1point","c2point","_generateInterpolatedOpenContour","nearestAnnotation","has","oldAnnotationData","_findExistingAnnotation","interpolatedAnnotation","_editInterpolatedContour","viewRef","onInterpolationComplete","parentAnnotation","createPolylineHole","_addInterpolatedContour","_linearlyInterpolateContour","arr","slicedArray","c","nodesPerSegment","ci","n","xSpacing","ySpacing","zSpacing","perimInterp","perimInd","perimIndSorted","indicesOfOriginNodes","elementValue","numFalse","numTrue","numNodes","cumPerimNorm","diff","linspace","concat","cumPerim","cumulativePerimeter","lengthOfSegment","isInterpolationUpdate","queueMicrotask","indexOf","updateChildInterpolationUID","toolType","eventDetails","ANNOTATION_INTERPOLATION_PROCESS_COMPLETED","startInterpolation","createBasicStatsState","storePointData","maxIJK","maxLPS","minIJK","minLPS","runMean","m2","m3","m4","allValues","pointsInShape","sumLPS","basicStatsCallback","newValue","pointLPS","newArray","it","delta","delta_n","term1","basicGetStatistics","unit","stdDev","squaredDiffSum","skewness","variance","pow","kurtosis","median","sorted","mid","calculateMedian","named","freshState","BasicStatsCalculator","statsInit","statsCallback","InstanceBasicStatsCalculator","getCanvasEllipseCorners","ellipseCanvasPoints","bottom","top","left","right","distanceToPoint","lineStart","lineEnd","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","infinite","x1","y1","x2","y2","x3","y3","x4","y4","denom","t","a1","b1","r3","r4","a2","b2","r1","r2","denomSegment","num","rect","height","minDistance","lineSegments","rectToLineSegments","interpolatePoints","originalPoints","knotsIndexes","xInterpolator","k","yInterpolator","zInterpolator","shouldSmooth","smoothing","smoothOnAdd","smoothOnEdit","isEqual","pointA","pointB","followingIndex","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","knotsRatioPercentage","changedIniIndex","changedEndIndex","filterAnnotationsForDisplay","filterOptions","VolumeViewport","spacingInNormalDirection","colonIndex","imageURI","substring","isReferenceViewable","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","filterAnnotationsWithinSamePlane","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","filterAnnotationsWithinSlice","vector","focalPoint","dotProduct","cameraFocalPoint","halfSpacingInNormalDirection","annotationsWithinSlice","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","getPointsInLineOfSight","pickedPoint","pointToPick","getIntensityFromWorld","normalDirection","step","bounds","getBounds","currentPos","_inBounds","xMin","xMax","yMin","yMax","zMin","zMax","padding","getWorldWidthAndHeightFromCorners","viewRight","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getWorldWidthAndHeightFromTwoPoints","worldPos1","worldPos2","isPlaneIntersectingAABB","origin","normal","minX","minY","minZ","maxX","maxY","maxZ","vertices","normalVec","originVec","planeDistance","initialSign","vertex","deleteRelatedAnnotations","interpolationAnnotations","referencedSliceIndex","minInterpolation","maxInterpolation","nonInterpolated","removedAnnotations","annotationToDelete","INTERPOLATED_ANNOTATIONS_REMOVED","nextAnnotation","viewportNewData","imageIndex","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","onComputationComplete","representations","debouncedUpdateFunction","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","segmentColor","getSegmentIndexColor","segmentationVisible","activeSegmentation","isActive","mergedConfig","getViewportIdsWithToolToRender","requireParallelNormals","viewports","getViewports","getViewport","vp"],"sourceRoot":""}